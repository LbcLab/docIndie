\hypertarget{classirr_1_1scene_1_1ISceneManager}{}\section{irr\+:\+:scene\+:\+:I\+Scene\+Manager Class Reference}
\label{classirr_1_1scene_1_1ISceneManager}\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}


The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff.  




{\ttfamily \#include $<$I\+Scene\+Manager.\+h$>$}

Inheritance diagram for irr\+:\+:scene\+:\+:I\+Scene\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classirr_1_1scene_1_1ISceneManager}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{get\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename)=0
\begin{DoxyCompactList}\small\item\em Get pointer to an animateable mesh. Loads the file if not loaded already. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}{get\+Mesh} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file)=0
\begin{DoxyCompactList}\small\item\em Get pointer to an animateable mesh. Loads the file if not loaded already. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshCache}{I\+Mesh\+Cache} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}{get\+Mesh\+Cache} ()=0
\begin{DoxyCompactList}\small\item\em Get interface to the mesh cache which is shared beween all existing scene managers. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IVideoDriver}{video\+::\+I\+Video\+Driver} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}{get\+Video\+Driver} ()=0
\begin{DoxyCompactList}\small\item\em Get the video driver. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1gui_1_1IGUIEnvironment}{gui\+::\+I\+G\+U\+I\+Environment} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}{get\+G\+U\+I\+Environment} ()=0
\begin{DoxyCompactList}\small\item\em Get the active G\+U\+I\+Environment. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1io_1_1IFileSystem}{io\+::\+I\+File\+System} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}{get\+File\+System} ()=0
\begin{DoxyCompactList}\small\item\em Get the active File\+System. \end{DoxyCompactList}\item 
virtual I\+Volume\+Light\+Scene\+Node $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}{add\+Volume\+Light\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} subdivU=32, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} subdivV=32, const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} foot=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51, 0, 230, 180), const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} tail=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0, 0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em adds Volume Lighting Scene Node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}{add\+Cube\+Scene\+Node} (\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} size=10.\+0f, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a cube scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}{add\+Sphere\+Scene\+Node} (\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=5.\+0f, s32 poly\+Count=16, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a sphere scene node of the given radius and detail. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}{add\+Animated\+Mesh\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f), bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering an animated mesh model. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}{add\+Mesh\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f), bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering a static mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}{add\+Water\+Surface\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} wave\+Height=2.\+0f, f32 wave\+Speed=300.\+0f, f32 wave\+Length=10.\+0f, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering a animated water surface mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}{add\+Octree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=512, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}{add\+Oct\+Tree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=512, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}{add\+Octree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=256, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}{add\+Oct\+Tree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=256, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}{add\+Camera\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&lookat=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 100), \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a camera scene node to the scene graph and sets it as active camera. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}{add\+Camera\+Scene\+Node\+Maya} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} rotate\+Speed=-\/1500.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} zoom\+Speed=200.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} translation\+Speed=1500.f, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} distance=70.f, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a maya style user controlled camera scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}{add\+Camera\+Scene\+Node\+F\+PS} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} rotate\+Speed=100.\+0f, f32 move\+Speed=0.\+5f, s32 id=-\/1, S\+Key\+Map $\ast$key\+Map\+Array=0, s32 key\+Map\+Size=0, bool no\+Vertical\+Movement=false, f32 jump\+Speed=0.\+f, bool invert\+Mouse=false, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (F\+PS). \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ILightSceneNode}{I\+Light\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}{add\+Light\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} color=\hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}(1.\+0f, 1.\+0f, 1.\+0f), f32 radius=100.\+0f, s32 id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a dynamic light scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IBillboardSceneNode}{I\+Billboard\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}{add\+Billboard\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), s32 id=-\/1, video\+::\+S\+Color color\+Top=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color color\+Bottom=0x\+F\+F\+F\+F\+F\+F\+F\+F)=0
\begin{DoxyCompactList}\small\item\em Adds a billboard scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}{add\+Sky\+Box\+Scene\+Node} (\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$top, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$bottom, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$left, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$right, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$front, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$back, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a skybox scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}{add\+Sky\+Dome\+Scene\+Node} (\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} hori\+Res=16, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} vert\+Res=8, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} texture\+Percentage=0.\+9, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} sphere\+Percentage=2.\+0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=1000.f, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a skydome scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode}{I\+Particle\+System\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}{add\+Particle\+System\+Scene\+Node} (bool with\+Default\+Emitter=true, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a particle system scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}{add\+Terrain\+Scene\+Node} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&height\+Map\+File\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&rotation=core\+::vector3df(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f), video\+::\+S\+Color vertex\+Color=video\+::\+S\+Color(255, 255, 255, 255), s32 max\+L\+O\+D=5, E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+Z\+E patch\+Size=\+E\+T\+P\+S\+\_\+17, s32 smooth\+Factor=0, bool add\+Also\+If\+Heightmap\+Empty=false)=0
\begin{DoxyCompactList}\small\item\em Adds a terrain scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}{add\+Terrain\+Scene\+Node} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$height\+Map\+File, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&rotation=core\+::vector3df(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f), video\+::\+S\+Color vertex\+Color=video\+::\+S\+Color(255, 255, 255, 255), s32 max\+L\+O\+D=5, E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+Z\+E patch\+Size=\+E\+T\+P\+S\+\_\+17, s32 smooth\+Factor=0, bool add\+Also\+If\+Heightmap\+Empty=false)=0
\begin{DoxyCompactList}\small\item\em Adds a terrain scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}{add\+Quake3\+Scene\+Node} (const \hyperlink{classirr_1_1scene_1_1IMeshBuffer}{I\+Mesh\+Buffer} $\ast$mesh\+Buffer, const \hyperlink{structirr_1_1scene_1_1quake3_1_1IShader}{quake3\+::\+I\+Shader} $\ast$shader, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a quake3 scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}{add\+Empty\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds an empty scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IDummyTransformationSceneNode}{I\+Dummy\+Transformation\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}{add\+Dummy\+Transformation\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a dummy transformation scene node to the scene graph. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}\label{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}} 
virtual \hyperlink{classirr_1_1scene_1_1ITextSceneNode}{I\+Text\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}{add\+Text\+Scene\+Node} (\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$font, const wchar\+\_\+t $\ast$text, \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(100, 255, 255, 255), \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a text scene node, which is able to display 2d text at a position in three dimensional space. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IBillboardTextSceneNode}{I\+Billboard\+Text\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}{add\+Billboard\+Text\+Scene\+Node} (\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$font, const wchar\+\_\+t $\ast$text, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), s32 id=-\/1, video\+::\+S\+Color color\+Top=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color color\+Bottom=0x\+F\+F\+F\+F\+F\+F\+F\+F)=0
\begin{DoxyCompactList}\small\item\em Adds a text scene node, which uses billboards. The node, and the text on it, will scale with distance. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}{add\+Hill\+Plane\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&tile\+Size, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&tile\+Count, \hyperlink{classirr_1_1video_1_1SMaterial}{video\+::\+S\+Material} $\ast$material=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} hill\+Height=0.\+0f, const core\+::dimension2d$<$ f32 $>$ \&count\+Hills=core\+::dimension2d$<$ f32 $>$(0.\+0f, 0.\+0f), const core\+::dimension2d$<$ f32 $>$ \&texture\+Repeat\+Count=core\+::dimension2d$<$ f32 $>$(1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a Hill Plane mesh to the mesh pool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}{add\+Terrain\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&meshname, \hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$texture, \hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$heightmap, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&stretch\+Size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), f32 max\+Height=200.\+0f, const core\+::dimension2d$<$ u32 $>$ \&default\+Vertex\+Block\+Size=core\+::dimension2d$<$ u32 $>$(64, 64))=0
\begin{DoxyCompactList}\small\item\em Adds a static terrain mesh to the mesh pool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}{add\+Arrow\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} vtx\+Color\+Cylinder=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color vtx\+Color\+Cone=0x\+F\+F\+F\+F\+F\+F\+F\+F, u32 tesselation\+Cylinder=4, u32 tesselation\+Cone=8, f32 height=1.\+f, f32 cylinder\+Height=0.\+6f, f32 width\+Cylinder=0.\+05f, f32 width\+Cone=0.\+3f)=0
\begin{DoxyCompactList}\small\item\em add a static arrow mesh to the meshpool \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}{add\+Sphere\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=5.f, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} poly\+CountX=16, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} poly\+CountY=16)=0
\begin{DoxyCompactList}\small\item\em add a static sphere mesh to the meshpool \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}{add\+Volume\+Light\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} SubdivideU=32, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} SubdivideV=32, const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} Foot\+Color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51, 0, 230, 180), const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} Tail\+Color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0, 0, 0, 0))=0
\begin{DoxyCompactList}\small\item\em Add a volume light mesh to the meshpool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}{get\+Root\+Scene\+Node} ()=0
\begin{DoxyCompactList}\small\item\em Gets the root scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}{get\+Scene\+Node\+From\+Id} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified id. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}{get\+Scene\+Node\+From\+Name} (const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified name. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}{get\+Scene\+Node\+From\+Type} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{scene\+::\+E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified type. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}{get\+Scene\+Nodes\+From\+Type} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type, \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1scene_1_1ISceneNode}{scene\+::\+I\+Scene\+Node} $\ast$$>$ \&out\+Nodes, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get scene nodes by type. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}{get\+Active\+Camera} () const =0
\begin{DoxyCompactList}\small\item\em Get the current active camera. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}{set\+Active\+Camera} (\hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$camera)=0
\begin{DoxyCompactList}\small\item\em Sets the currently active camera. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}\label{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}} 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}{set\+Shadow\+Color} (\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(150, 0, 0, 0))=0
\begin{DoxyCompactList}\small\item\em Sets the color of stencil buffers shadows drawn by the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}\label{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}} 
virtual \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} \hyperlink{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}{get\+Shadow\+Color} () const =0
\begin{DoxyCompactList}\small\item\em Get the current color of shadows. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}{register\+Node\+For\+Rendering} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} pass=\hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67fad9a67a121247bc1001e35b8a8c0ef20d}{E\+S\+N\+R\+P\+\_\+\+A\+U\+T\+O\+M\+A\+T\+IC})=0
\begin{DoxyCompactList}\small\item\em Registers a node for rendering it at a specific time. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}{draw\+All} ()=0
\begin{DoxyCompactList}\small\item\em Draws all the scene nodes. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}{create\+Rotation\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation\+Speed)=0
\begin{DoxyCompactList}\small\item\em Creates a rotation animator, which rotates the attached scene node around itself. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}{create\+Fly\+Circle\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&center=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f, 0.f, 0.f), \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=100.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} speed=0.\+001f, const core\+::vector3df \&direction=core\+::vector3df(0.\+f, 1.\+f, 0.\+f), f32 start\+Position=0.\+f, f32 radius\+Ellipsoid=0.\+f)=0
\begin{DoxyCompactList}\small\item\em Creates a fly circle animator, which lets the attached scene node fly around a center. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}{create\+Fly\+Straight\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&start\+Point, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&end\+Point, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} time\+For\+Way, bool loop=false, bool pingpong=false)=0
\begin{DoxyCompactList}\small\item\em Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}{create\+Texture\+Animator} (const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$$>$ \&textures, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} time\+Per\+Frame, bool loop=true)=0
\begin{DoxyCompactList}\small\item\em Creates a texture animator, which switches the textures of the target scene node based on a list of textures. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}{create\+Delete\+Animator} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} time\+Ms)=0
\begin{DoxyCompactList}\small\item\em Creates a scene node animator, which deletes the scene node after some time automatically. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}{create\+Collision\+Response\+Animator} (\hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$world, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$scene\+Node, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&ellipsoid\+Radius=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(30, 60, 30), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&gravity\+Per\+Second=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.\+0f, 0), const core\+::vector3df \&ellipsoid\+Translation=core\+::vector3df(0, 0, 0), f32 sliding\+Value=0.\+0005f)=0
\begin{DoxyCompactList}\small\item\em Creates a special scene node animator for doing automatic collision detection and response. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}{create\+Follow\+Spline\+Animator} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} start\+Time, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} $>$ \&points, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} speed=1.\+0f, f32 tightness=0.\+5f, bool loop=true, bool pingpong=false)=0
\begin{DoxyCompactList}\small\item\em Creates a follow spline animator. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}{create\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}{create\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on an animated mesh scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}{create\+Triangle\+Selector\+From\+Bounding\+Box} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple dynamic \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a axis aligned bounding box. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}{create\+Octree\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=32)=0
\begin{DoxyCompactList}\small\item\em Creates a Triangle Selector, optimized by an octree. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}{create\+Oct\+Tree\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=32)
\begin{DoxyCompactList}\small\item\em //! Creates a Triangle Selector, optimized by an octree. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMetaTriangleSelector}{I\+Meta\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}{create\+Meta\+Triangle\+Selector} ()=0
\begin{DoxyCompactList}\small\item\em Creates a meta triangle selector. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}{create\+Terrain\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} L\+OD=0)=0
\begin{DoxyCompactList}\small\item\em Creates a triangle selector which can select triangles from a terrain scene node. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}{add\+External\+Mesh\+Loader} (\hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$external\+Loader)=0
\begin{DoxyCompactList}\small\item\em Adds an external mesh loader for extending the engine with new file formats. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}\label{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}{get\+Mesh\+Loader\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Returns the number of mesh loaders supported by Irrlicht at this time. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}{get\+Mesh\+Loader} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index) const =0
\begin{DoxyCompactList}\small\item\em Retrieve the given mesh loader. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{add\+External\+Scene\+Loader} (\hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$external\+Loader)=0
\begin{DoxyCompactList}\small\item\em Adds an external scene loader for extending the engine with new file formats. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}\label{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}{get\+Scene\+Loader\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Returns the number of scene loaders supported by Irrlicht at this time. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}{get\+Scene\+Loader} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index) const =0
\begin{DoxyCompactList}\small\item\em Retrieve the given scene loader. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneCollisionManager}{I\+Scene\+Collision\+Manager} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}{get\+Scene\+Collision\+Manager} ()=0
\begin{DoxyCompactList}\small\item\em Get pointer to the scene collision manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshManipulator}{I\+Mesh\+Manipulator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}{get\+Mesh\+Manipulator} ()=0
\begin{DoxyCompactList}\small\item\em Get pointer to the mesh manipulator. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}{add\+To\+Deletion\+Queue} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node to the deletion queue. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}{post\+Event\+From\+User} (const \hyperlink{structirr_1_1SEvent}{S\+Event} \&event)=0
\begin{DoxyCompactList}\small\item\em Posts an input event to the environment. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}{clear} ()=0
\begin{DoxyCompactList}\small\item\em Clears the whole scene. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1io_1_1IAttributes}{io\+::\+I\+Attributes} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters} ()=0
\begin{DoxyCompactList}\small\item\em Get interface to the parameters set in this scene. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} \hyperlink{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}{get\+Scene\+Node\+Render\+Pass} () const =0
\begin{DoxyCompactList}\small\item\em Get current render pass. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}{get\+Default\+Scene\+Node\+Factory} ()=0
\begin{DoxyCompactList}\small\item\em Get the default scene node factory which can create all built in scene nodes. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}{register\+Scene\+Node\+Factory} (\hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$factory\+To\+Add)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node factory to the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}\label{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}{get\+Registered\+Scene\+Node\+Factory\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Get amount of registered scene node factories. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}{get\+Scene\+Node\+Factory} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index)=0
\begin{DoxyCompactList}\small\item\em Get a scene node factory by index. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}{get\+Default\+Scene\+Node\+Animator\+Factory} ()=0
\begin{DoxyCompactList}\small\item\em Get the default scene node animator factory which can create all built-\/in scene node animators. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}{register\+Scene\+Node\+Animator\+Factory} (\hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$factory\+To\+Add)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node animator factory to the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}\label{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}{get\+Registered\+Scene\+Node\+Animator\+Factory\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Get amount of registered scene node animator factories. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}{get\+Scene\+Node\+Animator\+Factory} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index)=0
\begin{DoxyCompactList}\small\item\em Get scene node animator factory by index. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}\label{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}} 
virtual const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}{get\+Scene\+Node\+Type\+Name} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Get typename from a scene node type or null if not found. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}\label{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}} 
virtual const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}{get\+Animator\+Type\+Name} (\hyperlink{namespaceirr_1_1scene_a327a1e43872705cf8f3f3342fb307d19}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+A\+N\+I\+M\+A\+T\+O\+R\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Returns a typename from a scene node animator type or null if not found. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}{add\+Scene\+Node} (const char $\ast$scene\+Node\+Type\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node to the scene by name. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}{create\+Scene\+Node\+Animator} (const char $\ast$type\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$target=0)=0
\begin{DoxyCompactList}\small\item\em creates a scene node animator based on its type name \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneManager}{I\+Scene\+Manager} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}{create\+New\+Scene\+Manager} (bool clone\+Content=false)=0
\begin{DoxyCompactList}\small\item\em Creates a new scene manager. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{save\+Scene} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}{save\+Scene} (\hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} $\ast$file, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}{save\+Scene} (\hyperlink{classirr_1_1io_1_1IXMLWriter}{io\+::\+I\+X\+M\+L\+Writer} $\ast$writer, const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&current\+Path, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{load\+Scene} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$root\+Node=0)=0
\begin{DoxyCompactList}\small\item\em Loads a scene. Note that the current scene is not cleared before. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}{load\+Scene} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$root\+Node=0)=0
\begin{DoxyCompactList}\small\item\em Loads a scene. Note that the current scene is not cleared before. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshWriter}{I\+Mesh\+Writer} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}{create\+Mesh\+Writer} (\hyperlink{namespaceirr_1_1scene_a431fa15741518ba15f6d5f2608b6cb4e}{E\+M\+E\+S\+H\+\_\+\+W\+R\+I\+T\+E\+R\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Get a mesh writer implementation if available. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}{create\+Skinned\+Mesh} ()=0
\begin{DoxyCompactList}\small\item\em Get a skinned mesh, which is not available as header-\/only code. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}\label{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}} 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}{set\+Ambient\+Light} (const \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} \&ambient\+Color)=0
\begin{DoxyCompactList}\small\item\em Sets ambient color of the scene. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}\label{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}} 
virtual const \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} \& \hyperlink{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}{get\+Ambient\+Light} () const =0
\begin{DoxyCompactList}\small\item\em Get ambient color of the scene. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}{set\+Light\+Manager} (\hyperlink{classirr_1_1scene_1_1ILightManager}{I\+Light\+Manager} $\ast$light\+Manager)=0
\begin{DoxyCompactList}\small\item\em Register a custom callbacks manager which gets callbacks during scene rendering. \end{DoxyCompactList}\item 
virtual const \hyperlink{classirr_1_1scene_1_1IGeometryCreator}{I\+Geometry\+Creator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}{get\+Geometry\+Creator} (void) const =0
\begin{DoxyCompactList}\small\item\em Get an instance of a geometry creator. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}{is\+Culled} (const \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node) const =0
\begin{DoxyCompactList}\small\item\em Check if node is culled in current view frustum. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{get\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename)=0
\begin{DoxyCompactList}\small\item\em Get pointer to an animateable mesh. Loads the file if not loaded already. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}{get\+Mesh} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file)=0
\begin{DoxyCompactList}\small\item\em Get pointer to an animateable mesh. Loads the file if not loaded already. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshCache}{I\+Mesh\+Cache} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}{get\+Mesh\+Cache} ()=0
\begin{DoxyCompactList}\small\item\em Get interface to the mesh cache which is shared beween all existing scene managers. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IVideoDriver}{video\+::\+I\+Video\+Driver} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}{get\+Video\+Driver} ()=0
\begin{DoxyCompactList}\small\item\em Get the video driver. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1gui_1_1IGUIEnvironment}{gui\+::\+I\+G\+U\+I\+Environment} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}{get\+G\+U\+I\+Environment} ()=0
\begin{DoxyCompactList}\small\item\em Get the active G\+U\+I\+Environment. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1io_1_1IFileSystem}{io\+::\+I\+File\+System} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}{get\+File\+System} ()=0
\begin{DoxyCompactList}\small\item\em Get the active File\+System. \end{DoxyCompactList}\item 
virtual I\+Volume\+Light\+Scene\+Node $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}{add\+Volume\+Light\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} subdivU=32, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} subdivV=32, const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} foot=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51, 0, 230, 180), const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} tail=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0, 0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em adds Volume Lighting Scene Node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}{add\+Cube\+Scene\+Node} (\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} size=10.\+0f, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a cube scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}{add\+Sphere\+Scene\+Node} (\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=5.\+0f, s32 poly\+Count=16, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a sphere scene node of the given radius and detail. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}{add\+Animated\+Mesh\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f), bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering an animated mesh model. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}{add\+Mesh\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f), bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering a static mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}{add\+Water\+Surface\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} wave\+Height=2.\+0f, f32 wave\+Speed=300.\+0f, f32 wave\+Length=10.\+0f, I\+Scene\+Node $\ast$parent=0, s32 id=-\/1, const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), const core\+::vector3df \&rotation=core\+::vector3df(0, 0, 0), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering a animated water surface mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}{add\+Octree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=512, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}{add\+Oct\+Tree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=512, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}{add\+Octree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=256, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}{add\+Oct\+Tree\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=256, bool also\+Add\+If\+Mesh\+Pointer\+Zero=false)
\begin{DoxyCompactList}\small\item\em Adds a scene node for rendering using a octree to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}{add\+Camera\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&lookat=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 100), \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a camera scene node to the scene graph and sets it as active camera. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}{add\+Camera\+Scene\+Node\+Maya} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} rotate\+Speed=-\/1500.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} zoom\+Speed=200.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} translation\+Speed=1500.f, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} distance=70.f, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a maya style user controlled camera scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}{add\+Camera\+Scene\+Node\+F\+PS} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} rotate\+Speed=100.\+0f, f32 move\+Speed=0.\+5f, s32 id=-\/1, S\+Key\+Map $\ast$key\+Map\+Array=0, s32 key\+Map\+Size=0, bool no\+Vertical\+Movement=false, f32 jump\+Speed=0.\+f, bool invert\+Mouse=false, bool make\+Active=true)=0
\begin{DoxyCompactList}\small\item\em Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (F\+PS). \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ILightSceneNode}{I\+Light\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}{add\+Light\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} color=\hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}(1.\+0f, 1.\+0f, 1.\+0f), f32 radius=100.\+0f, s32 id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a dynamic light scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IBillboardSceneNode}{I\+Billboard\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}{add\+Billboard\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), s32 id=-\/1, video\+::\+S\+Color color\+Top=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color color\+Bottom=0x\+F\+F\+F\+F\+F\+F\+F\+F)=0
\begin{DoxyCompactList}\small\item\em Adds a billboard scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}{add\+Sky\+Box\+Scene\+Node} (\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$top, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$bottom, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$left, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$right, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$front, \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$back, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a skybox scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}{add\+Sky\+Dome\+Scene\+Node} (\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} hori\+Res=16, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} vert\+Res=8, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} texture\+Percentage=0.\+9, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} sphere\+Percentage=2.\+0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=1000.f, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a skydome scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode}{I\+Particle\+System\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}{add\+Particle\+System\+Scene\+Node} (bool with\+Default\+Emitter=true, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&scale=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.\+0f, 1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a particle system scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}{add\+Terrain\+Scene\+Node} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&height\+Map\+File\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&rotation=core\+::vector3df(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f), video\+::\+S\+Color vertex\+Color=video\+::\+S\+Color(255, 255, 255, 255), s32 max\+L\+O\+D=5, E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+Z\+E patch\+Size=\+E\+T\+P\+S\+\_\+17, s32 smooth\+Factor=0, bool add\+Also\+If\+Heightmap\+Empty=false)=0
\begin{DoxyCompactList}\small\item\em Adds a terrain scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}{add\+Terrain\+Scene\+Node} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$height\+Map\+File, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&rotation=core\+::vector3df(0.\+0f, 0.\+0f, 0.\+0f), const core\+::vector3df \&scale=core\+::vector3df(1.\+0f, 1.\+0f, 1.\+0f), video\+::\+S\+Color vertex\+Color=video\+::\+S\+Color(255, 255, 255, 255), s32 max\+L\+O\+D=5, E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+Z\+E patch\+Size=\+E\+T\+P\+S\+\_\+17, s32 smooth\+Factor=0, bool add\+Also\+If\+Heightmap\+Empty=false)=0
\begin{DoxyCompactList}\small\item\em Adds a terrain scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}{add\+Quake3\+Scene\+Node} (const \hyperlink{classirr_1_1scene_1_1IMeshBuffer}{I\+Mesh\+Buffer} $\ast$mesh\+Buffer, const \hyperlink{structirr_1_1scene_1_1quake3_1_1IShader}{quake3\+::\+I\+Shader} $\ast$shader, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a quake3 scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}{add\+Empty\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds an empty scene node to the scene graph. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IDummyTransformationSceneNode}{I\+Dummy\+Transformation\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}{add\+Dummy\+Transformation\+Scene\+Node} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a dummy transformation scene node to the scene graph. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}\label{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}} 
virtual \hyperlink{classirr_1_1scene_1_1ITextSceneNode}{I\+Text\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae3a173f0b0dd97e69251a22b5e4fbc0f}{add\+Text\+Scene\+Node} (\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$font, const wchar\+\_\+t $\ast$text, \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(100, 255, 255, 255), \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&position=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0, 0, 0), \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id=-\/1)=0
\begin{DoxyCompactList}\small\item\em Adds a text scene node, which is able to display 2d text at a position in three dimensional space. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IBillboardTextSceneNode}{I\+Billboard\+Text\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}{add\+Billboard\+Text\+Scene\+Node} (\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$font, const wchar\+\_\+t $\ast$text, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), const core\+::vector3df \&position=core\+::vector3df(0, 0, 0), s32 id=-\/1, video\+::\+S\+Color color\+Top=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color color\+Bottom=0x\+F\+F\+F\+F\+F\+F\+F\+F)=0
\begin{DoxyCompactList}\small\item\em Adds a text scene node, which uses billboards. The node, and the text on it, will scale with distance. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}{add\+Hill\+Plane\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&tile\+Size, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&tile\+Count, \hyperlink{classirr_1_1video_1_1SMaterial}{video\+::\+S\+Material} $\ast$material=0, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} hill\+Height=0.\+0f, const core\+::dimension2d$<$ f32 $>$ \&count\+Hills=core\+::dimension2d$<$ f32 $>$(0.\+0f, 0.\+0f), const core\+::dimension2d$<$ f32 $>$ \&texture\+Repeat\+Count=core\+::dimension2d$<$ f32 $>$(1.\+0f, 1.\+0f))=0
\begin{DoxyCompactList}\small\item\em Adds a Hill Plane mesh to the mesh pool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}{add\+Terrain\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&meshname, \hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$texture, \hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$heightmap, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&stretch\+Size=\hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$(10.\+0f, 10.\+0f), f32 max\+Height=200.\+0f, const core\+::dimension2d$<$ u32 $>$ \&default\+Vertex\+Block\+Size=core\+::dimension2d$<$ u32 $>$(64, 64))=0
\begin{DoxyCompactList}\small\item\em Adds a static terrain mesh to the mesh pool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}{add\+Arrow\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} vtx\+Color\+Cylinder=0x\+F\+F\+F\+F\+F\+F\+F\+F, video\+::\+S\+Color vtx\+Color\+Cone=0x\+F\+F\+F\+F\+F\+F\+F\+F, u32 tesselation\+Cylinder=4, u32 tesselation\+Cone=8, f32 height=1.\+f, f32 cylinder\+Height=0.\+6f, f32 width\+Cylinder=0.\+05f, f32 width\+Cone=0.\+3f)=0
\begin{DoxyCompactList}\small\item\em add a static arrow mesh to the meshpool \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}{add\+Sphere\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=5.f, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} poly\+CountX=16, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} poly\+CountY=16)=0
\begin{DoxyCompactList}\small\item\em add a static sphere mesh to the meshpool \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}{add\+Volume\+Light\+Mesh} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&name, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} SubdivideU=32, const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} SubdivideV=32, const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} Foot\+Color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51, 0, 230, 180), const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} Tail\+Color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0, 0, 0, 0))=0
\begin{DoxyCompactList}\small\item\em Add a volume light mesh to the meshpool. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}{get\+Root\+Scene\+Node} ()=0
\begin{DoxyCompactList}\small\item\em Gets the root scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}{get\+Scene\+Node\+From\+Id} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} id, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified id. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}{get\+Scene\+Node\+From\+Name} (const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified name. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}{get\+Scene\+Node\+From\+Type} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{scene\+::\+E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get the first scene node with the specified type. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}{get\+Scene\+Nodes\+From\+Type} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type, \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1scene_1_1ISceneNode}{scene\+::\+I\+Scene\+Node} $\ast$$>$ \&out\+Nodes, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$start=0)=0
\begin{DoxyCompactList}\small\item\em Get scene nodes by type. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}{get\+Active\+Camera} () const =0
\begin{DoxyCompactList}\small\item\em Get the current active camera. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}{set\+Active\+Camera} (\hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$camera)=0
\begin{DoxyCompactList}\small\item\em Sets the currently active camera. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}\label{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}} 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a074feb54d61f5402befef5e1bf0aff37}{set\+Shadow\+Color} (\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(150, 0, 0, 0))=0
\begin{DoxyCompactList}\small\item\em Sets the color of stencil buffers shadows drawn by the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}\label{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}} 
virtual \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} \hyperlink{classirr_1_1scene_1_1ISceneManager_ac57d3e4fca82867fd3f0ef2a47c4c07c}{get\+Shadow\+Color} () const =0
\begin{DoxyCompactList}\small\item\em Get the current color of shadows. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}{register\+Node\+For\+Rendering} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} pass=\hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67fad9a67a121247bc1001e35b8a8c0ef20d}{E\+S\+N\+R\+P\+\_\+\+A\+U\+T\+O\+M\+A\+T\+IC})=0
\begin{DoxyCompactList}\small\item\em Registers a node for rendering it at a specific time. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}{draw\+All} ()=0
\begin{DoxyCompactList}\small\item\em Draws all the scene nodes. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}{create\+Rotation\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&rotation\+Speed)=0
\begin{DoxyCompactList}\small\item\em Creates a rotation animator, which rotates the attached scene node around itself. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}{create\+Fly\+Circle\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&center=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f, 0.f, 0.f), \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius=100.f, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} speed=0.\+001f, const core\+::vector3df \&direction=core\+::vector3df(0.\+f, 1.\+f, 0.\+f), f32 start\+Position=0.\+f, f32 radius\+Ellipsoid=0.\+f)=0
\begin{DoxyCompactList}\small\item\em Creates a fly circle animator, which lets the attached scene node fly around a center. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}{create\+Fly\+Straight\+Animator} (const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&start\+Point, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&end\+Point, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} time\+For\+Way, bool loop=false, bool pingpong=false)=0
\begin{DoxyCompactList}\small\item\em Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}{create\+Texture\+Animator} (const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$$>$ \&textures, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} time\+Per\+Frame, bool loop=true)=0
\begin{DoxyCompactList}\small\item\em Creates a texture animator, which switches the textures of the target scene node based on a list of textures. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}{create\+Delete\+Animator} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} time\+Ms)=0
\begin{DoxyCompactList}\small\item\em Creates a scene node animator, which deletes the scene node after some time automatically. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}{create\+Collision\+Response\+Animator} (\hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$world, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$scene\+Node, const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&ellipsoid\+Radius=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(30, 60, 30), const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&gravity\+Per\+Second=\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.\+0f, 0), const core\+::vector3df \&ellipsoid\+Translation=core\+::vector3df(0, 0, 0), f32 sliding\+Value=0.\+0005f)=0
\begin{DoxyCompactList}\small\item\em Creates a special scene node animator for doing automatic collision detection and response. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}{create\+Follow\+Spline\+Animator} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} start\+Time, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} $>$ \&points, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} speed=1.\+0f, f32 tightness=0.\+5f, bool loop=true, bool pingpong=false)=0
\begin{DoxyCompactList}\small\item\em Creates a follow spline animator. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}{create\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a mesh. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}{create\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on an animated mesh scene node. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}{create\+Triangle\+Selector\+From\+Bounding\+Box} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Creates a simple dynamic \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a axis aligned bounding box. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}{create\+Octree\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=32)=0
\begin{DoxyCompactList}\small\item\em Creates a Triangle Selector, optimized by an octree. \end{DoxyCompactList}\item 
\+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}{create\+Oct\+Tree\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$mesh, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} minimal\+Polys\+Per\+Node=32)
\begin{DoxyCompactList}\small\item\em //! Creates a Triangle Selector, optimized by an octree. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMetaTriangleSelector}{I\+Meta\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}{create\+Meta\+Triangle\+Selector} ()=0
\begin{DoxyCompactList}\small\item\em Creates a meta triangle selector. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}{create\+Terrain\+Triangle\+Selector} (\hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$node, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} L\+OD=0)=0
\begin{DoxyCompactList}\small\item\em Creates a triangle selector which can select triangles from a terrain scene node. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}{add\+External\+Mesh\+Loader} (\hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$external\+Loader)=0
\begin{DoxyCompactList}\small\item\em Adds an external mesh loader for extending the engine with new file formats. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}\label{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_abb3fc9803b7de0cf7177042bd24508ad}{get\+Mesh\+Loader\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Returns the number of mesh loaders supported by Irrlicht at this time. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}{get\+Mesh\+Loader} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index) const =0
\begin{DoxyCompactList}\small\item\em Retrieve the given mesh loader. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{add\+External\+Scene\+Loader} (\hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$external\+Loader)=0
\begin{DoxyCompactList}\small\item\em Adds an external scene loader for extending the engine with new file formats. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}\label{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_a3e5cd3e93d3ed711df7692c830c5a58a}{get\+Scene\+Loader\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Returns the number of scene loaders supported by Irrlicht at this time. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}{get\+Scene\+Loader} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index) const =0
\begin{DoxyCompactList}\small\item\em Retrieve the given scene loader. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneCollisionManager}{I\+Scene\+Collision\+Manager} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}{get\+Scene\+Collision\+Manager} ()=0
\begin{DoxyCompactList}\small\item\em Get pointer to the scene collision manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshManipulator}{I\+Mesh\+Manipulator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}{get\+Mesh\+Manipulator} ()=0
\begin{DoxyCompactList}\small\item\em Get pointer to the mesh manipulator. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}{add\+To\+Deletion\+Queue} (\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node to the deletion queue. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}{post\+Event\+From\+User} (const \hyperlink{structirr_1_1SEvent}{S\+Event} \&event)=0
\begin{DoxyCompactList}\small\item\em Posts an input event to the environment. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}{clear} ()=0
\begin{DoxyCompactList}\small\item\em Clears the whole scene. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1io_1_1IAttributes}{io\+::\+I\+Attributes} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters} ()=0
\begin{DoxyCompactList}\small\item\em Get interface to the parameters set in this scene. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} \hyperlink{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}{get\+Scene\+Node\+Render\+Pass} () const =0
\begin{DoxyCompactList}\small\item\em Get current render pass. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}{get\+Default\+Scene\+Node\+Factory} ()=0
\begin{DoxyCompactList}\small\item\em Get the default scene node factory which can create all built in scene nodes. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}{register\+Scene\+Node\+Factory} (\hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$factory\+To\+Add)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node factory to the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}\label{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_a405dd898657d08cd1dbf973d1cb88b19}{get\+Registered\+Scene\+Node\+Factory\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Get amount of registered scene node factories. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}{get\+Scene\+Node\+Factory} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index)=0
\begin{DoxyCompactList}\small\item\em Get a scene node factory by index. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}{get\+Default\+Scene\+Node\+Animator\+Factory} ()=0
\begin{DoxyCompactList}\small\item\em Get the default scene node animator factory which can create all built-\/in scene node animators. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}{register\+Scene\+Node\+Animator\+Factory} (\hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$factory\+To\+Add)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node animator factory to the scene manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}\label{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}} 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1scene_1_1ISceneManager_abf31f8c0dfb5242d07339fbba20a63e5}{get\+Registered\+Scene\+Node\+Animator\+Factory\+Count} () const =0
\begin{DoxyCompactList}\small\item\em Get amount of registered scene node animator factories. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}{get\+Scene\+Node\+Animator\+Factory} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index)=0
\begin{DoxyCompactList}\small\item\em Get scene node animator factory by index. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}\label{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}} 
virtual const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9f8cc1f55b8e067528b7a9a21b7fdd50}{get\+Scene\+Node\+Type\+Name} (\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Get typename from a scene node type or null if not found. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}\label{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}} 
virtual const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_aeedfa596280048e6ea6463ff69d23855}{get\+Animator\+Type\+Name} (\hyperlink{namespaceirr_1_1scene_a327a1e43872705cf8f3f3342fb307d19}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+A\+N\+I\+M\+A\+T\+O\+R\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Returns a typename from a scene node animator type or null if not found. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}{add\+Scene\+Node} (const char $\ast$scene\+Node\+Type\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$parent=0)=0
\begin{DoxyCompactList}\small\item\em Adds a scene node to the scene by name. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}{create\+Scene\+Node\+Animator} (const char $\ast$type\+Name, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$target=0)=0
\begin{DoxyCompactList}\small\item\em creates a scene node animator based on its type name \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISceneManager}{I\+Scene\+Manager} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}{create\+New\+Scene\+Manager} (bool clone\+Content=false)=0
\begin{DoxyCompactList}\small\item\em Creates a new scene manager. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{save\+Scene} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}{save\+Scene} (\hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} $\ast$file, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}{save\+Scene} (\hyperlink{classirr_1_1io_1_1IXMLWriter}{io\+::\+I\+X\+M\+L\+Writer} $\ast$writer, const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&current\+Path, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node=0)=0
\begin{DoxyCompactList}\small\item\em Saves the current scene into a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{load\+Scene} (const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&filename, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$root\+Node=0)=0
\begin{DoxyCompactList}\small\item\em Loads a scene. Note that the current scene is not cleared before. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}{load\+Scene} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file, \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$user\+Data\+Serializer=0, \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$root\+Node=0)=0
\begin{DoxyCompactList}\small\item\em Loads a scene. Note that the current scene is not cleared before. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshWriter}{I\+Mesh\+Writer} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}{create\+Mesh\+Writer} (\hyperlink{namespaceirr_1_1scene_a431fa15741518ba15f6d5f2608b6cb4e}{E\+M\+E\+S\+H\+\_\+\+W\+R\+I\+T\+E\+R\+\_\+\+T\+Y\+PE} type)=0
\begin{DoxyCompactList}\small\item\em Get a mesh writer implementation if available. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}{create\+Skinned\+Mesh} ()=0
\begin{DoxyCompactList}\small\item\em Get a skinned mesh, which is not available as header-\/only code. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}\label{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}} 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a8a424accb615c4f60fde59f55033a816}{set\+Ambient\+Light} (const \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} \&ambient\+Color)=0
\begin{DoxyCompactList}\small\item\em Sets ambient color of the scene. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}\label{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}} 
virtual const \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf} \& \hyperlink{classirr_1_1scene_1_1ISceneManager_a9da2090baaeeaa6261d6a1fac5025b09}{get\+Ambient\+Light} () const =0
\begin{DoxyCompactList}\small\item\em Get ambient color of the scene. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}{set\+Light\+Manager} (\hyperlink{classirr_1_1scene_1_1ILightManager}{I\+Light\+Manager} $\ast$light\+Manager)=0
\begin{DoxyCompactList}\small\item\em Register a custom callbacks manager which gets callbacks during scene rendering. \end{DoxyCompactList}\item 
virtual const \hyperlink{classirr_1_1scene_1_1IGeometryCreator}{I\+Geometry\+Creator} $\ast$ \hyperlink{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}{get\+Geometry\+Creator} (void) const =0
\begin{DoxyCompactList}\small\item\em Get an instance of a geometry creator. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}{is\+Culled} (const \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$node) const =0
\begin{DoxyCompactList}\small\item\em Check if node is culled in current view frustum. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff. 

All Scene nodes can be created only here. There is a always growing list of scene nodes for lots of purposes\+: Indoor rendering scene nodes like the Octree (\hyperlink{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}{add\+Octree\+Scene\+Node()}) or the terrain renderer (\hyperlink{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}{add\+Terrain\+Scene\+Node()}), different \hyperlink{classCamera}{Camera} scene nodes (\hyperlink{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}{add\+Camera\+Scene\+Node()}, \hyperlink{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}{add\+Camera\+Scene\+Node\+Maya()}), scene nodes for Light (\hyperlink{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}{add\+Light\+Scene\+Node()}), Billboards (\hyperlink{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}{add\+Billboard\+Scene\+Node()}) and so on. A scene node is a node in the hierachical scene graph. Every scene node may have children, which are other scene nodes. Children move relative the their parents position. If the parent of a node is not visible, its children won\textquotesingle{}t be visible, too. In this way, it is for example easily possible to attach a light to a moving car or to place a walking character on a moving platform on a moving ship. The Scene\+Manager is also able to load 3d mesh files of different formats. Take a look at \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{get\+Mesh()} to find out what formats are supported. If these formats are not enough, use \hyperlink{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}{add\+External\+Mesh\+Loader()} to add new formats to the engine. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}\label{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Animated\+Mesh\+Scene\+Node@{add\+Animated\+Mesh\+Scene\+Node}}
\index{add\+Animated\+Mesh\+Scene\+Node@{add\+Animated\+Mesh\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Animated\+Mesh\+Scene\+Node()}{addAnimatedMeshSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Animated\+Mesh\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering an animated mesh model. 


\begin{DoxyParams}{Parameters}
{\em mesh} & Pointer to the loaded animated mesh to be displayed. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}\label{classirr_1_1scene_1_1ISceneManager_a8e2e0cd3a27e85b4116855dd2f3365b8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Animated\+Mesh\+Scene\+Node@{add\+Animated\+Mesh\+Scene\+Node}}
\index{add\+Animated\+Mesh\+Scene\+Node@{add\+Animated\+Mesh\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Animated\+Mesh\+Scene\+Node()}{addAnimatedMeshSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Animated\+Mesh\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering an animated mesh model. 


\begin{DoxyParams}{Parameters}
{\em mesh} & Pointer to the loaded animated mesh to be displayed. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}\label{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Arrow\+Mesh@{add\+Arrow\+Mesh}}
\index{add\+Arrow\+Mesh@{add\+Arrow\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Arrow\+Mesh()}{addArrowMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Arrow\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vtx\+Color\+Cylinder = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vtx\+Color\+Cone = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{tesselation\+Cylinder = {\ttfamily 4},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{tesselation\+Cone = {\ttfamily 8},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{height = {\ttfamily 1.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{cylinder\+Height = {\ttfamily 0.6f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{width\+Cylinder = {\ttfamily 0.05f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{width\+Cone = {\ttfamily 0.3f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



add a static arrow mesh to the meshpool 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em vtx\+Color\+Cylinder} & color of the cylinder \\
\hline
{\em vtx\+Color\+Cone} & color of the cone \\
\hline
{\em tesselation\+Cylinder} & Number of quads the cylinder side consists of \\
\hline
{\em tesselation\+Cone} & Number of triangles the cone\textquotesingle{}s roof consits of \\
\hline
{\em height} & Total height of the arrow \\
\hline
{\em cylinder\+Height} & Total height of the cylinder, should be lesser than total height \\
\hline
{\em width\+Cylinder} & Diameter of the cylinder \\
\hline
{\em width\+Cone} & Diameter of the cone\textquotesingle{}s base, should be not smaller than the cylinder\textquotesingle{}s diameter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the arrow mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}\label{classirr_1_1scene_1_1ISceneManager_ac1bca43a6301e6c9daf09806ea46309a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Arrow\+Mesh@{add\+Arrow\+Mesh}}
\index{add\+Arrow\+Mesh@{add\+Arrow\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Arrow\+Mesh()}{addArrowMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Arrow\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vtx\+Color\+Cylinder = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vtx\+Color\+Cone = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{tesselation\+Cylinder = {\ttfamily 4},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{tesselation\+Cone = {\ttfamily 8},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{height = {\ttfamily 1.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{cylinder\+Height = {\ttfamily 0.6f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{width\+Cylinder = {\ttfamily 0.05f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{width\+Cone = {\ttfamily 0.3f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



add a static arrow mesh to the meshpool 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em vtx\+Color\+Cylinder} & color of the cylinder \\
\hline
{\em vtx\+Color\+Cone} & color of the cone \\
\hline
{\em tesselation\+Cylinder} & Number of quads the cylinder side consists of \\
\hline
{\em tesselation\+Cone} & Number of triangles the cone\textquotesingle{}s roof consits of \\
\hline
{\em height} & Total height of the arrow \\
\hline
{\em cylinder\+Height} & Total height of the cylinder, should be lesser than total height \\
\hline
{\em width\+Cylinder} & Diameter of the cylinder \\
\hline
{\em width\+Cone} & Diameter of the cone\textquotesingle{}s base, should be not smaller than the cylinder\textquotesingle{}s diameter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the arrow mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}\label{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Billboard\+Scene\+Node@{add\+Billboard\+Scene\+Node}}
\index{add\+Billboard\+Scene\+Node@{add\+Billboard\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Billboard\+Scene\+Node()}{addBillboardSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IBillboardSceneNode}{I\+Billboard\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Billboard\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Top = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Bottom = {\ttfamily 0xFFFFFFFF} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a billboard scene node to the scene graph. 

A billboard is like a 3d sprite\+: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. \\
\hline
{\em size} & Size of the billboard. This size is 2 dimensional because a billboard only has width and height. \\
\hline
{\em position} & Position of the space relative to its parent where the billboard will be placed. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
{\em color\+Top} & The color of the vertices at the top of the billboard (default\+: white). \\
\hline
{\em color\+Bottom} & The color of the vertices at the bottom of the billboard (default\+: white). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the billboard if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}\label{classirr_1_1scene_1_1ISceneManager_a00266a58b97e827acd9e105806a99c3a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Billboard\+Scene\+Node@{add\+Billboard\+Scene\+Node}}
\index{add\+Billboard\+Scene\+Node@{add\+Billboard\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Billboard\+Scene\+Node()}{addBillboardSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IBillboardSceneNode}{I\+Billboard\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Billboard\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Top = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Bottom = {\ttfamily 0xFFFFFFFF} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a billboard scene node to the scene graph. 

A billboard is like a 3d sprite\+: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. \\
\hline
{\em size} & Size of the billboard. This size is 2 dimensional because a billboard only has width and height. \\
\hline
{\em position} & Position of the space relative to its parent where the billboard will be placed. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
{\em color\+Top} & The color of the vertices at the top of the billboard (default\+: white). \\
\hline
{\em color\+Bottom} & The color of the vertices at the bottom of the billboard (default\+: white). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the billboard if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}\label{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Billboard\+Text\+Scene\+Node@{add\+Billboard\+Text\+Scene\+Node}}
\index{add\+Billboard\+Text\+Scene\+Node@{add\+Billboard\+Text\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Billboard\+Text\+Scene\+Node()}{addBillboardTextSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IBillboardTextSceneNode}{I\+Billboard\+Text\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Billboard\+Text\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$}]{font,  }\item[{const wchar\+\_\+t $\ast$}]{text,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Top = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Bottom = {\ttfamily 0xFFFFFFFF} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a text scene node, which uses billboards. The node, and the text on it, will scale with distance. 


\begin{DoxyParams}{Parameters}
{\em font} & The font to use on the billboard. Pass 0 to use the G\+UI environment\textquotesingle{}s default font. \\
\hline
{\em text} & The text to display on the billboard. \\
\hline
{\em parent} & The billboard\textquotesingle{}s parent. Pass 0 to use the root scene node. \\
\hline
{\em size} & The billboard\textquotesingle{}s width and height. \\
\hline
{\em position} & The billboards position relative to its parent. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
{\em color\+Top} & The color of the vertices at the top of the billboard (default\+: white). \\
\hline
{\em color\+Bottom} & The color of the vertices at the bottom of the billboard (default\+: white). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the billboard if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}\label{classirr_1_1scene_1_1ISceneManager_a82e91e414ac6ad4f4c0eaa5b17ce3a44}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Billboard\+Text\+Scene\+Node@{add\+Billboard\+Text\+Scene\+Node}}
\index{add\+Billboard\+Text\+Scene\+Node@{add\+Billboard\+Text\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Billboard\+Text\+Scene\+Node()}{addBillboardTextSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IBillboardTextSceneNode}{I\+Billboard\+Text\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Billboard\+Text\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1gui_1_1IGUIFont}{gui\+::\+I\+G\+U\+I\+Font} $\ast$}]{font,  }\item[{const wchar\+\_\+t $\ast$}]{text,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Top = {\ttfamily 0xFFFFFFFF},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{color\+Bottom = {\ttfamily 0xFFFFFFFF} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a text scene node, which uses billboards. The node, and the text on it, will scale with distance. 


\begin{DoxyParams}{Parameters}
{\em font} & The font to use on the billboard. Pass 0 to use the G\+UI environment\textquotesingle{}s default font. \\
\hline
{\em text} & The text to display on the billboard. \\
\hline
{\em parent} & The billboard\textquotesingle{}s parent. Pass 0 to use the root scene node. \\
\hline
{\em size} & The billboard\textquotesingle{}s width and height. \\
\hline
{\em position} & The billboards position relative to its parent. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
{\em color\+Top} & The color of the vertices at the top of the billboard (default\+: white). \\
\hline
{\em color\+Bottom} & The color of the vertices at the bottom of the billboard (default\+: white). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the billboard if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}\label{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node@{add\+Camera\+Scene\+Node}}
\index{add\+Camera\+Scene\+Node@{add\+Camera\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node()}{addCameraSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{lookat = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~100)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a camera scene node to the scene graph and sets it as active camera. 

This camera does not react on user input like for example the one created with \hyperlink{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}{add\+Camera\+Scene\+Node\+F\+P\+S()}. If you want to move or animate it, use animators or the \hyperlink{classirr_1_1scene_1_1ISceneNode_a2166eb0a92cc0e46c49266f41a68ed50}{I\+Scene\+Node\+::set\+Position()}, \hyperlink{classirr_1_1scene_1_1ICameraSceneNode_a7280b07fd7915c64350db5a132b4ba07}{I\+Camera\+Scene\+Node\+::set\+Target()} etc methods. By default, a camera\textquotesingle{}s look at position (set with set\+Target()) and its scene node rotation (set with set\+Rotation()) are independent. If you want to be able to control the direction that the camera looks by using set\+Rotation() then call I\+Camera\+Scene\+Node\+::bind\+Target\+And\+Rotation(true) on it. 
\begin{DoxyParams}{Parameters}
{\em position} & Position of the space relative to its parent where the camera will be placed. \\
\hline
{\em lookat} & Position where the camera will look at. Also known as target. \\
\hline
{\em parent} & Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}\label{classirr_1_1scene_1_1ISceneManager_afc3733849319078d5d22d94f58c7d1f2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node@{add\+Camera\+Scene\+Node}}
\index{add\+Camera\+Scene\+Node@{add\+Camera\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node()}{addCameraSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{lookat = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~100)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a camera scene node to the scene graph and sets it as active camera. 

This camera does not react on user input like for example the one created with \hyperlink{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}{add\+Camera\+Scene\+Node\+F\+P\+S()}. If you want to move or animate it, use animators or the \hyperlink{classirr_1_1scene_1_1ISceneNode_a2166eb0a92cc0e46c49266f41a68ed50}{I\+Scene\+Node\+::set\+Position()}, \hyperlink{classirr_1_1scene_1_1ICameraSceneNode_a7280b07fd7915c64350db5a132b4ba07}{I\+Camera\+Scene\+Node\+::set\+Target()} etc methods. By default, a camera\textquotesingle{}s look at position (set with set\+Target()) and its scene node rotation (set with set\+Rotation()) are independent. If you want to be able to control the direction that the camera looks by using set\+Rotation() then call I\+Camera\+Scene\+Node\+::bind\+Target\+And\+Rotation(true) on it. 
\begin{DoxyParams}{Parameters}
{\em position} & Position of the space relative to its parent where the camera will be placed. \\
\hline
{\em lookat} & Position where the camera will look at. Also known as target. \\
\hline
{\em parent} & Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}\label{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node\+F\+PS@{add\+Camera\+Scene\+Node\+F\+PS}}
\index{add\+Camera\+Scene\+Node\+F\+PS@{add\+Camera\+Scene\+Node\+F\+PS}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node\+F\+P\+S()}{addCameraSceneNodeFPS()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node\+F\+PS (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{rotate\+Speed = {\ttfamily 100.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{move\+Speed = {\ttfamily 0.5f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{structirr_1_1SKeyMap}{S\+Key\+Map} $\ast$}]{key\+Map\+Array = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{key\+Map\+Size = {\ttfamily 0},  }\item[{bool}]{no\+Vertical\+Movement = {\ttfamily false},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{jump\+Speed = {\ttfamily 0.f},  }\item[{bool}]{invert\+Mouse = {\ttfamily false},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (F\+PS). 

This F\+PS camera is intended to provide a demonstration of a camera that behaves like a typical First Person Shooter. It is useful for simple demos and prototyping but is not intended to provide a full solution for a production quality game. It binds the camera scene node rotation to the look-\/at target; \begin{DoxySeeAlso}{See also}
\hyperlink{classirr_1_1scene_1_1ICameraSceneNode_ad8785d7b2f730933a8d4425ac54e7205}{I\+Camera\+Scene\+Node\+::bind\+Target\+And\+Rotation()}. With this camera, you look with the mouse, and move with cursor keys. If you want to change the key layout, you can specify your own keymap. For example to make the camera be controlled by the cursor keys A\+ND the keys W,A,S, and D, do something like this\+: 
\begin{DoxyCode}
 SKeyMap keyMap[8];
 keyMap[0].Action = EKA\_MOVE\_FORWARD;
 keyMap[0].KeyCode = KEY\_UP;
 keyMap[1].Action = EKA\_MOVE\_FORWARD;
 keyMap[1].KeyCode = KEY\_KEY\_W;

 keyMap[2].Action = EKA\_MOVE\_BACKWARD;
 keyMap[2].KeyCode = KEY\_DOWN;
 keyMap[3].Action = EKA\_MOVE\_BACKWARD;
 keyMap[3].KeyCode = KEY\_KEY\_S;

 keyMap[4].Action = EKA\_STRAFE\_LEFT;
 keyMap[4].KeyCode = KEY\_LEFT;
 keyMap[5].Action = EKA\_STRAFE\_LEFT;
 keyMap[5].KeyCode = KEY\_KEY\_A;

 keyMap[6].Action = EKA\_STRAFE\_RIGHT;
 keyMap[6].KeyCode = KEY\_RIGHT;
 keyMap[7].Action = EKA\_STRAFE\_RIGHT;
 keyMap[7].KeyCode = KEY\_KEY\_D;

camera = sceneManager->addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 8);
\end{DoxyCode}
 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the camera. Can be null. \\
\hline
{\em rotate\+Speed} & Speed in degress with which the camera is rotated. This can be done only with the mouse. \\
\hline
{\em move\+Speed} & Speed in units per millisecond with which the camera is moved. Movement is done with the cursor keys. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em key\+Map\+Array} & Optional pointer to an array of a keymap, specifying what keys should be used to move the camera. If this is null, the default keymap is used. You can define actions more then one time in the array, to bind multiple keys to the same action. \\
\hline
{\em key\+Map\+Size} & Amount of items in the keymap array. \\
\hline
{\em no\+Vertical\+Movement} & Setting this to true makes the camera only move within a horizontal plane, and disables vertical movement as known from most ego shooters. Default is \textquotesingle{}false\textquotesingle{}, with which it is possible to fly around in space, if no gravity is there. \\
\hline
{\em jump\+Speed} & Speed with which the camera is moved when jumping. \\
\hline
{\em invert\+Mouse} & Setting this to true makes the camera look up when the mouse is moved down and down when the mouse is moved up, the default is \textquotesingle{}false\textquotesingle{} which means it will follow the movement of the mouse cursor. \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}\label{classirr_1_1scene_1_1ISceneManager_ac312cbc85161678d00192880f2cdddbb}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node\+F\+PS@{add\+Camera\+Scene\+Node\+F\+PS}}
\index{add\+Camera\+Scene\+Node\+F\+PS@{add\+Camera\+Scene\+Node\+F\+PS}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node\+F\+P\+S()}{addCameraSceneNodeFPS()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node\+F\+PS (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{rotate\+Speed = {\ttfamily 100.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{move\+Speed = {\ttfamily 0.5f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{structirr_1_1SKeyMap}{S\+Key\+Map} $\ast$}]{key\+Map\+Array = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{key\+Map\+Size = {\ttfamily 0},  }\item[{bool}]{no\+Vertical\+Movement = {\ttfamily false},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{jump\+Speed = {\ttfamily 0.f},  }\item[{bool}]{invert\+Mouse = {\ttfamily false},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (F\+PS). 

This F\+PS camera is intended to provide a demonstration of a camera that behaves like a typical First Person Shooter. It is useful for simple demos and prototyping but is not intended to provide a full solution for a production quality game. It binds the camera scene node rotation to the look-\/at target; \begin{DoxySeeAlso}{See also}
\hyperlink{classirr_1_1scene_1_1ICameraSceneNode_ad8785d7b2f730933a8d4425ac54e7205}{I\+Camera\+Scene\+Node\+::bind\+Target\+And\+Rotation()}. With this camera, you look with the mouse, and move with cursor keys. If you want to change the key layout, you can specify your own keymap. For example to make the camera be controlled by the cursor keys A\+ND the keys W,A,S, and D, do something like this\+: 
\begin{DoxyCode}
 SKeyMap keyMap[8];
 keyMap[0].Action = EKA\_MOVE\_FORWARD;
 keyMap[0].KeyCode = KEY\_UP;
 keyMap[1].Action = EKA\_MOVE\_FORWARD;
 keyMap[1].KeyCode = KEY\_KEY\_W;

 keyMap[2].Action = EKA\_MOVE\_BACKWARD;
 keyMap[2].KeyCode = KEY\_DOWN;
 keyMap[3].Action = EKA\_MOVE\_BACKWARD;
 keyMap[3].KeyCode = KEY\_KEY\_S;

 keyMap[4].Action = EKA\_STRAFE\_LEFT;
 keyMap[4].KeyCode = KEY\_LEFT;
 keyMap[5].Action = EKA\_STRAFE\_LEFT;
 keyMap[5].KeyCode = KEY\_KEY\_A;

 keyMap[6].Action = EKA\_STRAFE\_RIGHT;
 keyMap[6].KeyCode = KEY\_RIGHT;
 keyMap[7].Action = EKA\_STRAFE\_RIGHT;
 keyMap[7].KeyCode = KEY\_KEY\_D;

camera = sceneManager->addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 8);
\end{DoxyCode}
 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the camera. Can be null. \\
\hline
{\em rotate\+Speed} & Speed in degress with which the camera is rotated. This can be done only with the mouse. \\
\hline
{\em move\+Speed} & Speed in units per millisecond with which the camera is moved. Movement is done with the cursor keys. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em key\+Map\+Array} & Optional pointer to an array of a keymap, specifying what keys should be used to move the camera. If this is null, the default keymap is used. You can define actions more then one time in the array, to bind multiple keys to the same action. \\
\hline
{\em key\+Map\+Size} & Amount of items in the keymap array. \\
\hline
{\em no\+Vertical\+Movement} & Setting this to true makes the camera only move within a horizontal plane, and disables vertical movement as known from most ego shooters. Default is \textquotesingle{}false\textquotesingle{}, with which it is possible to fly around in space, if no gravity is there. \\
\hline
{\em jump\+Speed} & Speed with which the camera is moved when jumping. \\
\hline
{\em invert\+Mouse} & Setting this to true makes the camera look up when the mouse is moved down and down when the mouse is moved up, the default is \textquotesingle{}false\textquotesingle{} which means it will follow the movement of the mouse cursor. \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}\label{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node\+Maya@{add\+Camera\+Scene\+Node\+Maya}}
\index{add\+Camera\+Scene\+Node\+Maya@{add\+Camera\+Scene\+Node\+Maya}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node\+Maya()}{addCameraSceneNodeMaya()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node\+Maya (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{rotate\+Speed = {\ttfamily -\/1500.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{zoom\+Speed = {\ttfamily 200.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{translation\+Speed = {\ttfamily 1500.f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{distance = {\ttfamily 70.f},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a maya style user controlled camera scene node to the scene graph. 

This is a standard camera with an animator that provides mouse control similar to camera in the 3D Software Maya by Alias Wavefront. The camera does not react on set\+Position anymore after applying this animator. Instead use set\+Target, to fix the target the camera the camera hovers around. And set\+Distance to set the current distance from that target, i.\+e. the radius of the orbit the camera hovers on. 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the camera. Can be null. \\
\hline
{\em rotate\+Speed} & Rotation speed of the camera. \\
\hline
{\em zoom\+Speed} & Zoom speed of the camera. \\
\hline
{\em translation\+Speed} & Translation\+Speed of the camera. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em distance} & Initial distance of the camera from the object \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}\label{classirr_1_1scene_1_1ISceneManager_a18e81a59e02231567ac938ea287fe523}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Camera\+Scene\+Node\+Maya@{add\+Camera\+Scene\+Node\+Maya}}
\index{add\+Camera\+Scene\+Node\+Maya@{add\+Camera\+Scene\+Node\+Maya}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Camera\+Scene\+Node\+Maya()}{addCameraSceneNodeMaya()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Camera\+Scene\+Node\+Maya (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{rotate\+Speed = {\ttfamily -\/1500.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{zoom\+Speed = {\ttfamily 200.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{translation\+Speed = {\ttfamily 1500.f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{distance = {\ttfamily 70.f},  }\item[{bool}]{make\+Active = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a maya style user controlled camera scene node to the scene graph. 

This is a standard camera with an animator that provides mouse control similar to camera in the 3D Software Maya by Alias Wavefront. The camera does not react on set\+Position anymore after applying this animator. Instead use set\+Target, to fix the target the camera the camera hovers around. And set\+Distance to set the current distance from that target, i.\+e. the radius of the orbit the camera hovers on. 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the camera. Can be null. \\
\hline
{\em rotate\+Speed} & Rotation speed of the camera. \\
\hline
{\em zoom\+Speed} & Zoom speed of the camera. \\
\hline
{\em translation\+Speed} & Translation\+Speed of the camera. \\
\hline
{\em id} & id of the camera. This id can be used to identify the camera. \\
\hline
{\em distance} & Initial distance of the camera from the object \\
\hline
{\em make\+Active} & Flag whether this camera should become the active one. Make sure you always have one active camera. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}\label{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Cube\+Scene\+Node@{add\+Cube\+Scene\+Node}}
\index{add\+Cube\+Scene\+Node@{add\+Cube\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Cube\+Scene\+Node()}{addCubeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Cube\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{size = {\ttfamily 10.0f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a cube scene node. 


\begin{DoxyParams}{Parameters}
{\em size} & Size of the cube, uniformly in each dimension. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created test scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}\label{classirr_1_1scene_1_1ISceneManager_a23d1328c68b1585f613108f386fabc1c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Cube\+Scene\+Node@{add\+Cube\+Scene\+Node}}
\index{add\+Cube\+Scene\+Node@{add\+Cube\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Cube\+Scene\+Node()}{addCubeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Cube\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{size = {\ttfamily 10.0f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a cube scene node. 


\begin{DoxyParams}{Parameters}
{\em size} & Size of the cube, uniformly in each dimension. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created test scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}\label{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Dummy\+Transformation\+Scene\+Node@{add\+Dummy\+Transformation\+Scene\+Node}}
\index{add\+Dummy\+Transformation\+Scene\+Node@{add\+Dummy\+Transformation\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Dummy\+Transformation\+Scene\+Node()}{addDummyTransformationSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IDummyTransformationSceneNode}{I\+Dummy\+Transformation\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Dummy\+Transformation\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a dummy transformation scene node to the scene graph. 

This scene node does not render itself, and does not respond to set/get\+Position, set/get\+Rotation and set/get\+Scale. Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. \begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}\label{classirr_1_1scene_1_1ISceneManager_ad7aa119894aa960f428b7baefcedc58a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Dummy\+Transformation\+Scene\+Node@{add\+Dummy\+Transformation\+Scene\+Node}}
\index{add\+Dummy\+Transformation\+Scene\+Node@{add\+Dummy\+Transformation\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Dummy\+Transformation\+Scene\+Node()}{addDummyTransformationSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IDummyTransformationSceneNode}{I\+Dummy\+Transformation\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Dummy\+Transformation\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a dummy transformation scene node to the scene graph. 

This scene node does not render itself, and does not respond to set/get\+Position, set/get\+Rotation and set/get\+Scale. Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. \begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}\label{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Empty\+Scene\+Node@{add\+Empty\+Scene\+Node}}
\index{add\+Empty\+Scene\+Node@{add\+Empty\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Empty\+Scene\+Node()}{addEmptySceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Empty\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an empty scene node to the scene graph. 

Can be used for doing advanced transformations or structuring the scene graph. \begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}\label{classirr_1_1scene_1_1ISceneManager_a3811d3d2a092474e2c5613d550678187}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Empty\+Scene\+Node@{add\+Empty\+Scene\+Node}}
\index{add\+Empty\+Scene\+Node@{add\+Empty\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Empty\+Scene\+Node()}{addEmptySceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Empty\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an empty scene node to the scene graph. 

Can be used for doing advanced transformations or structuring the scene graph. \begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}\label{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+External\+Mesh\+Loader@{add\+External\+Mesh\+Loader}}
\index{add\+External\+Mesh\+Loader@{add\+External\+Mesh\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+External\+Mesh\+Loader()}{addExternalMeshLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+External\+Mesh\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$}]{external\+Loader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an external mesh loader for extending the engine with new file formats. 

If you want the engine to be extended with file formats it currently is not able to load (e.\+g. .cob), just implement the \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} interface in your loading class and add it with this method. Using this method it is also possible to override built-\/in mesh loaders with newer or updated versions without the need to recompile the engine. 
\begin{DoxyParams}{Parameters}
{\em external\+Loader} & Implementation of a new mesh loader. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}\label{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+External\+Mesh\+Loader@{add\+External\+Mesh\+Loader}}
\index{add\+External\+Mesh\+Loader@{add\+External\+Mesh\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+External\+Mesh\+Loader()}{addExternalMeshLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+External\+Mesh\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} $\ast$}]{external\+Loader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an external mesh loader for extending the engine with new file formats. 

If you want the engine to be extended with file formats it currently is not able to load (e.\+g. .cob), just implement the \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader} interface in your loading class and add it with this method. Using this method it is also possible to override built-\/in mesh loaders with newer or updated versions without the need to recompile the engine. 
\begin{DoxyParams}{Parameters}
{\em external\+Loader} & Implementation of a new mesh loader. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}\label{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+External\+Scene\+Loader@{add\+External\+Scene\+Loader}}
\index{add\+External\+Scene\+Loader@{add\+External\+Scene\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+External\+Scene\+Loader()}{addExternalSceneLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+External\+Scene\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$}]{external\+Loader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an external scene loader for extending the engine with new file formats. 

If you want the engine to be extended with file formats it currently is not able to load (e.\+g. .vrml), just implement the \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} interface in your loading class and add it with this method. Using this method it is also possible to override the built-\/in scene loaders with newer or updated versions without the need to recompile the engine. 
\begin{DoxyParams}{Parameters}
{\em external\+Loader} & Implementation of a new mesh loader. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}\label{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+External\+Scene\+Loader@{add\+External\+Scene\+Loader}}
\index{add\+External\+Scene\+Loader@{add\+External\+Scene\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+External\+Scene\+Loader()}{addExternalSceneLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+External\+Scene\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} $\ast$}]{external\+Loader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds an external scene loader for extending the engine with new file formats. 

If you want the engine to be extended with file formats it currently is not able to load (e.\+g. .vrml), just implement the \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader} interface in your loading class and add it with this method. Using this method it is also possible to override the built-\/in scene loaders with newer or updated versions without the need to recompile the engine. 
\begin{DoxyParams}{Parameters}
{\em external\+Loader} & Implementation of a new mesh loader. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}\label{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Hill\+Plane\+Mesh@{add\+Hill\+Plane\+Mesh}}
\index{add\+Hill\+Plane\+Mesh@{add\+Hill\+Plane\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Hill\+Plane\+Mesh()}{addHillPlaneMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Hill\+Plane\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{tile\+Size,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&}]{tile\+Count,  }\item[{\hyperlink{classirr_1_1video_1_1SMaterial}{video\+::\+S\+Material} $\ast$}]{material = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{hill\+Height = {\ttfamily 0.0f},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{count\+Hills = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(0.0f,~0.0f)},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{texture\+Repeat\+Count = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a Hill Plane mesh to the mesh pool. 

The mesh is generated on the fly and looks like a plane with some hills on it. It is uses mostly for quick tests of the engine only. You can specify how many hills there should be on the plane and how high they should be. Also you must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} with the name as parameter. 
\begin{DoxyParams}{Parameters}
{\em name} & The name of this mesh which must be specified in order to be able to retrieve the mesh later with \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()}. \\
\hline
{\em tile\+Size} & Size of a tile of the mesh. (10.\+0f, 10.\+0f) would be a good value to start, for example. \\
\hline
{\em tile\+Count} & Specifies how much tiles there will be. If you specifiy for example that a tile has the size (10.\+0f, 10.\+0f) and the tile\+Count is (10,10), than you get a field of 100 tiles which has the dimension 100.\+0fx100.\+0f. \\
\hline
{\em material} & Material of the hill mesh. \\
\hline
{\em hill\+Height} & Height of the hills. If you specify a negative value you will get holes instead of hills. If the height is 0, no hills will be created. \\
\hline
{\em count\+Hills} & Amount of hills on the plane. There will be count\+Hills.\+X hills along the X axis and count\+Hills.\+Y along the Y axis. So in total there will be count\+Hills.\+X $\ast$ count\+Hills.\+Y hills. \\
\hline
{\em texture\+Repeat\+Count} & Defines how often the texture will be repeated in x and y direction. return Null if the creation failed. The reason could be that you specified some invalid parameters or that a mesh with that name already exists. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}\label{classirr_1_1scene_1_1ISceneManager_a2eb986c6975ebc1aa1f68c878ac8dcda}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Hill\+Plane\+Mesh@{add\+Hill\+Plane\+Mesh}}
\index{add\+Hill\+Plane\+Mesh@{add\+Hill\+Plane\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Hill\+Plane\+Mesh()}{addHillPlaneMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Hill\+Plane\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{tile\+Size,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&}]{tile\+Count,  }\item[{\hyperlink{classirr_1_1video_1_1SMaterial}{video\+::\+S\+Material} $\ast$}]{material = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{hill\+Height = {\ttfamily 0.0f},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{count\+Hills = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(0.0f,~0.0f)},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{texture\+Repeat\+Count = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a Hill Plane mesh to the mesh pool. 

The mesh is generated on the fly and looks like a plane with some hills on it. It is uses mostly for quick tests of the engine only. You can specify how many hills there should be on the plane and how high they should be. Also you must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} with the name as parameter. 
\begin{DoxyParams}{Parameters}
{\em name} & The name of this mesh which must be specified in order to be able to retrieve the mesh later with \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()}. \\
\hline
{\em tile\+Size} & Size of a tile of the mesh. (10.\+0f, 10.\+0f) would be a good value to start, for example. \\
\hline
{\em tile\+Count} & Specifies how much tiles there will be. If you specifiy for example that a tile has the size (10.\+0f, 10.\+0f) and the tile\+Count is (10,10), than you get a field of 100 tiles which has the dimension 100.\+0fx100.\+0f. \\
\hline
{\em material} & Material of the hill mesh. \\
\hline
{\em hill\+Height} & Height of the hills. If you specify a negative value you will get holes instead of hills. If the height is 0, no hills will be created. \\
\hline
{\em count\+Hills} & Amount of hills on the plane. There will be count\+Hills.\+X hills along the X axis and count\+Hills.\+Y along the Y axis. So in total there will be count\+Hills.\+X $\ast$ count\+Hills.\+Y hills. \\
\hline
{\em texture\+Repeat\+Count} & Defines how often the texture will be repeated in x and y direction. return Null if the creation failed. The reason could be that you specified some invalid parameters or that a mesh with that name already exists. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}\label{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Light\+Scene\+Node@{add\+Light\+Scene\+Node}}
\index{add\+Light\+Scene\+Node@{add\+Light\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Light\+Scene\+Node()}{addLightSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ILightSceneNode}{I\+Light\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Light\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}}]{color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 100.0f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a dynamic light scene node to the scene graph. 

The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video\+::\+M\+T\+F\+\_\+\+L\+I\+G\+H\+T\+I\+NG turned on. (This is the default setting in most scene nodes). 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the light. Can be null. If the parent moves, the light will move too. \\
\hline
{\em position} & Position of the space relative to its parent where the light will be placed. \\
\hline
{\em color} & Diffuse color of the light. Ambient or Specular colors can be set manually with the \hyperlink{classirr_1_1scene_1_1ILightSceneNode_a20147e049be1a4790346fd72b150b30c}{I\+Light\+Scene\+Node\+::get\+Light\+Data()} method. \\
\hline
{\em radius} & Radius of the light. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the interface of the light if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}\label{classirr_1_1scene_1_1ISceneManager_a2e6442f8c95a544c355bd137ccdb7095}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Light\+Scene\+Node@{add\+Light\+Scene\+Node}}
\index{add\+Light\+Scene\+Node@{add\+Light\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Light\+Scene\+Node()}{addLightSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ILightSceneNode}{I\+Light\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Light\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}}]{color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColorf}{video\+::\+S\+Colorf}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 100.0f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a dynamic light scene node to the scene graph. 

The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video\+::\+M\+T\+F\+\_\+\+L\+I\+G\+H\+T\+I\+NG turned on. (This is the default setting in most scene nodes). 
\begin{DoxyParams}{Parameters}
{\em parent} & Parent scene node of the light. Can be null. If the parent moves, the light will move too. \\
\hline
{\em position} & Position of the space relative to its parent where the light will be placed. \\
\hline
{\em color} & Diffuse color of the light. Ambient or Specular colors can be set manually with the \hyperlink{classirr_1_1scene_1_1ILightSceneNode_a20147e049be1a4790346fd72b150b30c}{I\+Light\+Scene\+Node\+::get\+Light\+Data()} method. \\
\hline
{\em radius} & Radius of the light. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the interface of the light if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}\label{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Mesh\+Scene\+Node@{add\+Mesh\+Scene\+Node}}
\index{add\+Mesh\+Scene\+Node@{add\+Mesh\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Mesh\+Scene\+Node()}{addMeshSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Mesh\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering a static mesh. 


\begin{DoxyParams}{Parameters}
{\em mesh} & Pointer to the loaded static mesh to be displayed. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}\label{classirr_1_1scene_1_1ISceneManager_aa0a32f9f5b13d94e24eed80bdb999919}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Mesh\+Scene\+Node@{add\+Mesh\+Scene\+Node}}
\index{add\+Mesh\+Scene\+Node@{add\+Mesh\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Mesh\+Scene\+Node()}{addMeshSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Mesh\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering a static mesh. 


\begin{DoxyParams}{Parameters}
{\em mesh} & Pointer to the loaded static mesh to be displayed. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}\label{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}}
\index{add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Octree\+Scene\+Node()}{addOctreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Octree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 512},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering using a octree to the scene graph. 

This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh. 
\begin{DoxyParams}{Parameters}
{\em mesh} & The mesh containing all geometry from which the octree will be build. If this animated mesh has more than one frames in it, the first frame is taken. \\
\hline
{\em parent} & Parent node of the octree node. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the Octree if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}\label{classirr_1_1scene_1_1ISceneManager_a503339385ca2b33d7e8035a61c4eca84}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}}
\index{add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Octree\+Scene\+Node()}{addOctreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Octree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 512},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering using a octree to the scene graph. 

This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh. 
\begin{DoxyParams}{Parameters}
{\em mesh} & The mesh containing all geometry from which the octree will be build. If this animated mesh has more than one frames in it, the first frame is taken. \\
\hline
{\em parent} & Parent node of the octree node. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the Octree if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}\label{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}}
\index{add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Octree\+Scene\+Node()}{addOctreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Octree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 256},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering using a octree to the scene graph. 

This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh, much faster then a bsp tree. 
\begin{DoxyParams}{Parameters}
{\em mesh} & The mesh containing all geometry from which the octree will be build. \\
\hline
{\em parent} & Parent node of the octree node. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the octree if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}\label{classirr_1_1scene_1_1ISceneManager_abfa8d1ebb1ff681d588aea98e6e2b193}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}}
\index{add\+Octree\+Scene\+Node@{add\+Octree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Octree\+Scene\+Node()}{addOctreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Octree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 256},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering using a octree to the scene graph. 

This a good method for rendering scenes with lots of geometry. The Octree is built on the fly from the mesh, much faster then a bsp tree. 
\begin{DoxyParams}{Parameters}
{\em mesh} & The mesh containing all geometry from which the octree will be build. \\
\hline
{\em parent} & Parent node of the octree node. \\
\hline
{\em id} & id of the node. This id can be used to identify the node. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. \\
\hline
{\em also\+Add\+If\+Mesh\+Pointer\+Zero} & Add the scene node even if a 0 pointer is passed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the octree if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}\label{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}}
\index{add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Oct\+Tree\+Scene\+Node()}{addOctTreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Oct\+Tree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 512},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adds a scene node for rendering using a octree to the scene graph. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000044}{Deprecated}]Use add\+Octree\+Scene\+Node instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}\label{classirr_1_1scene_1_1ISceneManager_ad976720f7b110b47374e129b29e4e572}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}}
\index{add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Oct\+Tree\+Scene\+Node()}{addOctTreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Oct\+Tree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 512},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adds a scene node for rendering using a octree to the scene graph. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000018}{Deprecated}]Use add\+Octree\+Scene\+Node instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}\label{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}}
\index{add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Oct\+Tree\+Scene\+Node()}{addOctTreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Oct\+Tree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 256},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adds a scene node for rendering using a octree to the scene graph. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000019}{Deprecated}]Use add\+Octree\+Scene\+Node instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}\label{classirr_1_1scene_1_1ISceneManager_af2f5dfc8d5d0f525aee59058fd7457cd}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}}
\index{add\+Oct\+Tree\+Scene\+Node@{add\+Oct\+Tree\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Oct\+Tree\+Scene\+Node()}{addOctTreeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Oct\+Tree\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 256},  }\item[{bool}]{also\+Add\+If\+Mesh\+Pointer\+Zero = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adds a scene node for rendering using a octree to the scene graph. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000045}{Deprecated}]Use add\+Octree\+Scene\+Node instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}\label{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Particle\+System\+Scene\+Node@{add\+Particle\+System\+Scene\+Node}}
\index{add\+Particle\+System\+Scene\+Node@{add\+Particle\+System\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Particle\+System\+Scene\+Node()}{addParticleSystemSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode}{I\+Particle\+System\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Particle\+System\+Scene\+Node (\begin{DoxyParamCaption}\item[{bool}]{with\+Default\+Emitter = {\ttfamily true},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a particle system scene node to the scene graph. 


\begin{DoxyParams}{Parameters}
{\em with\+Default\+Emitter} & Creates a default working point emitter which emitts some particles. Set this to true to see a particle system in action. If set to false, you\textquotesingle{}ll have to set the emitter you want by calling \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode_aececff4531482ce976f1859c40bf3f76}{I\+Particle\+System\+Scene\+Node\+::set\+Emitter()}. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}\label{classirr_1_1scene_1_1ISceneManager_a1c1c2b024a01bd1d6d56518926e37fa8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Particle\+System\+Scene\+Node@{add\+Particle\+System\+Scene\+Node}}
\index{add\+Particle\+System\+Scene\+Node@{add\+Particle\+System\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Particle\+System\+Scene\+Node()}{addParticleSystemSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode}{I\+Particle\+System\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Particle\+System\+Scene\+Node (\begin{DoxyParamCaption}\item[{bool}]{with\+Default\+Emitter = {\ttfamily true},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a particle system scene node to the scene graph. 


\begin{DoxyParams}{Parameters}
{\em with\+Default\+Emitter} & Creates a default working point emitter which emitts some particles. Set this to true to see a particle system in action. If set to false, you\textquotesingle{}ll have to set the emitter you want by calling \hyperlink{classirr_1_1scene_1_1IParticleSystemSceneNode_aececff4531482ce976f1859c40bf3f76}{I\+Particle\+System\+Scene\+Node\+::set\+Emitter()}. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}\label{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Quake3\+Scene\+Node@{add\+Quake3\+Scene\+Node}}
\index{add\+Quake3\+Scene\+Node@{add\+Quake3\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Quake3\+Scene\+Node()}{addQuake3SceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Quake3\+Scene\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1scene_1_1IMeshBuffer}{I\+Mesh\+Buffer} $\ast$}]{mesh\+Buffer,  }\item[{const \hyperlink{structirr_1_1scene_1_1quake3_1_1IShader}{quake3\+::\+I\+Shader} $\ast$}]{shader,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a quake3 scene node to the scene graph. 

A Quake3 Scene renders multiple meshes for a specific High\+Language Shader (Quake3 Style ) \begin{DoxyReturn}{Returns}
Pointer to the quake3 scene node if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}\label{classirr_1_1scene_1_1ISceneManager_a58642d304110532988d27cebbe76ed41}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Quake3\+Scene\+Node@{add\+Quake3\+Scene\+Node}}
\index{add\+Quake3\+Scene\+Node@{add\+Quake3\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Quake3\+Scene\+Node()}{addQuake3SceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Quake3\+Scene\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1scene_1_1IMeshBuffer}{I\+Mesh\+Buffer} $\ast$}]{mesh\+Buffer,  }\item[{const \hyperlink{structirr_1_1scene_1_1quake3_1_1IShader}{quake3\+::\+I\+Shader} $\ast$}]{shader,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a quake3 scene node to the scene graph. 

A Quake3 Scene renders multiple meshes for a specific High\+Language Shader (Quake3 Style ) \begin{DoxyReturn}{Returns}
Pointer to the quake3 scene node if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}\label{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Scene\+Node@{add\+Scene\+Node}}
\index{add\+Scene\+Node@{add\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Scene\+Node()}{addSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Scene\+Node (\begin{DoxyParamCaption}\item[{const char $\ast$}]{scene\+Node\+Type\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node to the scene by name. 

\begin{DoxyReturn}{Returns}
Pointer to the scene node added by a factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}\label{classirr_1_1scene_1_1ISceneManager_a22ea17e8c06a773af9828f7bb70cdc40}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Scene\+Node@{add\+Scene\+Node}}
\index{add\+Scene\+Node@{add\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Scene\+Node()}{addSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Scene\+Node (\begin{DoxyParamCaption}\item[{const char $\ast$}]{scene\+Node\+Type\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node to the scene by name. 

\begin{DoxyReturn}{Returns}
Pointer to the scene node added by a factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}\label{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sky\+Box\+Scene\+Node@{add\+Sky\+Box\+Scene\+Node}}
\index{add\+Sky\+Box\+Scene\+Node@{add\+Sky\+Box\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sky\+Box\+Scene\+Node()}{addSkyBoxSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sky\+Box\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{top,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{bottom,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{left,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{right,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{front,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{back,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a skybox scene node to the scene graph. 

A skybox is a big cube with 6 textures on it and is drawn around the camera position. 
\begin{DoxyParams}{Parameters}
{\em top} & Texture for the top plane of the box. \\
\hline
{\em bottom} & Texture for the bottom plane of the box. \\
\hline
{\em left} & Texture for the left plane of the box. \\
\hline
{\em right} & Texture for the right plane of the box. \\
\hline
{\em front} & Texture for the front plane of the box. \\
\hline
{\em back} & Texture for the back plane of the box. \\
\hline
{\em parent} & Parent scene node of the skybox. A skybox usually has no parent, so this should be null. Note\+: If a parent is set to the skybox, the box will not change how it is drawn. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sky box if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}\label{classirr_1_1scene_1_1ISceneManager_a2b08b9f20ec62faeffc02b9fed9fd683}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sky\+Box\+Scene\+Node@{add\+Sky\+Box\+Scene\+Node}}
\index{add\+Sky\+Box\+Scene\+Node@{add\+Sky\+Box\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sky\+Box\+Scene\+Node()}{addSkyBoxSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sky\+Box\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{top,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{bottom,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{left,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{right,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{front,  }\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{back,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a skybox scene node to the scene graph. 

A skybox is a big cube with 6 textures on it and is drawn around the camera position. 
\begin{DoxyParams}{Parameters}
{\em top} & Texture for the top plane of the box. \\
\hline
{\em bottom} & Texture for the bottom plane of the box. \\
\hline
{\em left} & Texture for the left plane of the box. \\
\hline
{\em right} & Texture for the right plane of the box. \\
\hline
{\em front} & Texture for the front plane of the box. \\
\hline
{\em back} & Texture for the back plane of the box. \\
\hline
{\em parent} & Parent scene node of the skybox. A skybox usually has no parent, so this should be null. Note\+: If a parent is set to the skybox, the box will not change how it is drawn. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sky box if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}\label{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sky\+Dome\+Scene\+Node@{add\+Sky\+Dome\+Scene\+Node}}
\index{add\+Sky\+Dome\+Scene\+Node@{add\+Sky\+Dome\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sky\+Dome\+Scene\+Node()}{addSkyDomeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sky\+Dome\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{texture,  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{hori\+Res = {\ttfamily 16},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{vert\+Res = {\ttfamily 8},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{texture\+Percentage = {\ttfamily 0.9},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{sphere\+Percentage = {\ttfamily 2.0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 1000.f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a skydome scene node to the scene graph. 

A skydome is a large (half-\/) sphere with a panoramic texture on the inside and is drawn around the camera position. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture for the dome. \\
\hline
{\em hori\+Res} & Number of vertices of a horizontal layer of the sphere. \\
\hline
{\em vert\+Res} & Number of vertices of a vertical layer of the sphere. \\
\hline
{\em texture\+Percentage} & How much of the height of the texture is used. Should be between 0 and 1. \\
\hline
{\em sphere\+Percentage} & How much of the sphere is drawn. Value should be between 0 and 2, where 1 is an exact half-\/sphere and 2 is a full sphere. \\
\hline
{\em radius} & The Radius of the sphere \\
\hline
{\em parent} & Parent scene node of the dome. A dome usually has no parent, so this should be null. Note\+: If a parent is set, the dome will not change how it is drawn. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sky dome if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}\label{classirr_1_1scene_1_1ISceneManager_aadf84a7a18a5ed92d9868f90c506daa7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sky\+Dome\+Scene\+Node@{add\+Sky\+Dome\+Scene\+Node}}
\index{add\+Sky\+Dome\+Scene\+Node@{add\+Sky\+Dome\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sky\+Dome\+Scene\+Node()}{addSkyDomeSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sky\+Dome\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$}]{texture,  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{hori\+Res = {\ttfamily 16},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{vert\+Res = {\ttfamily 8},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{texture\+Percentage = {\ttfamily 0.9},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{sphere\+Percentage = {\ttfamily 2.0},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 1000.f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a skydome scene node to the scene graph. 

A skydome is a large (half-\/) sphere with a panoramic texture on the inside and is drawn around the camera position. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture for the dome. \\
\hline
{\em hori\+Res} & Number of vertices of a horizontal layer of the sphere. \\
\hline
{\em vert\+Res} & Number of vertices of a vertical layer of the sphere. \\
\hline
{\em texture\+Percentage} & How much of the height of the texture is used. Should be between 0 and 1. \\
\hline
{\em sphere\+Percentage} & How much of the sphere is drawn. Value should be between 0 and 2, where 1 is an exact half-\/sphere and 2 is a full sphere. \\
\hline
{\em radius} & The Radius of the sphere \\
\hline
{\em parent} & Parent scene node of the dome. A dome usually has no parent, so this should be null. Note\+: If a parent is set, the dome will not change how it is drawn. \\
\hline
{\em id} & An id of the node. This id can be used to identify the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sky dome if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}\label{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sphere\+Mesh@{add\+Sphere\+Mesh}}
\index{add\+Sphere\+Mesh@{add\+Sphere\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sphere\+Mesh()}{addSphereMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sphere\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 5.f},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{poly\+CountX = {\ttfamily 16},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{poly\+CountY = {\ttfamily 16} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



add a static sphere mesh to the meshpool 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em radius} & Radius of the sphere \\
\hline
{\em poly\+CountX} & Number of quads used for the horizontal tiling \\
\hline
{\em poly\+CountY} & Number of quads used for the vertical tiling \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sphere mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}\label{classirr_1_1scene_1_1ISceneManager_a9e9e8524055ca841c0bb16316f4b8212}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sphere\+Mesh@{add\+Sphere\+Mesh}}
\index{add\+Sphere\+Mesh@{add\+Sphere\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sphere\+Mesh()}{addSphereMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sphere\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 5.f},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{poly\+CountX = {\ttfamily 16},  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{poly\+CountY = {\ttfamily 16} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



add a static sphere mesh to the meshpool 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em radius} & Radius of the sphere \\
\hline
{\em poly\+CountX} & Number of quads used for the horizontal tiling \\
\hline
{\em poly\+CountY} & Number of quads used for the vertical tiling \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the sphere mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}\label{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sphere\+Scene\+Node@{add\+Sphere\+Scene\+Node}}
\index{add\+Sphere\+Scene\+Node@{add\+Sphere\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sphere\+Scene\+Node()}{addSphereSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sphere\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 5.0f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{poly\+Count = {\ttfamily 16},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a sphere scene node of the given radius and detail. 


\begin{DoxyParams}{Parameters}
{\em radius} & Radius of the sphere. \\
\hline
{\em poly\+Count} & The number of vertices in horizontal and vertical direction. The total poly\+Count of the sphere is poly\+Count$\ast$poly\+Count. This parameter must be less than 256 to stay within the 16-\/bit limit of the indices of a meshbuffer. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created test scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}\label{classirr_1_1scene_1_1ISceneManager_acd6454347276ff8c74e46063970cfc04}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Sphere\+Scene\+Node@{add\+Sphere\+Scene\+Node}}
\index{add\+Sphere\+Scene\+Node@{add\+Sphere\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Sphere\+Scene\+Node()}{addSphereSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshSceneNode}{I\+Mesh\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Sphere\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 5.0f},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{poly\+Count = {\ttfamily 16},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a sphere scene node of the given radius and detail. 


\begin{DoxyParams}{Parameters}
{\em radius} & Radius of the sphere. \\
\hline
{\em poly\+Count} & The number of vertices in horizontal and vertical direction. The total poly\+Count of the sphere is poly\+Count$\ast$poly\+Count. This parameter must be less than 256 to stay within the 16-\/bit limit of the indices of a meshbuffer. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created test scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}\label{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Mesh@{add\+Terrain\+Mesh}}
\index{add\+Terrain\+Mesh@{add\+Terrain\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Mesh()}{addTerrainMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{meshname,  }\item[{\hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$}]{texture,  }\item[{\hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$}]{heightmap,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{stretch\+Size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{max\+Height = {\ttfamily 200.0f},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&}]{default\+Vertex\+Block\+Size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}~$>$(64,~64)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a static terrain mesh to the mesh pool. 

The mesh is generated on the fly from a texture file and a height map file. Both files may be huge (8000x8000 pixels would be no problem) because the generator splits the files into smaller textures if necessary. You must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} with the name as parameter. 
\begin{DoxyParams}{Parameters}
{\em meshname} & The name of this mesh which must be specified in order to be able to retrieve the mesh later with \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()}. \\
\hline
{\em texture} & Texture for the terrain. Please note that this is not a hardware texture as usual (I\+Texture), but an I\+Image software texture. You can load this texture with I\+Video\+Driver\+::create\+Image\+From\+File(). \\
\hline
{\em heightmap} & A grayscaled heightmap image. Like the texture, it can be created with I\+Video\+Driver\+::create\+Image\+From\+File(). The amount of triangles created depends on the size of this texture, so use a small heightmap to increase rendering speed. \\
\hline
{\em stretch\+Size} & Parameter defining how big a is pixel on the heightmap. \\
\hline
{\em max\+Height} & Defines how high a white pixel on the heighmap is. \\
\hline
{\em default\+Vertex\+Block\+Size} & Defines the initial dimension between vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null if the creation failed. The reason could be that you specified some invalid parameters, that a mesh with that name already exists, or that a texture could not be found. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}\label{classirr_1_1scene_1_1ISceneManager_ac56c56d5ec02bfe7cfb35db7afc19b50}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Mesh@{add\+Terrain\+Mesh}}
\index{add\+Terrain\+Mesh@{add\+Terrain\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Mesh()}{addTerrainMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{meshname,  }\item[{\hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$}]{texture,  }\item[{\hyperlink{classirr_1_1video_1_1IImage}{video\+::\+I\+Image} $\ast$}]{heightmap,  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&}]{stretch\+Size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}~$>$(10.0f,~10.0f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{max\+Height = {\ttfamily 200.0f},  }\item[{const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&}]{default\+Vertex\+Block\+Size = {\ttfamily \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$~\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}~$>$(64,~64)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a static terrain mesh to the mesh pool. 

The mesh is generated on the fly from a texture file and a height map file. Both files may be huge (8000x8000 pixels would be no problem) because the generator splits the files into smaller textures if necessary. You must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} with the name as parameter. 
\begin{DoxyParams}{Parameters}
{\em meshname} & The name of this mesh which must be specified in order to be able to retrieve the mesh later with \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()}. \\
\hline
{\em texture} & Texture for the terrain. Please note that this is not a hardware texture as usual (I\+Texture), but an I\+Image software texture. You can load this texture with I\+Video\+Driver\+::create\+Image\+From\+File(). \\
\hline
{\em heightmap} & A grayscaled heightmap image. Like the texture, it can be created with I\+Video\+Driver\+::create\+Image\+From\+File(). The amount of triangles created depends on the size of this texture, so use a small heightmap to increase rendering speed. \\
\hline
{\em stretch\+Size} & Parameter defining how big a is pixel on the heightmap. \\
\hline
{\em max\+Height} & Defines how high a white pixel on the heighmap is. \\
\hline
{\em default\+Vertex\+Block\+Size} & Defines the initial dimension between vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null if the creation failed. The reason could be that you specified some invalid parameters, that a mesh with that name already exists, or that a texture could not be found. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}\label{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}}
\index{add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Scene\+Node()}{addTerrainSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Scene\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{height\+Map\+File\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vertex\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(255,~255,~255,~255)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{max\+L\+OD = {\ttfamily 5},  }\item[{\hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044}{E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+ZE}}]{patch\+Size = {\ttfamily \hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044a3b0d536665e67bc8c8e098e512db2671}{E\+T\+P\+S\+\_\+17}},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{smooth\+Factor = {\ttfamily 0},  }\item[{bool}]{add\+Also\+If\+Heightmap\+Empty = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a terrain scene node to the scene graph. 

This node implements is a simple terrain renderer which uses a technique known as geo mip mapping for reducing the detail of triangle blocks which are far away. The code for the Terrain\+Scene\+Node is based on the terrain renderer by Soconne and the Geo\+Mip\+Map\+Scene\+Node developed by Spintz. They made their code available for Irrlicht and allowed it to be distributed under this licence. I only modified some parts. A lot of thanks go to them.

This scene node is capable of loading terrains and updating the indices at runtime to enable viewing very large terrains very quickly. It uses a C\+L\+OD (Continuous \hyperlink{classLevel}{Level} of Detail) algorithm which updates the indices for each patch based on a L\+OD (\hyperlink{classLevel}{Level} of Detail) which is determined based on a patch\textquotesingle{}s distance from the camera.

The patch size of the terrain must always be a size of 2$^\wedge$\+N+1, i.\+e. 8+1(9), 16+1(17), etc. The Max\+L\+OD available is directly dependent on the patch size of the terrain. L\+OD 0 contains all of the indices to draw all the triangles at the max detail for a patch. As each L\+OD goes up by 1 the step taken, in generating indices increases by -\/2$^\wedge$\+L\+OD, so for L\+OD 1, the step taken is 2, for L\+OD 2, the step taken is 4, L\+OD 3 -\/ 8, etc. The step can be no larger than the size of the patch, so having a L\+OD of 8, with a patch size of 17, is asking the algoritm to generate indices every 2$^\wedge$8 ( 256 ) vertices, which is not possible with a patch size of 17. The maximum L\+OD for a patch size of 17 is 2$^\wedge$4 ( 16 ). So, with a Max\+L\+OD of 5, you\textquotesingle{}ll have L\+OD 0 ( full detail ), L\+OD 1 ( every 2 vertices ), L\+OD 2 ( every 4 vertices ), L\+OD 3 ( every 8 vertices ) and L\+OD 4 ( every 16 vertices ). 
\begin{DoxyParams}{Parameters}
{\em height\+Map\+File\+Name} & The name of the file on disk, to read vertex data from. This should be a gray scale bitmap. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & The absolute position of this node. \\
\hline
{\em rotation} & The absolute rotation of this node. ( N\+OT Y\+ET I\+M\+P\+L\+E\+M\+E\+N\+T\+ED ) \\
\hline
{\em scale} & The scale factor for the terrain. If you\textquotesingle{}re using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core\+::vector ( 100.\+0f, 100.\+0f, 100.\+0f ). If you use a Y scaling factor of 0.\+0f, then your terrain will be flat. \\
\hline
{\em vertex\+Color} & The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. \\
\hline
{\em max\+L\+OD} & The maximum L\+OD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em patch\+Size} & patch size of the terrain. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em smooth\+Factor} & The number of times the vertices are smoothed. \\
\hline
{\em add\+Also\+If\+Heightmap\+Empty} & Add terrain node even with empty heightmap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}\label{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}}
\index{add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Scene\+Node()}{addTerrainSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Scene\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{height\+Map\+File\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vertex\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(255,~255,~255,~255)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{max\+L\+OD = {\ttfamily 5},  }\item[{\hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044}{E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+ZE}}]{patch\+Size = {\ttfamily \hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044a3b0d536665e67bc8c8e098e512db2671}{E\+T\+P\+S\+\_\+17}},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{smooth\+Factor = {\ttfamily 0},  }\item[{bool}]{add\+Also\+If\+Heightmap\+Empty = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a terrain scene node to the scene graph. 

This node implements is a simple terrain renderer which uses a technique known as geo mip mapping for reducing the detail of triangle blocks which are far away. The code for the Terrain\+Scene\+Node is based on the terrain renderer by Soconne and the Geo\+Mip\+Map\+Scene\+Node developed by Spintz. They made their code available for Irrlicht and allowed it to be distributed under this licence. I only modified some parts. A lot of thanks go to them.

This scene node is capable of loading terrains and updating the indices at runtime to enable viewing very large terrains very quickly. It uses a C\+L\+OD (Continuous \hyperlink{classLevel}{Level} of Detail) algorithm which updates the indices for each patch based on a L\+OD (\hyperlink{classLevel}{Level} of Detail) which is determined based on a patch\textquotesingle{}s distance from the camera.

The patch size of the terrain must always be a size of 2$^\wedge$\+N+1, i.\+e. 8+1(9), 16+1(17), etc. The Max\+L\+OD available is directly dependent on the patch size of the terrain. L\+OD 0 contains all of the indices to draw all the triangles at the max detail for a patch. As each L\+OD goes up by 1 the step taken, in generating indices increases by -\/2$^\wedge$\+L\+OD, so for L\+OD 1, the step taken is 2, for L\+OD 2, the step taken is 4, L\+OD 3 -\/ 8, etc. The step can be no larger than the size of the patch, so having a L\+OD of 8, with a patch size of 17, is asking the algoritm to generate indices every 2$^\wedge$8 ( 256 ) vertices, which is not possible with a patch size of 17. The maximum L\+OD for a patch size of 17 is 2$^\wedge$4 ( 16 ). So, with a Max\+L\+OD of 5, you\textquotesingle{}ll have L\+OD 0 ( full detail ), L\+OD 1 ( every 2 vertices ), L\+OD 2 ( every 4 vertices ), L\+OD 3 ( every 8 vertices ) and L\+OD 4 ( every 16 vertices ). 
\begin{DoxyParams}{Parameters}
{\em height\+Map\+File\+Name} & The name of the file on disk, to read vertex data from. This should be a gray scale bitmap. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & The absolute position of this node. \\
\hline
{\em rotation} & The absolute rotation of this node. ( N\+OT Y\+ET I\+M\+P\+L\+E\+M\+E\+N\+T\+ED ) \\
\hline
{\em scale} & The scale factor for the terrain. If you\textquotesingle{}re using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core\+::vector ( 100.\+0f, 100.\+0f, 100.\+0f ). If you use a Y scaling factor of 0.\+0f, then your terrain will be flat. \\
\hline
{\em vertex\+Color} & The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. \\
\hline
{\em max\+L\+OD} & The maximum L\+OD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em patch\+Size} & patch size of the terrain. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em smooth\+Factor} & The number of times the vertices are smoothed. \\
\hline
{\em add\+Also\+If\+Heightmap\+Empty} & Add terrain node even with empty heightmap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}\label{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}}
\index{add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Scene\+Node()}{addTerrainSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{height\+Map\+File,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vertex\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(255,~255,~255,~255)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{max\+L\+OD = {\ttfamily 5},  }\item[{\hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044}{E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+ZE}}]{patch\+Size = {\ttfamily \hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044a3b0d536665e67bc8c8e098e512db2671}{E\+T\+P\+S\+\_\+17}},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{smooth\+Factor = {\ttfamily 0},  }\item[{bool}]{add\+Also\+If\+Heightmap\+Empty = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a terrain scene node to the scene graph. 

Just like the other \hyperlink{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}{add\+Terrain\+Scene\+Node()} method, but takes an I\+Read\+File pointer as parameter for the heightmap. For more informations take a look at the other function. 
\begin{DoxyParams}{Parameters}
{\em height\+Map\+File} & The file handle to read vertex data from. This should be a gray scale bitmap. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & The absolute position of this node. \\
\hline
{\em rotation} & The absolute rotation of this node. ( N\+OT Y\+ET I\+M\+P\+L\+E\+M\+E\+N\+T\+ED ) \\
\hline
{\em scale} & The scale factor for the terrain. If you\textquotesingle{}re using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core\+::vector ( 100.\+0f, 100.\+0f, 100.\+0f ). If you use a Y scaling factor of 0.\+0f, then your terrain will be flat. \\
\hline
{\em vertex\+Color} & The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. \\
\hline
{\em max\+L\+OD} & The maximum L\+OD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em patch\+Size} & patch size of the terrain. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em smooth\+Factor} & The number of times the vertices are smoothed. \\
\hline
{\em add\+Also\+If\+Heightmap\+Empty} & Add terrain node even with empty heightmap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}\label{classirr_1_1scene_1_1ISceneManager_ae89a0a2d162a86f087eec66ddcd801b6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}}
\index{add\+Terrain\+Scene\+Node@{add\+Terrain\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Terrain\+Scene\+Node()}{addTerrainSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Terrain\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{height\+Map\+File,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.0f,~0.0f,~0.0f)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)},  }\item[{\hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{vertex\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(255,~255,~255,~255)},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{max\+L\+OD = {\ttfamily 5},  }\item[{\hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044}{E\+\_\+\+T\+E\+R\+R\+A\+I\+N\+\_\+\+P\+A\+T\+C\+H\+\_\+\+S\+I\+ZE}}]{patch\+Size = {\ttfamily \hyperlink{namespaceirr_1_1scene_a6de1eb2d024f82b5b1af499d61523044a3b0d536665e67bc8c8e098e512db2671}{E\+T\+P\+S\+\_\+17}},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{smooth\+Factor = {\ttfamily 0},  }\item[{bool}]{add\+Also\+If\+Heightmap\+Empty = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a terrain scene node to the scene graph. 

Just like the other \hyperlink{classirr_1_1scene_1_1ISceneManager_a2188fb0443c7e0b6b69a673ca1d9ca5c}{add\+Terrain\+Scene\+Node()} method, but takes an I\+Read\+File pointer as parameter for the heightmap. For more informations take a look at the other function. 
\begin{DoxyParams}{Parameters}
{\em height\+Map\+File} & The file handle to read vertex data from. This should be a gray scale bitmap. \\
\hline
{\em parent} & Parent of the scene node. Can be 0 if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & The absolute position of this node. \\
\hline
{\em rotation} & The absolute rotation of this node. ( N\+OT Y\+ET I\+M\+P\+L\+E\+M\+E\+N\+T\+ED ) \\
\hline
{\em scale} & The scale factor for the terrain. If you\textquotesingle{}re using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core\+::vector ( 100.\+0f, 100.\+0f, 100.\+0f ). If you use a Y scaling factor of 0.\+0f, then your terrain will be flat. \\
\hline
{\em vertex\+Color} & The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. \\
\hline
{\em max\+L\+OD} & The maximum L\+OD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em patch\+Size} & patch size of the terrain. Only change if you know what you are doing, this might lead to strange behavior. \\
\hline
{\em smooth\+Factor} & The number of times the vertices are smoothed. \\
\hline
{\em add\+Also\+If\+Heightmap\+Empty} & Add terrain node even with empty heightmap. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}\label{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+To\+Deletion\+Queue@{add\+To\+Deletion\+Queue}}
\index{add\+To\+Deletion\+Queue@{add\+To\+Deletion\+Queue}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+To\+Deletion\+Queue()}{addToDeletionQueue()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+To\+Deletion\+Queue (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node to the deletion queue. 

The scene node is immediatly deleted when it\textquotesingle{}s secure. Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a \hyperlink{classirr_1_1scene_1_1ISceneNode_a2efa2670e29d6bb33b0dd99403b8b69c}{I\+Scene\+Node\+::remove()} call is enough, using this deletion queue is not necessary. See \hyperlink{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}{I\+Scene\+Manager\+::create\+Delete\+Animator()} for details. 
\begin{DoxyParams}{Parameters}
{\em node} & Node to detete. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}\label{classirr_1_1scene_1_1ISceneManager_a11eac917a4c75c7a7730198d7bf31f5a}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+To\+Deletion\+Queue@{add\+To\+Deletion\+Queue}}
\index{add\+To\+Deletion\+Queue@{add\+To\+Deletion\+Queue}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+To\+Deletion\+Queue()}{addToDeletionQueue()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::add\+To\+Deletion\+Queue (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node to the deletion queue. 

The scene node is immediatly deleted when it\textquotesingle{}s secure. Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a \hyperlink{classirr_1_1scene_1_1ISceneNode_a2efa2670e29d6bb33b0dd99403b8b69c}{I\+Scene\+Node\+::remove()} call is enough, using this deletion queue is not necessary. See \hyperlink{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}{I\+Scene\+Manager\+::create\+Delete\+Animator()} for details. 
\begin{DoxyParams}{Parameters}
{\em node} & Node to detete. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}\label{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Volume\+Light\+Mesh@{add\+Volume\+Light\+Mesh}}
\index{add\+Volume\+Light\+Mesh@{add\+Volume\+Light\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Volume\+Light\+Mesh()}{addVolumeLightMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Volume\+Light\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{SubdivideU = {\ttfamily 32},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{SubdivideV = {\ttfamily 32},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{Foot\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51,~0,~230,~180)},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{Tail\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0,~0,~0,~0)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Add a volume light mesh to the meshpool. 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em SubdivideU} & Horizontal subdivision count \\
\hline
{\em SubdivideV} & Vertical subdivision count \\
\hline
{\em Foot\+Color} & Color of the bottom of the light \\
\hline
{\em Tail\+Color} & Color of the top of the light \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the volume light mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}\label{classirr_1_1scene_1_1ISceneManager_a7086c554b86bdf055d6ebcc5950e1f16}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Volume\+Light\+Mesh@{add\+Volume\+Light\+Mesh}}
\index{add\+Volume\+Light\+Mesh@{add\+Volume\+Light\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Volume\+Light\+Mesh()}{addVolumeLightMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Volume\+Light\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{name,  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{SubdivideU = {\ttfamily 32},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{SubdivideV = {\ttfamily 32},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{Foot\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51,~0,~230,~180)},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{Tail\+Color = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0,~0,~0,~0)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Add a volume light mesh to the meshpool. 


\begin{DoxyParams}{Parameters}
{\em name} & Name of the mesh \\
\hline
{\em SubdivideU} & Horizontal subdivision count \\
\hline
{\em SubdivideV} & Vertical subdivision count \\
\hline
{\em Foot\+Color} & Color of the bottom of the light \\
\hline
{\em Tail\+Color} & Color of the top of the light \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the volume light mesh if successful, otherwise 0. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}\label{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Volume\+Light\+Scene\+Node@{add\+Volume\+Light\+Scene\+Node}}
\index{add\+Volume\+Light\+Scene\+Node@{add\+Volume\+Light\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Volume\+Light\+Scene\+Node()}{addVolumeLightSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual I\+Volume\+Light\+Scene\+Node$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Volume\+Light\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{subdivU = {\ttfamily 32},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{subdivV = {\ttfamily 32},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{foot = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51,~0,~230,~180)},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{tail = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0,~0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



adds Volume Lighting Scene Node. 

Example Usage\+: scene\+::\+I\+Volume\+Light\+Scene\+Node $\ast$ n = smgr-\/$>$add\+Volume\+Light\+Scene\+Node(0, -\/1, 32, 32, //\+Subdivide U/V video\+::\+S\+Color(0, 180, 180, 180), //foot color video\+::\+S\+Color(0, 0, 0, 0) //tail color ); if (n) \{ n-\/$>$set\+Scale(\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(46.\+0f, 45.\+0f, 46.\+0f)); n-\/$>$get\+Material(0).set\+Texture(0, smgr-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}{get\+Video\+Driver()}-\/$>$get\+Texture(\char`\"{}light\+Falloff.\+png\char`\"{})); \} \begin{DoxyReturn}{Returns}
Pointer to the volume\+Light if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}\label{classirr_1_1scene_1_1ISceneManager_a75fc84dd6ee9140da8fd63357947c724}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Volume\+Light\+Scene\+Node@{add\+Volume\+Light\+Scene\+Node}}
\index{add\+Volume\+Light\+Scene\+Node@{add\+Volume\+Light\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Volume\+Light\+Scene\+Node()}{addVolumeLightSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual I\+Volume\+Light\+Scene\+Node$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Volume\+Light\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{subdivU = {\ttfamily 32},  }\item[{const \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{subdivV = {\ttfamily 32},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{foot = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(51,~0,~230,~180)},  }\item[{const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}}]{tail = {\ttfamily \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color}(0,~0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



adds Volume Lighting Scene Node. 

Example Usage\+: scene\+::\+I\+Volume\+Light\+Scene\+Node $\ast$ n = smgr-\/$>$add\+Volume\+Light\+Scene\+Node(0, -\/1, 32, 32, //\+Subdivide U/V video\+::\+S\+Color(0, 180, 180, 180), //foot color video\+::\+S\+Color(0, 0, 0, 0) //tail color ); if (n) \{ n-\/$>$set\+Scale(\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(46.\+0f, 45.\+0f, 46.\+0f)); n-\/$>$get\+Material(0).set\+Texture(0, smgr-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}{get\+Video\+Driver()}-\/$>$get\+Texture(\char`\"{}light\+Falloff.\+png\char`\"{})); \} \begin{DoxyReturn}{Returns}
Pointer to the volume\+Light if successful, otherwise N\+U\+LL. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}\label{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Water\+Surface\+Scene\+Node@{add\+Water\+Surface\+Scene\+Node}}
\index{add\+Water\+Surface\+Scene\+Node@{add\+Water\+Surface\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Water\+Surface\+Scene\+Node()}{addWaterSurfaceSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Water\+Surface\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Height = {\ttfamily 2.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Speed = {\ttfamily 300.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Length = {\ttfamily 10.0f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering a animated water surface mesh. 

Looks really good when the Material type E\+M\+T\+\_\+\+T\+R\+A\+N\+S\+P\+A\+R\+E\+N\+T\+\_\+\+R\+E\+F\+L\+E\+C\+T\+I\+ON is used. 
\begin{DoxyParams}{Parameters}
{\em wave\+Height} & Height of the water waves. \\
\hline
{\em wave\+Speed} & Speed of the water waves. \\
\hline
{\em wave\+Length} & Lenght of a water wave. \\
\hline
{\em mesh} & Pointer to the loaded static mesh to be displayed with water waves on it. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}\label{classirr_1_1scene_1_1ISceneManager_a5f5beb6271d3ab753687400dd6573044}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!add\+Water\+Surface\+Scene\+Node@{add\+Water\+Surface\+Scene\+Node}}
\index{add\+Water\+Surface\+Scene\+Node@{add\+Water\+Surface\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{add\+Water\+Surface\+Scene\+Node()}{addWaterSurfaceSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::add\+Water\+Surface\+Scene\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Height = {\ttfamily 2.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Speed = {\ttfamily 300.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{wave\+Length = {\ttfamily 10.0f},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{parent = {\ttfamily 0},  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id = {\ttfamily -\/1},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{position = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{scale = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(1.0f,~1.0f,~1.0f)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node for rendering a animated water surface mesh. 

Looks really good when the Material type E\+M\+T\+\_\+\+T\+R\+A\+N\+S\+P\+A\+R\+E\+N\+T\+\_\+\+R\+E\+F\+L\+E\+C\+T\+I\+ON is used. 
\begin{DoxyParams}{Parameters}
{\em wave\+Height} & Height of the water waves. \\
\hline
{\em wave\+Speed} & Speed of the water waves. \\
\hline
{\em wave\+Length} & Lenght of a water wave. \\
\hline
{\em mesh} & Pointer to the loaded static mesh to be displayed with water waves on it. \\
\hline
{\em parent} & Parent of the scene node. Can be N\+U\+LL if no parent. \\
\hline
{\em id} & Id of the node. This id can be used to identify the scene node. \\
\hline
{\em position} & Position of the space relative to its parent where the scene node will be placed. \\
\hline
{\em rotation} & Initital rotation of the scene node. \\
\hline
{\em scale} & Initial scale of the scene node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the created scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}\label{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!clear@{clear}}
\index{clear@{clear}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{clear()}{clear()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Clears the whole scene. 

All scene nodes are removed. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}\label{classirr_1_1scene_1_1ISceneManager_abaa3d11a833b89f7579848e234881988}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!clear@{clear}}
\index{clear@{clear}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{clear()}{clear()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Clears the whole scene. 

All scene nodes are removed. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}\label{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Collision\+Response\+Animator@{create\+Collision\+Response\+Animator}}
\index{create\+Collision\+Response\+Animator@{create\+Collision\+Response\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Collision\+Response\+Animator()}{createCollisionResponseAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Collision\+Response\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$}]{world,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{scene\+Node,  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{ellipsoid\+Radius = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(30,~60,~30)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{gravity\+Per\+Second = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.0f,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{ellipsoid\+Translation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{sliding\+Value = {\ttfamily 0.0005f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a special scene node animator for doing automatic collision detection and response. 

See \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response} for details. 
\begin{DoxyParams}{Parameters}
{\em world} & Triangle selector holding all triangles of the world with which the scene node may collide. You can create a triangle selector with \hyperlink{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}{I\+Scene\+Manager\+::create\+Triangle\+Selector()}; \\
\hline
{\em scene\+Node} & Scene\+Node which should be manipulated. After you added this animator to the scene node, the scene node will not be able to move through walls and is affected by gravity. If you need to teleport the scene node to a new position without it being effected by the collision geometry, then call scene\+Node-\/$>$set\+Position(); then animator-\/$>$set\+Target\+Node(scene\+Node); \\
\hline
{\em ellipsoid\+Radius} & Radius of the ellipsoid with which collision detection and response is done. If you have got a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it\+: 
\begin{DoxyCode}
\textcolor{keyword}{const} core::aabbox3d<f32>& box = yourSceneNode->getBoundingBox();
\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core::vector3df} radius = box.MaxEdge - box.getCenter();
\end{DoxyCode}
 \\
\hline
{\em gravity\+Per\+Second} & Sets the gravity of the environment, as an acceleration in units per second per second. If your units are equivalent to metres, then \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.\+0f,0) would give an approximately realistic gravity. You can disable gravity by setting it to core\+::vector3df(0,0,0). \\
\hline
{\em ellipsoid\+Translation} & By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. \\
\hline
{\em sliding\+Value} & D\+O\+C\+U\+M\+E\+N\+T\+A\+T\+I\+ON N\+E\+E\+D\+ED. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will cause it to do collision detection and response. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}\label{classirr_1_1scene_1_1ISceneManager_a67b266cc40ebd66b5d21c26a78f002be}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Collision\+Response\+Animator@{create\+Collision\+Response\+Animator}}
\index{create\+Collision\+Response\+Animator@{create\+Collision\+Response\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Collision\+Response\+Animator()}{createCollisionResponseAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Collision\+Response\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector} $\ast$}]{world,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{scene\+Node,  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{ellipsoid\+Radius = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(30,~60,~30)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{gravity\+Per\+Second = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.0f,~0)},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{ellipsoid\+Translation = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,~0,~0)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{sliding\+Value = {\ttfamily 0.0005f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a special scene node animator for doing automatic collision detection and response. 

See \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse}{I\+Scene\+Node\+Animator\+Collision\+Response} for details. 
\begin{DoxyParams}{Parameters}
{\em world} & Triangle selector holding all triangles of the world with which the scene node may collide. You can create a triangle selector with \hyperlink{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}{I\+Scene\+Manager\+::create\+Triangle\+Selector()}; \\
\hline
{\em scene\+Node} & Scene\+Node which should be manipulated. After you added this animator to the scene node, the scene node will not be able to move through walls and is affected by gravity. If you need to teleport the scene node to a new position without it being effected by the collision geometry, then call scene\+Node-\/$>$set\+Position(); then animator-\/$>$set\+Target\+Node(scene\+Node); \\
\hline
{\em ellipsoid\+Radius} & Radius of the ellipsoid with which collision detection and response is done. If you have got a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it\+: 
\begin{DoxyCode}
\textcolor{keyword}{const} core::aabbox3d<f32>& box = yourSceneNode->getBoundingBox();
\hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core::vector3df} radius = box.MaxEdge - box.getCenter();
\end{DoxyCode}
 \\
\hline
{\em gravity\+Per\+Second} & Sets the gravity of the environment, as an acceleration in units per second per second. If your units are equivalent to metres, then \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0,-\/10.\+0f,0) would give an approximately realistic gravity. You can disable gravity by setting it to core\+::vector3df(0,0,0). \\
\hline
{\em ellipsoid\+Translation} & By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. \\
\hline
{\em sliding\+Value} & D\+O\+C\+U\+M\+E\+N\+T\+A\+T\+I\+ON N\+E\+E\+D\+ED. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will cause it to do collision detection and response. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}\label{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Delete\+Animator@{create\+Delete\+Animator}}
\index{create\+Delete\+Animator@{create\+Delete\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Delete\+Animator()}{createDeleteAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Delete\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{time\+Ms }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a scene node animator, which deletes the scene node after some time automatically. 


\begin{DoxyParams}{Parameters}
{\em time\+Ms} & Time in milliseconds, after when the node will be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}\label{classirr_1_1scene_1_1ISceneManager_a163cc04ff2cb03852ac891de56200fa3}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Delete\+Animator@{create\+Delete\+Animator}}
\index{create\+Delete\+Animator@{create\+Delete\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Delete\+Animator()}{createDeleteAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Delete\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{time\+Ms }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a scene node animator, which deletes the scene node after some time automatically. 


\begin{DoxyParams}{Parameters}
{\em time\+Ms} & Time in milliseconds, after when the node will be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}\label{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Fly\+Circle\+Animator@{create\+Fly\+Circle\+Animator}}
\index{create\+Fly\+Circle\+Animator@{create\+Fly\+Circle\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Fly\+Circle\+Animator()}{createFlyCircleAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Fly\+Circle\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{center = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f,~0.f,~0.f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 100.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{speed = {\ttfamily 0.001f},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{direction = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f,~1.f,~0.f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{start\+Position = {\ttfamily 0.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius\+Ellipsoid = {\ttfamily 0.f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a fly circle animator, which lets the attached scene node fly around a center. 


\begin{DoxyParams}{Parameters}
{\em center} & Center of the circle. \\
\hline
{\em radius} & Radius of the circle. \\
\hline
{\em speed} & The orbital speed, in radians per millisecond. \\
\hline
{\em direction} & Specifies the upvector used for alignment of the mesh. \\
\hline
{\em start\+Position} & The position on the circle where the animator will begin. Value is in multiples of a circle, i.\+e. 0.\+5 is half way around. (phase) \\
\hline
{\em radius\+Ellipsoid} & if radius\+Ellipsoid != 0 then radius2 froms a ellipsoid begin. Value is in multiples of a circle, i.\+e. 0.\+5 is half way around. (phase) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}\label{classirr_1_1scene_1_1ISceneManager_a2e49ff49bc9e88e8ecf3d681354e1ab6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Fly\+Circle\+Animator@{create\+Fly\+Circle\+Animator}}
\index{create\+Fly\+Circle\+Animator@{create\+Fly\+Circle\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Fly\+Circle\+Animator()}{createFlyCircleAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Fly\+Circle\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{center = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f,~0.f,~0.f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius = {\ttfamily 100.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{speed = {\ttfamily 0.001f},  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{direction = {\ttfamily \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df}(0.f,~1.f,~0.f)},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{start\+Position = {\ttfamily 0.f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{radius\+Ellipsoid = {\ttfamily 0.f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a fly circle animator, which lets the attached scene node fly around a center. 


\begin{DoxyParams}{Parameters}
{\em center} & Center of the circle. \\
\hline
{\em radius} & Radius of the circle. \\
\hline
{\em speed} & The orbital speed, in radians per millisecond. \\
\hline
{\em direction} & Specifies the upvector used for alignment of the mesh. \\
\hline
{\em start\+Position} & The position on the circle where the animator will begin. Value is in multiples of a circle, i.\+e. 0.\+5 is half way around. (phase) \\
\hline
{\em radius\+Ellipsoid} & if radius\+Ellipsoid != 0 then radius2 froms a ellipsoid begin. Value is in multiples of a circle, i.\+e. 0.\+5 is half way around. (phase) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}\label{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Fly\+Straight\+Animator@{create\+Fly\+Straight\+Animator}}
\index{create\+Fly\+Straight\+Animator@{create\+Fly\+Straight\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Fly\+Straight\+Animator()}{createFlyStraightAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Fly\+Straight\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{start\+Point,  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{end\+Point,  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{time\+For\+Way,  }\item[{bool}]{loop = {\ttfamily false},  }\item[{bool}]{pingpong = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. 


\begin{DoxyParams}{Parameters}
{\em start\+Point} & Start point of the line. \\
\hline
{\em end\+Point} & End point of the line. \\
\hline
{\em time\+For\+Way} & Time in milli seconds how long the node should need to move from the start point to the end point. \\
\hline
{\em loop} & If set to false, the node stops when the end point is reached. If loop is true, the node begins again at the start. \\
\hline
{\em pingpong} & Flag to set whether the animator should fly back from end to start again. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}\label{classirr_1_1scene_1_1ISceneManager_a865c2da86486dcdb44847d5baa7aaa61}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Fly\+Straight\+Animator@{create\+Fly\+Straight\+Animator}}
\index{create\+Fly\+Straight\+Animator@{create\+Fly\+Straight\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Fly\+Straight\+Animator()}{createFlyStraightAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Fly\+Straight\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{start\+Point,  }\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{end\+Point,  }\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{time\+For\+Way,  }\item[{bool}]{loop = {\ttfamily false},  }\item[{bool}]{pingpong = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. 


\begin{DoxyParams}{Parameters}
{\em start\+Point} & Start point of the line. \\
\hline
{\em end\+Point} & End point of the line. \\
\hline
{\em time\+For\+Way} & Time in milli seconds how long the node should need to move from the start point to the end point. \\
\hline
{\em loop} & If set to false, the node stops when the end point is reached. If loop is true, the node begins again at the start. \\
\hline
{\em pingpong} & Flag to set whether the animator should fly back from end to start again. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}\label{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Follow\+Spline\+Animator@{create\+Follow\+Spline\+Animator}}
\index{create\+Follow\+Spline\+Animator@{create\+Follow\+Spline\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Follow\+Spline\+Animator()}{createFollowSplineAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Follow\+Spline\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{start\+Time,  }\item[{const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} $>$ \&}]{points,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{speed = {\ttfamily 1.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{tightness = {\ttfamily 0.5f},  }\item[{bool}]{loop = {\ttfamily true},  }\item[{bool}]{pingpong = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a follow spline animator. 

The animator modifies the position of the attached scene node to make it follow a hermite spline. It uses a subset of hermite splines\+: either cardinal splines (tightness != 0.\+5) or catmull-\/rom-\/splines (tightness == 0.\+5). The animator moves from one control point to the next in 1/speed seconds. This code was sent in by Matthias Gall. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}\label{classirr_1_1scene_1_1ISceneManager_ab0c9d4ab88bbe2ad71623b1054a0c3ba}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Follow\+Spline\+Animator@{create\+Follow\+Spline\+Animator}}
\index{create\+Follow\+Spline\+Animator@{create\+Follow\+Spline\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Follow\+Spline\+Animator()}{createFollowSplineAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Follow\+Spline\+Animator (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{start\+Time,  }\item[{const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} $>$ \&}]{points,  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{speed = {\ttfamily 1.0f},  }\item[{\hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32}}]{tightness = {\ttfamily 0.5f},  }\item[{bool}]{loop = {\ttfamily true},  }\item[{bool}]{pingpong = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a follow spline animator. 

The animator modifies the position of the attached scene node to make it follow a hermite spline. It uses a subset of hermite splines\+: either cardinal splines (tightness != 0.\+5) or catmull-\/rom-\/splines (tightness == 0.\+5). The animator moves from one control point to the next in 1/speed seconds. This code was sent in by Matthias Gall. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}\label{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Mesh\+Writer@{create\+Mesh\+Writer}}
\index{create\+Mesh\+Writer@{create\+Mesh\+Writer}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Mesh\+Writer()}{createMeshWriter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshWriter}{I\+Mesh\+Writer}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Mesh\+Writer (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_a431fa15741518ba15f6d5f2608b6cb4e}{E\+M\+E\+S\+H\+\_\+\+W\+R\+I\+T\+E\+R\+\_\+\+T\+Y\+PE}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a mesh writer implementation if available. 

Note\+: You need to \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{drop()} the pointer after use again, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}\label{classirr_1_1scene_1_1ISceneManager_ae9a06fb68757381f99cfe11ecbd153e6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Mesh\+Writer@{create\+Mesh\+Writer}}
\index{create\+Mesh\+Writer@{create\+Mesh\+Writer}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Mesh\+Writer()}{createMeshWriter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshWriter}{I\+Mesh\+Writer}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Mesh\+Writer (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_a431fa15741518ba15f6d5f2608b6cb4e}{E\+M\+E\+S\+H\+\_\+\+W\+R\+I\+T\+E\+R\+\_\+\+T\+Y\+PE}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a mesh writer implementation if available. 

Note\+: You need to \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{drop()} the pointer after use again, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}\label{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Meta\+Triangle\+Selector@{create\+Meta\+Triangle\+Selector}}
\index{create\+Meta\+Triangle\+Selector@{create\+Meta\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Meta\+Triangle\+Selector()}{createMetaTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMetaTriangleSelector}{I\+Meta\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Meta\+Triangle\+Selector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a meta triangle selector. 

A meta triangle selector is nothing more than a collection of one or more triangle selectors providing together the interface of one triangle selector. In this way, collision tests can be done with different triangle soups in one pass. \begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}\label{classirr_1_1scene_1_1ISceneManager_aee99e59dc55fe9f8c3507df68f84a9ff}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Meta\+Triangle\+Selector@{create\+Meta\+Triangle\+Selector}}
\index{create\+Meta\+Triangle\+Selector@{create\+Meta\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Meta\+Triangle\+Selector()}{createMetaTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMetaTriangleSelector}{I\+Meta\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Meta\+Triangle\+Selector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a meta triangle selector. 

A meta triangle selector is nothing more than a collection of one or more triangle selectors providing together the interface of one triangle selector. In this way, collision tests can be done with different triangle soups in one pass. \begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}\label{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+New\+Scene\+Manager@{create\+New\+Scene\+Manager}}
\index{create\+New\+Scene\+Manager@{create\+New\+Scene\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+New\+Scene\+Manager()}{createNewSceneManager()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneManager}{I\+Scene\+Manager}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+New\+Scene\+Manager (\begin{DoxyParamCaption}\item[{bool}]{clone\+Content = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a new scene manager. 

This can be used to easily draw and/or store two independent scenes at the same time. The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{get\+Mesh()}, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via \hyperlink{classirr_1_1IrrlichtDevice_a891b503ff4d5041296d88f23f97d7b3d}{Irrlicht\+Device\+::get\+Scene\+Manager()}. If you need input event in this new scene manager, for example for F\+PS cameras, you\textquotesingle{}ll need to forward input to this manually\+: Just implement an \hyperlink{classirr_1_1IEventReceiver}{I\+Event\+Receiver} and call your\+New\+Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}{post\+Event\+From\+User()}, and return true so that the original scene manager doesn\textquotesingle{}t get the event. Otherwise, all input will go to the main scene manager automatically. If you no longer need the new scene manager, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Manager\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}\label{classirr_1_1scene_1_1ISceneManager_a94805dd4eca41ccef9607aefe669aed9}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+New\+Scene\+Manager@{create\+New\+Scene\+Manager}}
\index{create\+New\+Scene\+Manager@{create\+New\+Scene\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+New\+Scene\+Manager()}{createNewSceneManager()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneManager}{I\+Scene\+Manager}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+New\+Scene\+Manager (\begin{DoxyParamCaption}\item[{bool}]{clone\+Content = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a new scene manager. 

This can be used to easily draw and/or store two independent scenes at the same time. The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{get\+Mesh()}, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via \hyperlink{classirr_1_1IrrlichtDevice_a891b503ff4d5041296d88f23f97d7b3d}{Irrlicht\+Device\+::get\+Scene\+Manager()}. If you need input event in this new scene manager, for example for F\+PS cameras, you\textquotesingle{}ll need to forward input to this manually\+: Just implement an \hyperlink{classirr_1_1IEventReceiver}{I\+Event\+Receiver} and call your\+New\+Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}{post\+Event\+From\+User()}, and return true so that the original scene manager doesn\textquotesingle{}t get the event. Otherwise, all input will go to the main scene manager automatically. If you no longer need the new scene manager, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Manager\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}\label{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Octree\+Triangle\+Selector@{create\+Octree\+Triangle\+Selector}}
\index{create\+Octree\+Triangle\+Selector@{create\+Octree\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Octree\+Triangle\+Selector()}{createOctreeTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Octree\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 32} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a Triangle Selector, optimized by an octree. 

Triangle selectors can be used for doing collision detection. This triangle selector is optimized for huge amounts of triangle, it organizes them in an octree. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \hyperlink{classirr_1_1scene_1_1ISceneNode_a87fb52ec54bf3ae117340d8defd1255f}{I\+Scene\+Node\+::set\+Triangle\+Selector()} for this. To create and attach a triangle selector is done like this\+: 
\begin{DoxyCode}
ITriangleSelector* s = sceneManager->createOctreeTriangleSelector(yourMesh,
        yourSceneNode);
yourSceneNode->setTriangleSelector(s);
s->drop();
\end{DoxyCode}
 For more informations and examples on this, take a look at the collision tutorial in the S\+DK. 
\begin{DoxyParams}{Parameters}
{\em mesh} & Mesh of which the triangles are taken. \\
\hline
{\em node} & Scene node of which visibility and transformation is used. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}\label{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Octree\+Triangle\+Selector@{create\+Octree\+Triangle\+Selector}}
\index{create\+Octree\+Triangle\+Selector@{create\+Octree\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Octree\+Triangle\+Selector()}{createOctreeTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Octree\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 32} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a Triangle Selector, optimized by an octree. 

Triangle selectors can be used for doing collision detection. This triangle selector is optimized for huge amounts of triangle, it organizes them in an octree. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \hyperlink{classirr_1_1scene_1_1ISceneNode_a87fb52ec54bf3ae117340d8defd1255f}{I\+Scene\+Node\+::set\+Triangle\+Selector()} for this. To create and attach a triangle selector is done like this\+: 
\begin{DoxyCode}
ITriangleSelector* s = sceneManager->createOctreeTriangleSelector(yourMesh,
        yourSceneNode);
yourSceneNode->setTriangleSelector(s);
s->drop();
\end{DoxyCode}
 For more informations and examples on this, take a look at the collision tutorial in the S\+DK. 
\begin{DoxyParams}{Parameters}
{\em mesh} & Mesh of which the triangles are taken. \\
\hline
{\em node} & Scene node of which visibility and transformation is used. \\
\hline
{\em minimal\+Polys\+Per\+Node} & Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}\label{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Oct\+Tree\+Triangle\+Selector@{create\+Oct\+Tree\+Triangle\+Selector}}
\index{create\+Oct\+Tree\+Triangle\+Selector@{create\+Oct\+Tree\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Oct\+Tree\+Triangle\+Selector()}{createOctTreeTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Oct\+Tree\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 32} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



//! Creates a Triangle Selector, optimized by an octree. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000020}{Deprecated}]Use create\+Octree\+Triangle\+Selector instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}\label{classirr_1_1scene_1_1ISceneManager_a67f20d1a535645048f2f7e2b5c670656}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Oct\+Tree\+Triangle\+Selector@{create\+Oct\+Tree\+Triangle\+Selector}}
\index{create\+Oct\+Tree\+Triangle\+Selector@{create\+Oct\+Tree\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Oct\+Tree\+Triangle\+Selector()}{createOctTreeTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Oct\+Tree\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{minimal\+Polys\+Per\+Node = {\ttfamily 32} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



//! Creates a Triangle Selector, optimized by an octree. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000046}{Deprecated}]Use create\+Octree\+Triangle\+Selector instead. This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}\label{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Rotation\+Animator@{create\+Rotation\+Animator}}
\index{create\+Rotation\+Animator@{create\+Rotation\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Rotation\+Animator()}{createRotationAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Rotation\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation\+Speed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a rotation animator, which rotates the attached scene node around itself. 


\begin{DoxyParams}{Parameters}
{\em rotation\+Speed} & Specifies the speed of the animation in degree per 10 milliseconds. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}\label{classirr_1_1scene_1_1ISceneManager_a29efe9505de4e5dc2218283ef0c2a64d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Rotation\+Animator@{create\+Rotation\+Animator}}
\index{create\+Rotation\+Animator@{create\+Rotation\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Rotation\+Animator()}{createRotationAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Rotation\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1core_ae6e2b2a6c552833ebbd5b7463d03586b}{core\+::vector3df} \&}]{rotation\+Speed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a rotation animator, which rotates the attached scene node around itself. 


\begin{DoxyParams}{Parameters}
{\em rotation\+Speed} & Specifies the speed of the animation in degree per 10 milliseconds. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}\label{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Scene\+Node\+Animator@{create\+Scene\+Node\+Animator}}
\index{create\+Scene\+Node\+Animator@{create\+Scene\+Node\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Scene\+Node\+Animator()}{createSceneNodeAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Scene\+Node\+Animator (\begin{DoxyParamCaption}\item[{const char $\ast$}]{type\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{target = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



creates a scene node animator based on its type name 


\begin{DoxyParams}{Parameters}
{\em type\+Name} & Type of the scene node animator to add. \\
\hline
{\em target} & Target scene node of the new animator. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns pointer to the new scene node animator or null if not successful. You need to drop this pointer after calling this, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}\label{classirr_1_1scene_1_1ISceneManager_ac63c38a05b8e7d0a11ddb1752da36835}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Scene\+Node\+Animator@{create\+Scene\+Node\+Animator}}
\index{create\+Scene\+Node\+Animator@{create\+Scene\+Node\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Scene\+Node\+Animator()}{createSceneNodeAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Scene\+Node\+Animator (\begin{DoxyParamCaption}\item[{const char $\ast$}]{type\+Name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{target = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



creates a scene node animator based on its type name 


\begin{DoxyParams}{Parameters}
{\em type\+Name} & Type of the scene node animator to add. \\
\hline
{\em target} & Target scene node of the new animator. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns pointer to the new scene node animator or null if not successful. You need to drop this pointer after calling this, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}\label{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Skinned\+Mesh@{create\+Skinned\+Mesh}}
\index{create\+Skinned\+Mesh@{create\+Skinned\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Skinned\+Mesh()}{createSkinnedMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Skinned\+Mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a skinned mesh, which is not available as header-\/only code. 

Note\+: You need to \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{drop()} the pointer after use again, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}\label{classirr_1_1scene_1_1ISceneManager_a67015b46ffde252ba723e6dcc6a93ac2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Skinned\+Mesh@{create\+Skinned\+Mesh}}
\index{create\+Skinned\+Mesh@{create\+Skinned\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Skinned\+Mesh()}{createSkinnedMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Skinned\+Mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a skinned mesh, which is not available as header-\/only code. 

Note\+: You need to \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{drop()} the pointer after use again, see \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for details. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}\label{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Terrain\+Triangle\+Selector@{create\+Terrain\+Triangle\+Selector}}
\index{create\+Terrain\+Triangle\+Selector@{create\+Terrain\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Terrain\+Triangle\+Selector()}{createTerrainTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Terrain\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{L\+OD = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a triangle selector which can select triangles from a terrain scene node. 


\begin{DoxyParams}{Parameters}
{\em node} & Pointer to the created terrain scene node \\
\hline
{\em L\+OD} & \hyperlink{classLevel}{Level} of detail, 0 for highest detail. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}\label{classirr_1_1scene_1_1ISceneManager_af52f8c74e08637b7643d239542371bc5}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Terrain\+Triangle\+Selector@{create\+Terrain\+Triangle\+Selector}}
\index{create\+Terrain\+Triangle\+Selector@{create\+Terrain\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Terrain\+Triangle\+Selector()}{createTerrainTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Terrain\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ITerrainSceneNode}{I\+Terrain\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{L\+OD = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a triangle selector which can select triangles from a terrain scene node. 


\begin{DoxyParams}{Parameters}
{\em node} & Pointer to the created terrain scene node \\
\hline
{\em L\+OD} & \hyperlink{classLevel}{Level} of detail, 0 for highest detail. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}\label{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Texture\+Animator@{create\+Texture\+Animator}}
\index{create\+Texture\+Animator@{create\+Texture\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Texture\+Animator()}{createTextureAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Texture\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$$>$ \&}]{textures,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{time\+Per\+Frame,  }\item[{bool}]{loop = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a texture animator, which switches the textures of the target scene node based on a list of textures. 


\begin{DoxyParams}{Parameters}
{\em textures} & List of textures to use. \\
\hline
{\em time\+Per\+Frame} & Time in milliseconds, how long any texture in the list should be visible. \\
\hline
{\em loop} & If set to to false, the last texture remains set, and the animation stops. If set to true, the animation restarts with the first texture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}\label{classirr_1_1scene_1_1ISceneManager_af50f3bdcefe2e7df979b86e297498c29}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Texture\+Animator@{create\+Texture\+Animator}}
\index{create\+Texture\+Animator@{create\+Texture\+Animator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Texture\+Animator()}{createTextureAnimator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimator}{I\+Scene\+Node\+Animator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Texture\+Animator (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$$>$ \&}]{textures,  }\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{time\+Per\+Frame,  }\item[{bool}]{loop = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a texture animator, which switches the textures of the target scene node based on a list of textures. 


\begin{DoxyParams}{Parameters}
{\em textures} & List of textures to use. \\
\hline
{\em time\+Per\+Frame} & Time in milliseconds, how long any texture in the list should be visible. \\
\hline
{\em loop} & If set to to false, the last texture remains set, and the animation stops. If set to true, the animation restarts with the first texture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The animator. Attach it to a scene node with \hyperlink{classirr_1_1scene_1_1ISceneNode_a0e5cd342cd7293c136e53e2c2c5e0f3a}{I\+Scene\+Node\+::add\+Animator()} and the animator will animate it. If you no longer need the animator, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Scene\+Node\+Animator\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}\label{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector@{create\+Triangle\+Selector}}
\index{create\+Triangle\+Selector@{create\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector()}{createTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a mesh. 

Triangle selectors can be used for doing collision detection. Don\textquotesingle{}t use this selector for a huge amount of triangles like in Quake3 maps. Instead, use for example \hyperlink{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}{I\+Scene\+Manager\+::create\+Octree\+Triangle\+Selector()}. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \hyperlink{classirr_1_1scene_1_1ISceneNode_a87fb52ec54bf3ae117340d8defd1255f}{I\+Scene\+Node\+::set\+Triangle\+Selector()} for this. To create and attach a triangle selector is done like this\+: 
\begin{DoxyCode}
ITriangleSelector* s = sceneManager->createTriangleSelector(yourMesh,
        yourSceneNode);
yourSceneNode->setTriangleSelector(s);
s->drop();
\end{DoxyCode}
 
\begin{DoxyParams}{Parameters}
{\em mesh} & Mesh of which the triangles are taken. \\
\hline
{\em node} & Scene node of which visibility and transformation is used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}\label{classirr_1_1scene_1_1ISceneManager_a266625379b1558e9be1dc062ea4e71f7}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector@{create\+Triangle\+Selector}}
\index{create\+Triangle\+Selector@{create\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector()}{createTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IMesh}{I\+Mesh} $\ast$}]{mesh,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a mesh. 

Triangle selectors can be used for doing collision detection. Don\textquotesingle{}t use this selector for a huge amount of triangles like in Quake3 maps. Instead, use for example \hyperlink{classirr_1_1scene_1_1ISceneManager_a4ed7d3b34f4d0c70395b6d464fe32b96}{I\+Scene\+Manager\+::create\+Octree\+Triangle\+Selector()}. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call \hyperlink{classirr_1_1scene_1_1ISceneNode_a87fb52ec54bf3ae117340d8defd1255f}{I\+Scene\+Node\+::set\+Triangle\+Selector()} for this. To create and attach a triangle selector is done like this\+: 
\begin{DoxyCode}
ITriangleSelector* s = sceneManager->createTriangleSelector(yourMesh,
        yourSceneNode);
yourSceneNode->setTriangleSelector(s);
s->drop();
\end{DoxyCode}
 
\begin{DoxyParams}{Parameters}
{\em mesh} & Mesh of which the triangles are taken. \\
\hline
{\em node} & Scene node of which visibility and transformation is used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}\label{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector@{create\+Triangle\+Selector}}
\index{create\+Triangle\+Selector@{create\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector()}{createTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on an animated mesh scene node. 

Details of the mesh associated with the node will be extracted internally. Call I\+Triangle\+Selector\+::update() to have the triangle selector updated based on the current frame of the animated mesh scene node. 
\begin{DoxyParams}{Parameters}
{\em node} & The animated mesh scene node from which to build the selector \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}\label{classirr_1_1scene_1_1ISceneManager_abc1ecc9a60abb40e7ffddbd72c077231}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector@{create\+Triangle\+Selector}}
\index{create\+Triangle\+Selector@{create\+Triangle\+Selector}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector()}{createTriangleSelector()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1IAnimatedMeshSceneNode}{I\+Animated\+Mesh\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on an animated mesh scene node. 

Details of the mesh associated with the node will be extracted internally. Call I\+Triangle\+Selector\+::update() to have the triangle selector updated based on the current frame of the animated mesh scene node. 
\begin{DoxyParams}{Parameters}
{\em node} & The animated mesh scene node from which to build the selector \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}\label{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector\+From\+Bounding\+Box@{create\+Triangle\+Selector\+From\+Bounding\+Box}}
\index{create\+Triangle\+Selector\+From\+Bounding\+Box@{create\+Triangle\+Selector\+From\+Bounding\+Box}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector\+From\+Bounding\+Box()}{createTriangleSelectorFromBoundingBox()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector\+From\+Bounding\+Box (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple dynamic \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a axis aligned bounding box. 

Triangle selectors can be used for doing collision detection. Every time when triangles are queried, the triangle selector gets the bounding box of the scene node, an creates new triangles. In this way, it works good with animated scene nodes. 
\begin{DoxyParams}{Parameters}
{\em node} & Scene node of which the bounding box, visibility and transformation is used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}\label{classirr_1_1scene_1_1ISceneManager_adb717113b4203e92f2bd95c84488059c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!create\+Triangle\+Selector\+From\+Bounding\+Box@{create\+Triangle\+Selector\+From\+Bounding\+Box}}
\index{create\+Triangle\+Selector\+From\+Bounding\+Box@{create\+Triangle\+Selector\+From\+Bounding\+Box}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{create\+Triangle\+Selector\+From\+Bounding\+Box()}{createTriangleSelectorFromBoundingBox()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::create\+Triangle\+Selector\+From\+Bounding\+Box (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates a simple dynamic \hyperlink{classirr_1_1scene_1_1ITriangleSelector}{I\+Triangle\+Selector}, based on a axis aligned bounding box. 

Triangle selectors can be used for doing collision detection. Every time when triangles are queried, the triangle selector gets the bounding box of the scene node, an creates new triangles. In this way, it works good with animated scene nodes. 
\begin{DoxyParams}{Parameters}
{\em node} & Scene node of which the bounding box, visibility and transformation is used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The selector, or null if not successful. If you no longer need the selector, you should call \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Triangle\+Selector\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}\label{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!draw\+All@{draw\+All}}
\index{draw\+All@{draw\+All}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{draw\+All()}{drawAll()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::draw\+All (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Draws all the scene nodes. 

This can only be invoked between I\+Video\+Driver\+::begin\+Scene() and I\+Video\+Driver\+::end\+Scene(). Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}\label{classirr_1_1scene_1_1ISceneManager_a04240262904667c821bd9de5e5fd9b02}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!draw\+All@{draw\+All}}
\index{draw\+All@{draw\+All}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{draw\+All()}{drawAll()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::draw\+All (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Draws all the scene nodes. 

This can only be invoked between I\+Video\+Driver\+::begin\+Scene() and I\+Video\+Driver\+::end\+Scene(). Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}\label{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Active\+Camera@{get\+Active\+Camera}}
\index{get\+Active\+Camera@{get\+Active\+Camera}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Active\+Camera()}{getActiveCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Active\+Camera (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the current active camera. 

\begin{DoxyReturn}{Returns}
The active camera is returned. Note that this can be N\+U\+LL, if there was no camera created yet. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}\label{classirr_1_1scene_1_1ISceneManager_a71391ee37dece0714d95c519f110010f}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Active\+Camera@{get\+Active\+Camera}}
\index{get\+Active\+Camera@{get\+Active\+Camera}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Active\+Camera()}{getActiveCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Active\+Camera (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the current active camera. 

\begin{DoxyReturn}{Returns}
The active camera is returned. Note that this can be N\+U\+LL, if there was no camera created yet. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}\label{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Default\+Scene\+Node\+Animator\+Factory@{get\+Default\+Scene\+Node\+Animator\+Factory}}
\index{get\+Default\+Scene\+Node\+Animator\+Factory@{get\+Default\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Default\+Scene\+Node\+Animator\+Factory()}{getDefaultSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Default\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the default scene node animator factory which can create all built-\/in scene node animators. 

\begin{DoxyReturn}{Returns}
Pointer to the default scene node animator factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}\label{classirr_1_1scene_1_1ISceneManager_adeb3d24c8ffafd5e671f344931a0b3a5}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Default\+Scene\+Node\+Animator\+Factory@{get\+Default\+Scene\+Node\+Animator\+Factory}}
\index{get\+Default\+Scene\+Node\+Animator\+Factory@{get\+Default\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Default\+Scene\+Node\+Animator\+Factory()}{getDefaultSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Default\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the default scene node animator factory which can create all built-\/in scene node animators. 

\begin{DoxyReturn}{Returns}
Pointer to the default scene node animator factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}\label{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Default\+Scene\+Node\+Factory@{get\+Default\+Scene\+Node\+Factory}}
\index{get\+Default\+Scene\+Node\+Factory@{get\+Default\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Default\+Scene\+Node\+Factory()}{getDefaultSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Default\+Scene\+Node\+Factory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the default scene node factory which can create all built in scene nodes. 

\begin{DoxyReturn}{Returns}
Pointer to the default scene node factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}\label{classirr_1_1scene_1_1ISceneManager_a1ea0ec7ec95a97819f1de5222b97e774}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Default\+Scene\+Node\+Factory@{get\+Default\+Scene\+Node\+Factory}}
\index{get\+Default\+Scene\+Node\+Factory@{get\+Default\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Default\+Scene\+Node\+Factory()}{getDefaultSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Default\+Scene\+Node\+Factory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the default scene node factory which can create all built in scene nodes. 

\begin{DoxyReturn}{Returns}
Pointer to the default scene node factory This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}\label{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+File\+System@{get\+File\+System}}
\index{get\+File\+System@{get\+File\+System}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+File\+System()}{getFileSystem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1io_1_1IFileSystem}{io\+::\+I\+File\+System}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+File\+System (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the active File\+System. 

\begin{DoxyReturn}{Returns}
Pointer to the File\+System This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}\label{classirr_1_1scene_1_1ISceneManager_adbd98fbeba199005cf795a5bae7ccbaf}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+File\+System@{get\+File\+System}}
\index{get\+File\+System@{get\+File\+System}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+File\+System()}{getFileSystem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1io_1_1IFileSystem}{io\+::\+I\+File\+System}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+File\+System (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the active File\+System. 

\begin{DoxyReturn}{Returns}
Pointer to the File\+System This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}\label{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Geometry\+Creator@{get\+Geometry\+Creator}}
\index{get\+Geometry\+Creator@{get\+Geometry\+Creator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Geometry\+Creator()}{getGeometryCreator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual const \hyperlink{classirr_1_1scene_1_1IGeometryCreator}{I\+Geometry\+Creator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Geometry\+Creator (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get an instance of a geometry creator. 

The geometry creator provides some helper methods to create various types of basic geometry. This can be useful for custom scene nodes. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}\label{classirr_1_1scene_1_1ISceneManager_a9840cfd39b44f238d06b7bc51e6ba1f6}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Geometry\+Creator@{get\+Geometry\+Creator}}
\index{get\+Geometry\+Creator@{get\+Geometry\+Creator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Geometry\+Creator()}{getGeometryCreator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual const \hyperlink{classirr_1_1scene_1_1IGeometryCreator}{I\+Geometry\+Creator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Geometry\+Creator (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get an instance of a geometry creator. 

The geometry creator provides some helper methods to create various types of basic geometry. This can be useful for custom scene nodes. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}\label{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+G\+U\+I\+Environment@{get\+G\+U\+I\+Environment}}
\index{get\+G\+U\+I\+Environment@{get\+G\+U\+I\+Environment}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+G\+U\+I\+Environment()}{getGUIEnvironment()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1gui_1_1IGUIEnvironment}{gui\+::\+I\+G\+U\+I\+Environment}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+G\+U\+I\+Environment (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the active G\+U\+I\+Environment. 

\begin{DoxyReturn}{Returns}
Pointer to the G\+U\+I\+Environment This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}\label{classirr_1_1scene_1_1ISceneManager_ad887536e9cc41d0670364f9f0a0f4510}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+G\+U\+I\+Environment@{get\+G\+U\+I\+Environment}}
\index{get\+G\+U\+I\+Environment@{get\+G\+U\+I\+Environment}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+G\+U\+I\+Environment()}{getGUIEnvironment()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1gui_1_1IGUIEnvironment}{gui\+::\+I\+G\+U\+I\+Environment}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+G\+U\+I\+Environment (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the active G\+U\+I\+Environment. 

\begin{DoxyReturn}{Returns}
Pointer to the G\+U\+I\+Environment This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}\label{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh@{get\+Mesh}}
\index{get\+Mesh@{get\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh()}{getMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to an animateable mesh. Loads the file if not loaded already. 

If you want to remove a loaded mesh from the cache again, use remove\+Mesh(). Currently there are the following mesh formats supported\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
Format &Description  \\\cline{1-2}
3D Studio (.3ds) &Loader for 3\+D-\/\+Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.  \\\cline{1-2}
3D World Studio (.smf) &Loader for Leadwerks S\+MF mesh files, a simple mesh format containing static geometry for games. The proprietary .S\+TF texture format is not supported yet. This loader was originally written by Joseph Ellis.   \\\cline{1-2}
Bliz Basic B3D (.b3d) &Loader for blitz basic files, developed by Mark Sibly. This is the ideal animated mesh format for game characters as it is both rigidly defined and widely supported by modeling and animation software. As this format supports skeletal animations, an \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} will be returned by this importer.  \\\cline{1-2}
Cartography shop 4 (.csm) &Cartography Shop is a modeling program for creating architecture and calculating lighting. Irrlicht can directly import .csm files thanks to the Irr\+C\+SM library created by Saurav Mohapatra which is now integrated directly in Irrlicht. If you are using this loader, please note that you\textquotesingle{}ll have to set the path of the textures before loading .csm files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_a72a3b82394847d221a79863b2d0f3cae}{scene\+::\+C\+S\+M\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures");  \\\cline{1-2}
C\+O\+L\+L\+A\+DA (.dae, .xml) &C\+O\+L\+L\+A\+DA is an open Digital Asset Exchange Schema for the interactive 3D industry. There are exporters and importers for this format available for most of the big 3d packagesat \href{http://collada.org}{\tt http\+://collada.\+org}. Irrlicht can import C\+O\+L\+L\+A\+DA files by using the \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} method. C\+O\+L\+L\+A\+DA files need not contain only one single mesh but multiple meshes and a whole scene setup with lights, cameras and mesh instances, this loader can set up a scene as described by the C\+O\+L\+L\+A\+DA file instead of loading and returning one single mesh. By default, this loader behaves like the other loaders and does not create instances, but it can be switched into this mode by using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\+C\+O\+L\+L\+A\+D\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+I\+N\+S\+T\+A\+N\+C\+E\+S, true); Created scene nodes will be named as the names of the nodes in the C\+O\+L\+L\+A\+DA file. The returned mesh is just a dummy object in this mode. Meshes included in the scene will be added into the scene manager with the following naming scheme\+: \char`\"{}path/to/file/file.\+dea\#meshname\char`\"{}. The loading of such meshes is logged. Currently, this loader is able to

\begin{DoxyVerb}   create meshes (made of only polygons), lights, and
   cameras. Materials and animations are currently not
   supported but this will change with future releases.
\end{DoxyVerb}
   \\\cline{1-2}
Delgine DeleD (.dmf) &DeleD (delgine.\+com) is a 3D editor and level-\/editor combined into one and is specifically designed for 3D game-\/development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see scene\+::\+D\+M\+F\+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+S\+\_\+\+D\+I\+RS and \hyperlink{namespaceirr_1_1scene_a0dc81c29a0fa37b3aa7c9dcfc9828eaa}{scene\+::\+D\+M\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}. It is also possible to flip the alpha texture by setting \hyperlink{namespaceirr_1_1scene_ae28846d2b02cbfc70c6771919a3b5edd}{scene\+::\+D\+M\+F\+\_\+\+F\+L\+I\+P\+\_\+\+A\+L\+P\+H\+A\+\_\+\+T\+E\+X\+T\+U\+R\+ES} to true and to set the material transparent reference value by setting \hyperlink{namespaceirr_1_1scene_a21e42b7847ca0eed258b80aac458b7dd}{scene\+::\+D\+M\+F\+\_\+\+A\+L\+P\+H\+A\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+R\+EF} to a float between 0 and
\begin{DoxyEnumerate}
\item The loader is based on Salvatore Russo\textquotesingle{}s .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in Irrlicht and put it under Irrlicht\textquotesingle{}s license. For newer and more enchanced versions of the loader, take a look at delgine.\+com.   
\end{DoxyEnumerate}\\\cline{1-2}
DirectX (.x) &Platform independent importer (so not D3\+D-\/only) for .x files. Most 3D packages can export these natively and there are several tools for them available, e.\+g. the Maya exporter included in the DX S\+DK. .x files can include skeletal animations and Irrlicht is able to play and display them, users can manipulate the joints via the \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} interface. Currently, Irrlicht only supports uncompressed .x files.  \\\cline{1-2}
Half-\/\+Life model (.mdl) &This loader opens Half-\/life 1 models, it was contributed by Fabio Concas and adapted by Thomas Alten.  \\\cline{1-2}
Irrlicht Mesh (.irr\+Mesh) &This is a static mesh format written in X\+ML, native to Irrlicht and written by the irr mesh writer. This format is exported by the Copper\+Cube engine\textquotesingle{}s lightmapper.  \\\cline{1-2}
Light\+Wave (.lwo) &Native to New\+Tek\textquotesingle{}s Light\+Wave 3D, the L\+WO format is well known and supported by many exporters. This loader will import L\+W\+O2 models including lightmaps, bumpmaps and reflection textures.  \\\cline{1-2}
Maya (.obj) &Most 3D software can create .obj files which contain static geometry without material data. The material files .mtl are also supported. This importer for Irrlicht can load them directly.   \\\cline{1-2}
Milkshape (.ms3d) &.M\+S3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. Like the other skeletal mesh loaders, oints are exposed via the \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} animated mesh type.  \\\cline{1-2}
My3D (.my3d) &.my3D is a flexible 3D file format. The My3\+D\+Tools contains plug-\/ins to export .my3D files from several 3D packages. With this built-\/in importer, Irrlicht can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3\+D\+Tools package. If you are using this loader, please note that you can set the path of the textures before loading .my3d files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_ad5aaf45c7642044ccb4bb6855446c441}{scene\+::\+M\+Y3\+D\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures");   \\\cline{1-2}
O\+CT (.oct) &The oct file format contains 3D geometry and lightmaps and can be loaded directly by Irrlicht. O\+CT files~\newline
 can be created by F\+S\+Rad, Paul Nette\textquotesingle{}s radiosity processor or exported from Blender using O\+C\+T\+Tools which can be found in the exporters/\+O\+C\+T\+Tools directory of the S\+DK. Thanks to Murphy Mc\+Cauley for creating all this.  \\\cline{1-2}
O\+G\+RE Meshes (.mesh) &Ogre .mesh files contain 3D data for the O\+G\+RE 3D engine. Irrlicht can read and display them directly with this importer. To define materials for the mesh, copy a .material file named like the corresponding .mesh file where the .mesh file is. (For example ogrehead.\+material for ogrehead.\+mesh). Thanks to Christian Stehno who wrote and contributed this loader.  \\\cline{1-2}
Pulsar L\+M\+Tools (.lmts) &L\+M\+Tools is a set of tools (Windows \& Linux) for creating lightmaps. Irrlicht can directly read .lmts files thanks to~\newline
 the importer created by Jonas Petersen. If you are using this loader, please note that you can set the path of the textures before loading .lmts files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_a706d82611b9c61c9e2a7950dfef3bb1a}{scene\+::\+L\+M\+T\+S\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures"); Notes for~\newline
 this version of the loader\+:~\newline

\begin{DoxyItemize}
\item It does not recognise/support user data in the $\ast$.lmts files.~\newline

\item The T\+G\+As generated by L\+M\+Tools don\textquotesingle{}t work in Irrlicht for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  
\end{DoxyItemize}\\\cline{1-2}
Quake 3 levels (.bsp) &Quake 3 is a popular game by I\+D\+Software, and .pk3 files contain .bsp files and textures/lightmaps describing huge prelighted levels. Irrlicht can read .pk3 and .bsp files directly and thus render Quake 3 levels directly. Written by Nikolaus Gebhardt enhanced by Dean P. Macri with the curved surfaces feature.   \\\cline{1-2}
Quake 2 models (.md2) &Quake 2 models are characters with morph target animation. Irrlicht can read, display and animate them directly with this importer.   \\\cline{1-2}
Quake 3 models (.md3) &Quake 3 models are characters with morph target animation, they contain mount points for weapons and body parts and are typically made of several sections which are manually joined together.  \\\cline{1-2}
Stanford Triangle (.ply) &Invented by Stanford University and known as the native format of the infamous \char`\"{}\+Stanford Bunny\char`\"{} model, this is a popular static mesh format used by 3D scanning hardware and software. This loader supports extremely large models in both A\+S\+C\+II and binary format, but only has rudimentary material support in the form of vertex colors and texture coordinates.  \\\cline{1-2}
Stereolithography (.stl) &The S\+TL format is used for rapid prototyping and computer-\/aided manufacturing, thus has no support for materials.  \\\cline{1-2}
\end{longtabu}


To load and display a mesh quickly, just do this\+: 
\begin{DoxyCode}
SceneManager->addAnimatedMeshSceneNode(
   SceneManager->getMesh(\textcolor{stringliteral}{"yourmesh.3ds"}));
\end{DoxyCode}
 If you would like to implement and add your own file format loader to Irrlicht, see \hyperlink{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}{add\+External\+Mesh\+Loader()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Filename of the mesh to load. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null if failed, otherwise pointer to the mesh. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}\label{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh@{get\+Mesh}}
\index{get\+Mesh@{get\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh()}{getMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to an animateable mesh. Loads the file if not loaded already. 

If you want to remove a loaded mesh from the cache again, use remove\+Mesh(). Currently there are the following mesh formats supported\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
Format &Description  \\\cline{1-2}
3D Studio (.3ds) &Loader for 3\+D-\/\+Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.  \\\cline{1-2}
3D World Studio (.smf) &Loader for Leadwerks S\+MF mesh files, a simple mesh format containing static geometry for games. The proprietary .S\+TF texture format is not supported yet. This loader was originally written by Joseph Ellis.   \\\cline{1-2}
Bliz Basic B3D (.b3d) &Loader for blitz basic files, developed by Mark Sibly. This is the ideal animated mesh format for game characters as it is both rigidly defined and widely supported by modeling and animation software. As this format supports skeletal animations, an \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} will be returned by this importer.  \\\cline{1-2}
Cartography shop 4 (.csm) &Cartography Shop is a modeling program for creating architecture and calculating lighting. Irrlicht can directly import .csm files thanks to the Irr\+C\+SM library created by Saurav Mohapatra which is now integrated directly in Irrlicht. If you are using this loader, please note that you\textquotesingle{}ll have to set the path of the textures before loading .csm files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_a72a3b82394847d221a79863b2d0f3cae}{scene\+::\+C\+S\+M\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures");  \\\cline{1-2}
C\+O\+L\+L\+A\+DA (.dae, .xml) &C\+O\+L\+L\+A\+DA is an open Digital Asset Exchange Schema for the interactive 3D industry. There are exporters and importers for this format available for most of the big 3d packagesat \href{http://collada.org}{\tt http\+://collada.\+org}. Irrlicht can import C\+O\+L\+L\+A\+DA files by using the \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} method. C\+O\+L\+L\+A\+DA files need not contain only one single mesh but multiple meshes and a whole scene setup with lights, cameras and mesh instances, this loader can set up a scene as described by the C\+O\+L\+L\+A\+DA file instead of loading and returning one single mesh. By default, this loader behaves like the other loaders and does not create instances, but it can be switched into this mode by using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\+C\+O\+L\+L\+A\+D\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+I\+N\+S\+T\+A\+N\+C\+E\+S, true); Created scene nodes will be named as the names of the nodes in the C\+O\+L\+L\+A\+DA file. The returned mesh is just a dummy object in this mode. Meshes included in the scene will be added into the scene manager with the following naming scheme\+: \char`\"{}path/to/file/file.\+dea\#meshname\char`\"{}. The loading of such meshes is logged. Currently, this loader is able to

\begin{DoxyVerb}   create meshes (made of only polygons), lights, and
   cameras. Materials and animations are currently not
   supported but this will change with future releases.
\end{DoxyVerb}
   \\\cline{1-2}
Delgine DeleD (.dmf) &DeleD (delgine.\+com) is a 3D editor and level-\/editor combined into one and is specifically designed for 3D game-\/development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see scene\+::\+D\+M\+F\+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+S\+\_\+\+D\+I\+RS and \hyperlink{namespaceirr_1_1scene_a0dc81c29a0fa37b3aa7c9dcfc9828eaa}{scene\+::\+D\+M\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}. It is also possible to flip the alpha texture by setting \hyperlink{namespaceirr_1_1scene_ae28846d2b02cbfc70c6771919a3b5edd}{scene\+::\+D\+M\+F\+\_\+\+F\+L\+I\+P\+\_\+\+A\+L\+P\+H\+A\+\_\+\+T\+E\+X\+T\+U\+R\+ES} to true and to set the material transparent reference value by setting \hyperlink{namespaceirr_1_1scene_a21e42b7847ca0eed258b80aac458b7dd}{scene\+::\+D\+M\+F\+\_\+\+A\+L\+P\+H\+A\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+R\+EF} to a float between 0 and
\begin{DoxyEnumerate}
\item The loader is based on Salvatore Russo\textquotesingle{}s .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in Irrlicht and put it under Irrlicht\textquotesingle{}s license. For newer and more enchanced versions of the loader, take a look at delgine.\+com.   
\end{DoxyEnumerate}\\\cline{1-2}
DirectX (.x) &Platform independent importer (so not D3\+D-\/only) for .x files. Most 3D packages can export these natively and there are several tools for them available, e.\+g. the Maya exporter included in the DX S\+DK. .x files can include skeletal animations and Irrlicht is able to play and display them, users can manipulate the joints via the \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} interface. Currently, Irrlicht only supports uncompressed .x files.  \\\cline{1-2}
Half-\/\+Life model (.mdl) &This loader opens Half-\/life 1 models, it was contributed by Fabio Concas and adapted by Thomas Alten.  \\\cline{1-2}
Irrlicht Mesh (.irr\+Mesh) &This is a static mesh format written in X\+ML, native to Irrlicht and written by the irr mesh writer. This format is exported by the Copper\+Cube engine\textquotesingle{}s lightmapper.  \\\cline{1-2}
Light\+Wave (.lwo) &Native to New\+Tek\textquotesingle{}s Light\+Wave 3D, the L\+WO format is well known and supported by many exporters. This loader will import L\+W\+O2 models including lightmaps, bumpmaps and reflection textures.  \\\cline{1-2}
Maya (.obj) &Most 3D software can create .obj files which contain static geometry without material data. The material files .mtl are also supported. This importer for Irrlicht can load them directly.   \\\cline{1-2}
Milkshape (.ms3d) &.M\+S3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. Like the other skeletal mesh loaders, oints are exposed via the \hyperlink{classirr_1_1scene_1_1ISkinnedMesh}{I\+Skinned\+Mesh} animated mesh type.  \\\cline{1-2}
My3D (.my3d) &.my3D is a flexible 3D file format. The My3\+D\+Tools contains plug-\/ins to export .my3D files from several 3D packages. With this built-\/in importer, Irrlicht can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3\+D\+Tools package. If you are using this loader, please note that you can set the path of the textures before loading .my3d files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_ad5aaf45c7642044ccb4bb6855446c441}{scene\+::\+M\+Y3\+D\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures");   \\\cline{1-2}
O\+CT (.oct) &The oct file format contains 3D geometry and lightmaps and can be loaded directly by Irrlicht. O\+CT files~\newline
 can be created by F\+S\+Rad, Paul Nette\textquotesingle{}s radiosity processor or exported from Blender using O\+C\+T\+Tools which can be found in the exporters/\+O\+C\+T\+Tools directory of the S\+DK. Thanks to Murphy Mc\+Cauley for creating all this.  \\\cline{1-2}
O\+G\+RE Meshes (.mesh) &Ogre .mesh files contain 3D data for the O\+G\+RE 3D engine. Irrlicht can read and display them directly with this importer. To define materials for the mesh, copy a .material file named like the corresponding .mesh file where the .mesh file is. (For example ogrehead.\+material for ogrehead.\+mesh). Thanks to Christian Stehno who wrote and contributed this loader.  \\\cline{1-2}
Pulsar L\+M\+Tools (.lmts) &L\+M\+Tools is a set of tools (Windows \& Linux) for creating lightmaps. Irrlicht can directly read .lmts files thanks to~\newline
 the importer created by Jonas Petersen. If you are using this loader, please note that you can set the path of the textures before loading .lmts files. You can do this using Scene\+Manager-\/$>$\hyperlink{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}{get\+Parameters()}-\/$>$set\+Attribute(\hyperlink{namespaceirr_1_1scene_a706d82611b9c61c9e2a7950dfef3bb1a}{scene\+::\+L\+M\+T\+S\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH}, "path/to/your/textures"); Notes for~\newline
 this version of the loader\+:~\newline

\begin{DoxyItemize}
\item It does not recognise/support user data in the $\ast$.lmts files.~\newline

\item The T\+G\+As generated by L\+M\+Tools don\textquotesingle{}t work in Irrlicht for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  
\end{DoxyItemize}\\\cline{1-2}
Quake 3 levels (.bsp) &Quake 3 is a popular game by I\+D\+Software, and .pk3 files contain .bsp files and textures/lightmaps describing huge prelighted levels. Irrlicht can read .pk3 and .bsp files directly and thus render Quake 3 levels directly. Written by Nikolaus Gebhardt enhanced by Dean P. Macri with the curved surfaces feature.   \\\cline{1-2}
Quake 2 models (.md2) &Quake 2 models are characters with morph target animation. Irrlicht can read, display and animate them directly with this importer.   \\\cline{1-2}
Quake 3 models (.md3) &Quake 3 models are characters with morph target animation, they contain mount points for weapons and body parts and are typically made of several sections which are manually joined together.  \\\cline{1-2}
Stanford Triangle (.ply) &Invented by Stanford University and known as the native format of the infamous \char`\"{}\+Stanford Bunny\char`\"{} model, this is a popular static mesh format used by 3D scanning hardware and software. This loader supports extremely large models in both A\+S\+C\+II and binary format, but only has rudimentary material support in the form of vertex colors and texture coordinates.  \\\cline{1-2}
Stereolithography (.stl) &The S\+TL format is used for rapid prototyping and computer-\/aided manufacturing, thus has no support for materials.  \\\cline{1-2}
\end{longtabu}


To load and display a mesh quickly, just do this\+: 
\begin{DoxyCode}
SceneManager->addAnimatedMeshSceneNode(
   SceneManager->getMesh(\textcolor{stringliteral}{"yourmesh.3ds"}));
\end{DoxyCode}
 If you would like to implement and add your own file format loader to Irrlicht, see \hyperlink{classirr_1_1scene_1_1ISceneManager_a808972cc001db86c0576c38b3b3fbbf7}{add\+External\+Mesh\+Loader()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Filename of the mesh to load. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null if failed, otherwise pointer to the mesh. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}\label{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh@{get\+Mesh}}
\index{get\+Mesh@{get\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh()}{getMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{file }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to an animateable mesh. Loads the file if not loaded already. 

Works just as get\+Mesh(const char$\ast$ filename). If you want to remove a loaded mesh from the cache again, use remove\+Mesh(). 
\begin{DoxyParams}{Parameters}
{\em file} & File handle of the mesh to load. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+U\+LL if failed and pointer to the mesh if successful. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}\label{classirr_1_1scene_1_1ISceneManager_af0ff82d7bac969d6a30f67c7b1fa0c46}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh@{get\+Mesh}}
\index{get\+Mesh@{get\+Mesh}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh()}{getMesh()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IAnimatedMesh}{I\+Animated\+Mesh}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{file }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to an animateable mesh. Loads the file if not loaded already. 

Works just as get\+Mesh(const char$\ast$ filename). If you want to remove a loaded mesh from the cache again, use remove\+Mesh(). 
\begin{DoxyParams}{Parameters}
{\em file} & File handle of the mesh to load. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+U\+LL if failed and pointer to the mesh if successful. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}\label{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Cache@{get\+Mesh\+Cache}}
\index{get\+Mesh\+Cache@{get\+Mesh\+Cache}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Cache()}{getMeshCache()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshCache}{I\+Mesh\+Cache}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get interface to the mesh cache which is shared beween all existing scene managers. 

With this interface, it is possible to manually add new loaded meshes (if \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} is not sufficient), to remove them and to iterate through already loaded meshes. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}\label{classirr_1_1scene_1_1ISceneManager_a45d89c816e33abe0e77eb063d7ce58a8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Cache@{get\+Mesh\+Cache}}
\index{get\+Mesh\+Cache@{get\+Mesh\+Cache}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Cache()}{getMeshCache()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshCache}{I\+Mesh\+Cache}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get interface to the mesh cache which is shared beween all existing scene managers. 

With this interface, it is possible to manually add new loaded meshes (if \hyperlink{classirr_1_1scene_1_1ISceneManager_a63894c3f3d46cfc385116f1705935e03}{I\+Scene\+Manager\+::get\+Mesh()} is not sufficient), to remove them and to iterate through already loaded meshes. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}\label{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Loader@{get\+Mesh\+Loader}}
\index{get\+Mesh\+Loader@{get\+Mesh\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Loader()}{getMeshLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Retrieve the given mesh loader. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the loader to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified loader, 0 if the index is incorrect. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}\label{classirr_1_1scene_1_1ISceneManager_afabf244b50875a52eb42d5d375fa40d4}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Loader@{get\+Mesh\+Loader}}
\index{get\+Mesh\+Loader@{get\+Mesh\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Loader()}{getMeshLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshLoader}{I\+Mesh\+Loader}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Retrieve the given mesh loader. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the loader to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified loader, 0 if the index is incorrect. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}\label{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Manipulator@{get\+Mesh\+Manipulator}}
\index{get\+Mesh\+Manipulator@{get\+Mesh\+Manipulator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Manipulator()}{getMeshManipulator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshManipulator}{I\+Mesh\+Manipulator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Manipulator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to the mesh manipulator. 

\begin{DoxyReturn}{Returns}
Pointer to the mesh manipulator This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}\label{classirr_1_1scene_1_1ISceneManager_a05138d6b5f99fced0061794fb5c42318}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Mesh\+Manipulator@{get\+Mesh\+Manipulator}}
\index{get\+Mesh\+Manipulator@{get\+Mesh\+Manipulator}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Mesh\+Manipulator()}{getMeshManipulator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1IMeshManipulator}{I\+Mesh\+Manipulator}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Mesh\+Manipulator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to the mesh manipulator. 

\begin{DoxyReturn}{Returns}
Pointer to the mesh manipulator This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}\label{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Parameters@{get\+Parameters}}
\index{get\+Parameters@{get\+Parameters}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Parameters()}{getParameters()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1io_1_1IAttributes}{io\+::\+I\+Attributes}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Parameters (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get interface to the parameters set in this scene. 

String parameters can be used by plugins and mesh loaders. For example the C\+MS and L\+M\+TS loader want a parameter named \textquotesingle{}C\+S\+M\+\_\+\+Texture\+Path\textquotesingle{} and \textquotesingle{}L\+M\+T\+S\+\_\+\+Texture\+Path\textquotesingle{} set to the path were attached textures can be found. See C\+S\+M\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, L\+M\+T\+S\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, M\+Y3\+D\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, C\+O\+L\+L\+A\+D\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+I\+N\+S\+T\+A\+N\+C\+ES, D\+M\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH and D\+M\+F\+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+S\+\_\+\+D\+I\+RS \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}\label{classirr_1_1scene_1_1ISceneManager_a4dba8ee7f48fdf6ede2c3f4b5fabcad3}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Parameters@{get\+Parameters}}
\index{get\+Parameters@{get\+Parameters}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Parameters()}{getParameters()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1io_1_1IAttributes}{io\+::\+I\+Attributes}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Parameters (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get interface to the parameters set in this scene. 

String parameters can be used by plugins and mesh loaders. For example the C\+MS and L\+M\+TS loader want a parameter named \textquotesingle{}C\+S\+M\+\_\+\+Texture\+Path\textquotesingle{} and \textquotesingle{}L\+M\+T\+S\+\_\+\+Texture\+Path\textquotesingle{} set to the path were attached textures can be found. See C\+S\+M\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, L\+M\+T\+S\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, M\+Y3\+D\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH, C\+O\+L\+L\+A\+D\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+I\+N\+S\+T\+A\+N\+C\+ES, D\+M\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+P\+A\+TH and D\+M\+F\+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+S\+\_\+\+D\+I\+RS \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}\label{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Root\+Scene\+Node@{get\+Root\+Scene\+Node}}
\index{get\+Root\+Scene\+Node@{get\+Root\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Root\+Scene\+Node()}{getRootSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Root\+Scene\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Gets the root scene node. 

This is the scene node which is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. \begin{DoxyReturn}{Returns}
Pointer to the root scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}\label{classirr_1_1scene_1_1ISceneManager_a4f7075320f1a3bf2838f29c23f78635f}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Root\+Scene\+Node@{get\+Root\+Scene\+Node}}
\index{get\+Root\+Scene\+Node@{get\+Root\+Scene\+Node}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Root\+Scene\+Node()}{getRootSceneNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Root\+Scene\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Gets the root scene node. 

This is the scene node which is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. \begin{DoxyReturn}{Returns}
Pointer to the root scene node. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}\label{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Collision\+Manager@{get\+Scene\+Collision\+Manager}}
\index{get\+Scene\+Collision\+Manager@{get\+Scene\+Collision\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Collision\+Manager()}{getSceneCollisionManager()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneCollisionManager}{I\+Scene\+Collision\+Manager}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Collision\+Manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to the scene collision manager. 

\begin{DoxyReturn}{Returns}
Pointer to the collision manager This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}\label{classirr_1_1scene_1_1ISceneManager_a433b65bfc974d069a1dc2fc296b23d9b}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Collision\+Manager@{get\+Scene\+Collision\+Manager}}
\index{get\+Scene\+Collision\+Manager@{get\+Scene\+Collision\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Collision\+Manager()}{getSceneCollisionManager()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneCollisionManager}{I\+Scene\+Collision\+Manager}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Collision\+Manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get pointer to the scene collision manager. 

\begin{DoxyReturn}{Returns}
Pointer to the collision manager This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}\label{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Loader@{get\+Scene\+Loader}}
\index{get\+Scene\+Loader@{get\+Scene\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Loader()}{getSceneLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Retrieve the given scene loader. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the loader to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified loader, 0 if the index is incorrect. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}\label{classirr_1_1scene_1_1ISceneManager_a504fd792634ce0fbace4d13e70e4efab}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Loader@{get\+Scene\+Loader}}
\index{get\+Scene\+Loader@{get\+Scene\+Loader}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Loader()}{getSceneLoader()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneLoader}{I\+Scene\+Loader}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Retrieve the given scene loader. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the loader to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified loader, 0 if the index is incorrect. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}\label{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Animator\+Factory@{get\+Scene\+Node\+Animator\+Factory}}
\index{get\+Scene\+Node\+Animator\+Factory@{get\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Animator\+Factory()}{getSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get scene node animator factory by index. 

\begin{DoxyReturn}{Returns}
Pointer to the requested scene node animator factory, or 0 if it does not exist. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}\label{classirr_1_1scene_1_1ISceneManager_a96d8272b74bd0adc9138f17e832dc887}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Animator\+Factory@{get\+Scene\+Node\+Animator\+Factory}}
\index{get\+Scene\+Node\+Animator\+Factory@{get\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Animator\+Factory()}{getSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get scene node animator factory by index. 

\begin{DoxyReturn}{Returns}
Pointer to the requested scene node animator factory, or 0 if it does not exist. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}\label{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Factory@{get\+Scene\+Node\+Factory}}
\index{get\+Scene\+Node\+Factory@{get\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Factory()}{getSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a scene node factory by index. 

\begin{DoxyReturn}{Returns}
Pointer to the requested scene node factory, or 0 if it does not exist. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}\label{classirr_1_1scene_1_1ISceneManager_ac912b9effd5ce46f5dc038e0568e614c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Factory@{get\+Scene\+Node\+Factory}}
\index{get\+Scene\+Node\+Factory@{get\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Factory()}{getSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32}}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get a scene node factory by index. 

\begin{DoxyReturn}{Returns}
Pointer to the requested scene node factory, or 0 if it does not exist. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}\label{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Id@{get\+Scene\+Node\+From\+Id}}
\index{get\+Scene\+Node\+From\+Id@{get\+Scene\+Node\+From\+Id}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Id()}{getSceneNodeFromId()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Id (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified id. 


\begin{DoxyParams}{Parameters}
{\em id} & The id to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}\label{classirr_1_1scene_1_1ISceneManager_a038e2afb1397fe8f2b6f8f6c55d52b55}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Id@{get\+Scene\+Node\+From\+Id}}
\index{get\+Scene\+Node\+From\+Id@{get\+Scene\+Node\+From\+Id}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Id()}{getSceneNodeFromId()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Id (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32}}]{id,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified id. 


\begin{DoxyParams}{Parameters}
{\em id} & The id to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}\label{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Name@{get\+Scene\+Node\+From\+Name}}
\index{get\+Scene\+Node\+From\+Name@{get\+Scene\+Node\+From\+Name}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Name()}{getSceneNodeFromName()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Name (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$}]{name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified name. 


\begin{DoxyParams}{Parameters}
{\em name} & The name to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}\label{classirr_1_1scene_1_1ISceneManager_a13ada3cca4b9eadee5e8ba3ccb6683da}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Name@{get\+Scene\+Node\+From\+Name}}
\index{get\+Scene\+Node\+From\+Name@{get\+Scene\+Node\+From\+Name}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Name()}{getSceneNodeFromName()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Name (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$}]{name,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified name. 


\begin{DoxyParams}{Parameters}
{\em name} & The name to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}\label{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Type@{get\+Scene\+Node\+From\+Type}}
\index{get\+Scene\+Node\+From\+Type@{get\+Scene\+Node\+From\+Type}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Type()}{getSceneNodeFromType()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{scene\+::\+E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE}}]{type,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified type. 


\begin{DoxyParams}{Parameters}
{\em type} & The type to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this type, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}\label{classirr_1_1scene_1_1ISceneManager_a5ab8e8f8cc8456a3ea881c75dfe505bb}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+From\+Type@{get\+Scene\+Node\+From\+Type}}
\index{get\+Scene\+Node\+From\+Type@{get\+Scene\+Node\+From\+Type}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+From\+Type()}{getSceneNodeFromType()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+From\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{scene\+::\+E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE}}]{type,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the first scene node with the specified type. 


\begin{DoxyParams}{Parameters}
{\em type} & The type to search for \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the first scene node with this type, and null if no scene node could be found. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}\label{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Render\+Pass@{get\+Scene\+Node\+Render\+Pass}}
\index{get\+Scene\+Node\+Render\+Pass@{get\+Scene\+Node\+Render\+Pass}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Render\+Pass()}{getSceneNodeRenderPass()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Render\+Pass (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get current render pass. 

All scene nodes are being rendered in a specific order. First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}\label{classirr_1_1scene_1_1ISceneManager_a2b8f844a1367d80648bc055a5639807b}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Node\+Render\+Pass@{get\+Scene\+Node\+Render\+Pass}}
\index{get\+Scene\+Node\+Render\+Pass@{get\+Scene\+Node\+Render\+Pass}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Node\+Render\+Pass()}{getSceneNodeRenderPass()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Node\+Render\+Pass (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get current render pass. 

All scene nodes are being rendered in a specific order. First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}\label{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Nodes\+From\+Type@{get\+Scene\+Nodes\+From\+Type}}
\index{get\+Scene\+Nodes\+From\+Type@{get\+Scene\+Nodes\+From\+Type}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Nodes\+From\+Type()}{getSceneNodesFromType()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Nodes\+From\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE}}]{type,  }\item[{\hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1scene_1_1ISceneNode}{scene\+::\+I\+Scene\+Node} $\ast$$>$ \&}]{out\+Nodes,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get scene nodes by type. 


\begin{DoxyParams}{Parameters}
{\em type} & Type of scene node to find (E\+S\+N\+T\+\_\+\+A\+NY will return all child nodes). \\
\hline
{\em out\+Nodes} & array to be filled with results. \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}\label{classirr_1_1scene_1_1ISceneManager_aa920cb095fc901273fd097a39ebc3255}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Scene\+Nodes\+From\+Type@{get\+Scene\+Nodes\+From\+Type}}
\index{get\+Scene\+Nodes\+From\+Type@{get\+Scene\+Nodes\+From\+Type}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Scene\+Nodes\+From\+Type()}{getSceneNodesFromType()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Scene\+Nodes\+From\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceirr_1_1scene_acad3d7ef92a9807d391ba29120f3b7bd}{E\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+T\+Y\+PE}}]{type,  }\item[{\hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1scene_1_1ISceneNode}{scene\+::\+I\+Scene\+Node} $\ast$$>$ \&}]{out\+Nodes,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{start = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get scene nodes by type. 


\begin{DoxyParams}{Parameters}
{\em type} & Type of scene node to find (E\+S\+N\+T\+\_\+\+A\+NY will return all child nodes). \\
\hline
{\em out\+Nodes} & array to be filled with results. \\
\hline
{\em start} & Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}\label{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Video\+Driver@{get\+Video\+Driver}}
\index{get\+Video\+Driver@{get\+Video\+Driver}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Video\+Driver()}{getVideoDriver()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1video_1_1IVideoDriver}{video\+::\+I\+Video\+Driver}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Video\+Driver (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the video driver. 

\begin{DoxyReturn}{Returns}
Pointer to the video Driver. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}\label{classirr_1_1scene_1_1ISceneManager_afde082160205a8faab44cd5b61e3745c}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!get\+Video\+Driver@{get\+Video\+Driver}}
\index{get\+Video\+Driver@{get\+Video\+Driver}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{get\+Video\+Driver()}{getVideoDriver()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{classirr_1_1video_1_1IVideoDriver}{video\+::\+I\+Video\+Driver}$\ast$ irr\+::scene\+::\+I\+Scene\+Manager\+::get\+Video\+Driver (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the video driver. 

\begin{DoxyReturn}{Returns}
Pointer to the video Driver. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_a03856a09355b89d178090c4a5f738543}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}\label{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!is\+Culled@{is\+Culled}}
\index{is\+Culled@{is\+Culled}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{is\+Culled()}{isCulled()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::is\+Culled (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if node is culled in current view frustum. 

Please note that depending on the used culling method this check can be rather coarse, or slow. A positive result is correct, though, i.\+e. if this method returns true the node is positively not visible. The node might still be invisible even if this method returns false. 
\begin{DoxyParams}{Parameters}
{\em node} & The scene node which is checked for culling. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if node is not visible in the current scene, else false. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}\label{classirr_1_1scene_1_1ISceneManager_aff6c6d553e0faf12bbfd33e814ad4352}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!is\+Culled@{is\+Culled}}
\index{is\+Culled@{is\+Culled}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{is\+Culled()}{isCulled()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::is\+Culled (\begin{DoxyParamCaption}\item[{const \hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if node is culled in current view frustum. 

Please note that depending on the used culling method this check can be rather coarse, or slow. A positive result is correct, though, i.\+e. if this method returns true the node is positively not visible. The node might still be invisible even if this method returns false. 
\begin{DoxyParams}{Parameters}
{\em node} & The scene node which is checked for culling. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if node is not visible in the current scene, else false. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}\label{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!load\+Scene@{load\+Scene}}
\index{load\+Scene@{load\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{load\+Scene()}{loadScene()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::load\+Scene (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{root\+Node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Loads a scene. Note that the current scene is not cleared before. 

The scene is usually loaded from an .irr file, an xml based format, but other scene formats can be added to the engine via \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{I\+Scene\+Manager\+::add\+External\+Scene\+Loader}. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}) or saved directly by the engine using \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{I\+Scene\+Manager\+::save\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file to load from. \\
\hline
{\em user\+Data\+Serializer} & If you want to load user data possibily saved in that file for some scene nodes in the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em root\+Node} & Node which is taken as the root node of the scene. Pass 0 to add the scene directly to the scene manager (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}\label{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!load\+Scene@{load\+Scene}}
\index{load\+Scene@{load\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{load\+Scene()}{loadScene()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::load\+Scene (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{root\+Node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Loads a scene. Note that the current scene is not cleared before. 

The scene is usually loaded from an .irr file, an xml based format, but other scene formats can be added to the engine via \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{I\+Scene\+Manager\+::add\+External\+Scene\+Loader}. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}) or saved directly by the engine using \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{I\+Scene\+Manager\+::save\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file to load from. \\
\hline
{\em user\+Data\+Serializer} & If you want to load user data possibily saved in that file for some scene nodes in the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em root\+Node} & Node which is taken as the root node of the scene. Pass 0 to add the scene directly to the scene manager (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}\label{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!load\+Scene@{load\+Scene}}
\index{load\+Scene@{load\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{load\+Scene()}{loadScene()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::load\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{file,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{root\+Node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Loads a scene. Note that the current scene is not cleared before. 

The scene is usually loaded from an .irr file, an xml based format, but other scene formats can be added to the engine via \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{I\+Scene\+Manager\+::add\+External\+Scene\+Loader}. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}) or saved directly by the engine using \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{I\+Scene\+Manager\+::save\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em file} & File where the scene is loaded from. \\
\hline
{\em user\+Data\+Serializer} & If you want to load user data possibily saved in that file for some scene nodes in the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em root\+Node} & Node which is taken as the root node of the scene. Pass 0 to add the scene directly to the scene manager (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}\label{classirr_1_1scene_1_1ISceneManager_a21549d3cae3526313c37d9ed7fd08767}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!load\+Scene@{load\+Scene}}
\index{load\+Scene@{load\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{load\+Scene()}{loadScene()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::load\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$}]{file,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{root\+Node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Loads a scene. Note that the current scene is not cleared before. 

The scene is usually loaded from an .irr file, an xml based format, but other scene formats can be added to the engine via \hyperlink{classirr_1_1scene_1_1ISceneManager_a8f0bc0221c4faaca80ac8f560ee424ef}{I\+Scene\+Manager\+::add\+External\+Scene\+Loader}. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}) or saved directly by the engine using \hyperlink{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}{I\+Scene\+Manager\+::save\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em file} & File where the scene is loaded from. \\
\hline
{\em user\+Data\+Serializer} & If you want to load user data possibily saved in that file for some scene nodes in the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em root\+Node} & Node which is taken as the root node of the scene. Pass 0 to add the scene directly to the scene manager (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}\label{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!post\+Event\+From\+User@{post\+Event\+From\+User}}
\index{post\+Event\+From\+User@{post\+Event\+From\+User}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{post\+Event\+From\+User()}{postEventFromUser()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::post\+Event\+From\+User (\begin{DoxyParamCaption}\item[{const \hyperlink{structirr_1_1SEvent}{S\+Event} \&}]{event }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Posts an input event to the environment. 

Usually you do not have to use this method, it is used by the internal engine. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}\label{classirr_1_1scene_1_1ISceneManager_ac68aa8d654884f19ad52fa28f11db424}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!post\+Event\+From\+User@{post\+Event\+From\+User}}
\index{post\+Event\+From\+User@{post\+Event\+From\+User}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{post\+Event\+From\+User()}{postEventFromUser()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::post\+Event\+From\+User (\begin{DoxyParamCaption}\item[{const \hyperlink{structirr_1_1SEvent}{S\+Event} \&}]{event }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Posts an input event to the environment. 

Usually you do not have to use this method, it is used by the internal engine. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}\label{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Node\+For\+Rendering@{register\+Node\+For\+Rendering}}
\index{register\+Node\+For\+Rendering@{register\+Node\+For\+Rendering}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Node\+For\+Rendering()}{registerNodeForRendering()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Node\+For\+Rendering (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS}}]{pass = {\ttfamily \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67fad9a67a121247bc1001e35b8a8c0ef20d}{E\+S\+N\+R\+P\+\_\+\+A\+U\+T\+O\+M\+A\+T\+IC}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Registers a node for rendering it at a specific time. 

This method should only be used by Scene\+Nodes when they get a \hyperlink{classirr_1_1scene_1_1ISceneNode_ac9795bfcb88dcaf8cba6ea3296e5d8d0}{I\+Scene\+Node\+::\+On\+Register\+Scene\+Node()} call. 
\begin{DoxyParams}{Parameters}
{\em node} & Node to register for drawing. Usually scene nodes would set \textquotesingle{}this\textquotesingle{} as parameter here because they want to be drawn. \\
\hline
{\em pass} & Specifies when the node wants to be drawn in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use E\+S\+N\+R\+P\+\_\+\+S\+H\+A\+D\+OW for this. See \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{scene\+::\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} for details. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
scene will be rendered ( passed culling ) 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}\label{classirr_1_1scene_1_1ISceneManager_aaf17bdde6d4e9ef61a76f3b43100ecb8}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Node\+For\+Rendering@{register\+Node\+For\+Rendering}}
\index{register\+Node\+For\+Rendering@{register\+Node\+For\+Rendering}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Node\+For\+Rendering()}{registerNodeForRendering()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Node\+For\+Rendering (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS}}]{pass = {\ttfamily \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67fad9a67a121247bc1001e35b8a8c0ef20d}{E\+S\+N\+R\+P\+\_\+\+A\+U\+T\+O\+M\+A\+T\+IC}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Registers a node for rendering it at a specific time. 

This method should only be used by Scene\+Nodes when they get a \hyperlink{classirr_1_1scene_1_1ISceneNode_ac9795bfcb88dcaf8cba6ea3296e5d8d0}{I\+Scene\+Node\+::\+On\+Register\+Scene\+Node()} call. 
\begin{DoxyParams}{Parameters}
{\em node} & Node to register for drawing. Usually scene nodes would set \textquotesingle{}this\textquotesingle{} as parameter here because they want to be drawn. \\
\hline
{\em pass} & Specifies when the node wants to be drawn in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use E\+S\+N\+R\+P\+\_\+\+S\+H\+A\+D\+OW for this. See \hyperlink{namespaceirr_1_1scene_a7862269bd1abc123929d4dbb8200d67f}{scene\+::\+E\+\_\+\+S\+C\+E\+N\+E\+\_\+\+N\+O\+D\+E\+\_\+\+R\+E\+N\+D\+E\+R\+\_\+\+P\+A\+SS} for details. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
scene will be rendered ( passed culling ) 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}\label{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Scene\+Node\+Animator\+Factory@{register\+Scene\+Node\+Animator\+Factory}}
\index{register\+Scene\+Node\+Animator\+Factory@{register\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Scene\+Node\+Animator\+Factory()}{registerSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$}]{factory\+To\+Add }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node animator factory to the scene manager. 

Use this to extend the scene manager with new scene node animator types which it should be able to create automaticly, for example when loading data from xml files. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}\label{classirr_1_1scene_1_1ISceneManager_af48c93cc41f986f08ed964cc575ee7a0}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Scene\+Node\+Animator\+Factory@{register\+Scene\+Node\+Animator\+Factory}}
\index{register\+Scene\+Node\+Animator\+Factory@{register\+Scene\+Node\+Animator\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Scene\+Node\+Animator\+Factory()}{registerSceneNodeAnimatorFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Scene\+Node\+Animator\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNodeAnimatorFactory}{I\+Scene\+Node\+Animator\+Factory} $\ast$}]{factory\+To\+Add }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node animator factory to the scene manager. 

Use this to extend the scene manager with new scene node animator types which it should be able to create automaticly, for example when loading data from xml files. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}\label{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Scene\+Node\+Factory@{register\+Scene\+Node\+Factory}}
\index{register\+Scene\+Node\+Factory@{register\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Scene\+Node\+Factory()}{registerSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Scene\+Node\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$}]{factory\+To\+Add }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node factory to the scene manager. 

Use this to extend the scene manager with new scene node types which it should be able to create automaticly, for example when loading data from xml files. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}\label{classirr_1_1scene_1_1ISceneManager_a75ac9315def74ae5e26a2d6a2f5a38e9}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!register\+Scene\+Node\+Factory@{register\+Scene\+Node\+Factory}}
\index{register\+Scene\+Node\+Factory@{register\+Scene\+Node\+Factory}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{register\+Scene\+Node\+Factory()}{registerSceneNodeFactory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::register\+Scene\+Node\+Factory (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ISceneNodeFactory}{I\+Scene\+Node\+Factory} $\ast$}]{factory\+To\+Add }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds a scene node factory to the scene manager. 

Use this to extend the scene manager with new scene node types which it should be able to create automaticly, for example when loading data from xml files. \mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}\label{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}\label{classirr_1_1scene_1_1ISceneManager_a6dd059e96ff4f7233b7ba1ed7e39c337}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{filename,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}\label{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} $\ast$}]{file,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em file} & File where the scene is saved into. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}\label{classirr_1_1scene_1_1ISceneManager_a5de4b5131186f3bcd8b0213f68e4a9ce}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} $\ast$}]{file,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em file} & File where the scene is saved into. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}\label{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IXMLWriter}{io\+::\+I\+X\+M\+L\+Writer} $\ast$}]{writer,  }\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{current\+Path,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em writer} & X\+M\+L\+Writer with which the scene is saved. \\
\hline
{\em current\+Path} & Path which is used for relative file names. Usually the directory of the file written into. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}\label{classirr_1_1scene_1_1ISceneManager_a824daa42c8bcf5c5eff159a56052000d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!save\+Scene@{save\+Scene}}
\index{save\+Scene@{save\+Scene}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{save\+Scene()}{saveScene()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily virtual bool irr\+::scene\+::\+I\+Scene\+Manager\+::save\+Scene (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1io_1_1IXMLWriter}{io\+::\+I\+X\+M\+L\+Writer} $\ast$}]{writer,  }\item[{const \hyperlink{namespaceirr_1_1io_a6468281622ce3a1c46b72e19f32dded5}{io\+::path} \&}]{current\+Path,  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} $\ast$}]{user\+Data\+Serializer = {\ttfamily 0},  }\item[{\hyperlink{classirr_1_1scene_1_1ISceneNode}{I\+Scene\+Node} $\ast$}]{node = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Saves the current scene into a file. 

Scene nodes with the option is\+Debug\+Object set to true are not being saved. The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irr\+Edit (\href{http://www.ambiera.com/irredit/}{\tt http\+://www.\+ambiera.\+com/irredit/}). To load .irr files again, see \hyperlink{classirr_1_1scene_1_1ISceneManager_aa7641dd33e84fca7946ed17047349a3e}{I\+Scene\+Manager\+::load\+Scene()}. 
\begin{DoxyParams}{Parameters}
{\em writer} & X\+M\+L\+Writer with which the scene is saved. \\
\hline
{\em current\+Path} & Path which is used for relative file names. Usually the directory of the file written into. \\
\hline
{\em user\+Data\+Serializer} & If you want to save some user data for every scene node into the file, implement the \hyperlink{classirr_1_1scene_1_1ISceneUserDataSerializer}{I\+Scene\+User\+Data\+Serializer} interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. \\
\hline
{\em node} & Node which is taken as the top node of the scene. This node and all of its descendants are saved into the scene file. Pass 0 or the scene manager to save the full scene (which is also the default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if successful. 
\end{DoxyReturn}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}\label{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!set\+Active\+Camera@{set\+Active\+Camera}}
\index{set\+Active\+Camera@{set\+Active\+Camera}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{set\+Active\+Camera()}{setActiveCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::set\+Active\+Camera (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$}]{camera }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Sets the currently active camera. 

The previous active camera will be deactivated. 
\begin{DoxyParams}{Parameters}
{\em camera} & The new camera which should be active. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}\label{classirr_1_1scene_1_1ISceneManager_a5d19b7a6803a0a021082fc2b86043b3d}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!set\+Active\+Camera@{set\+Active\+Camera}}
\index{set\+Active\+Camera@{set\+Active\+Camera}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{set\+Active\+Camera()}{setActiveCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::set\+Active\+Camera (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ICameraSceneNode}{I\+Camera\+Scene\+Node} $\ast$}]{camera }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Sets the currently active camera. 

The previous active camera will be deactivated. 
\begin{DoxyParams}{Parameters}
{\em camera} & The new camera which should be active. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}\label{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!set\+Light\+Manager@{set\+Light\+Manager}}
\index{set\+Light\+Manager@{set\+Light\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{set\+Light\+Manager()}{setLightManager()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::set\+Light\+Manager (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ILightManager}{I\+Light\+Manager} $\ast$}]{light\+Manager }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Register a custom callbacks manager which gets callbacks during scene rendering. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em light\+Manager} & the new callbacks manager. You may pass 0 to remove the current callbacks manager and restore the default behavior. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}\label{classirr_1_1scene_1_1ISceneManager_a0065307bf3ff12fdc5b7bb624987a1c2}} 
\index{irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}!set\+Light\+Manager@{set\+Light\+Manager}}
\index{set\+Light\+Manager@{set\+Light\+Manager}!irr\+::scene\+::\+I\+Scene\+Manager@{irr\+::scene\+::\+I\+Scene\+Manager}}
\subsubsection{\texorpdfstring{set\+Light\+Manager()}{setLightManager()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void irr\+::scene\+::\+I\+Scene\+Manager\+::set\+Light\+Manager (\begin{DoxyParamCaption}\item[{\hyperlink{classirr_1_1scene_1_1ILightManager}{I\+Light\+Manager} $\ast$}]{light\+Manager }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Register a custom callbacks manager which gets callbacks during scene rendering. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em light\+Manager} & the new callbacks manager. You may pass 0 to remove the current callbacks manager and restore the default behavior. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
indie\+\_\+share/controller/include/I\+Scene\+Manager.\+h\end{DoxyCompactItemize}
