<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Indie Studio: irr::scene::ISceneNodeAnimatorCollisionResponse Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Indie Studio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1scene.html">scene</a></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html">ISceneNodeAnimatorCollisionResponse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::ISceneNodeAnimatorCollisionResponse Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Special scene node animator for doing automatic collision detection and response.  
 <a href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indie__share_2controller_2include_2ISceneNodeAnimatorCollisionResponse_8h_source.html">ISceneNodeAnimatorCollisionResponse.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::scene::ISceneNodeAnimatorCollisionResponse:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.png" usemap="#irr::scene::ISceneNodeAnimatorCollisionResponse_map" alt=""/>
  <map id="irr::scene::ISceneNodeAnimatorCollisionResponse_map" name="irr::scene::ISceneNodeAnimatorCollisionResponse_map">
<area href="classirr_1_1scene_1_1ISceneNodeAnimator.html" title="Animates a scene node. Can animate position, rotation, material, and so on. " alt="irr::scene::ISceneNodeAnimator" shape="rect" coords="0,224,293,248"/>
<area href="classirr_1_1scene_1_1ISceneNodeAnimator.html" title="Animates a scene node. Can animate position, rotation, material, and so on. " alt="irr::scene::ISceneNodeAnimator" shape="rect" coords="606,224,899,248"/>
<area href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events. " alt="irr::IEventReceiver" shape="rect" coords="909,168,1202,192"/>
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="909,112,1202,136"/>
<area href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events. " alt="irr::IEventReceiver" shape="rect" coords="909,56,1202,80"/>
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="909,0,1202,24"/>
<area href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events. " alt="irr::IEventReceiver" shape="rect" coords="303,168,596,192"/>
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="303,112,596,136"/>
<area href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events. " alt="irr::IEventReceiver" shape="rect" coords="303,56,596,80"/>
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="303,0,596,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="memItemLeft" align="right" valign="top"><a id="ab6b85fb4f76e2d0c03cf2c6b326bddde"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#ab6b85fb4f76e2d0c03cf2c6b326bddde">~ISceneNodeAnimatorCollisionResponse</a> ()</td></tr>
<tr class="memdesc:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a66f5534c1d2ac0e2ea52e7b21a3c91d7">isFalling</a> () const =0</td></tr>
<tr class="memdesc:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the attached scene node is falling.  <a href="#a66f5534c1d2ac0e2ea52e7b21a3c91d7">More...</a><br /></td></tr>
<tr class="separator:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71af73590016ba936340a79467690d3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a71af73590016ba936340a79467690d3f">setEllipsoidRadius</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;radius)=0</td></tr>
<tr class="memdesc:a71af73590016ba936340a79467690d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the radius of the ellipsoid for collision detection and response.  <a href="#a71af73590016ba936340a79467690d3f">More...</a><br /></td></tr>
<tr class="separator:a71af73590016ba936340a79467690d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92965919db3dfbaab2d1f4987a2c52c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a92965919db3dfbaab2d1f4987a2c52c1">getEllipsoidRadius</a> () const =0</td></tr>
<tr class="memdesc:a92965919db3dfbaab2d1f4987a2c52c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radius of the ellipsoid for collision detection and response.  <a href="#a92965919db3dfbaab2d1f4987a2c52c1">More...</a><br /></td></tr>
<tr class="separator:a92965919db3dfbaab2d1f4987a2c52c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af366695a82153c144b58c65cb4d092f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#af366695a82153c144b58c65cb4d092f3">setGravity</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;gravity)=0</td></tr>
<tr class="memdesc:af366695a82153c144b58c65cb4d092f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gravity of the environment.  <a href="#af366695a82153c144b58c65cb4d092f3">More...</a><br /></td></tr>
<tr class="separator:af366695a82153c144b58c65cb4d092f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c86e8948691ce00f2aa6253c5683a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a1b7c86e8948691ce00f2aa6253c5683a">getGravity</a> () const =0</td></tr>
<tr class="memdesc:a1b7c86e8948691ce00f2aa6253c5683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current vector of gravity.  <a href="#a1b7c86e8948691ce00f2aa6253c5683a">More...</a><br /></td></tr>
<tr class="separator:a1b7c86e8948691ce00f2aa6253c5683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b98d04be89fb06cce3384e0188abf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a409b98d04be89fb06cce3384e0188abf">jump</a> (<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> jumpSpeed)=0</td></tr>
<tr class="memdesc:a409b98d04be89fb06cce3384e0188abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Jump' the animator, by adding a jump speed opposite to its gravity  <a href="#a409b98d04be89fb06cce3384e0188abf">More...</a><br /></td></tr>
<tr class="separator:a409b98d04be89fb06cce3384e0188abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402cbe4934ad10f18762001458c939d9"><td class="memItemLeft" align="right" valign="top"><a id="a402cbe4934ad10f18762001458c939d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a402cbe4934ad10f18762001458c939d9">setAnimateTarget</a> (bool enable)=0</td></tr>
<tr class="memdesc:a402cbe4934ad10f18762001458c939d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should the Target react on collision ( default = true ) <br /></td></tr>
<tr class="separator:a402cbe4934ad10f18762001458c939d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ec747d320d70dd3e2a4143782ffc7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a234ec747d320d70dd3e2a4143782ffc7">setEllipsoidTranslation</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;translation)=0</td></tr>
<tr class="memdesc:a234ec747d320d70dd3e2a4143782ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set translation of the collision ellipsoid.  <a href="#a234ec747d320d70dd3e2a4143782ffc7">More...</a><br /></td></tr>
<tr class="separator:a234ec747d320d70dd3e2a4143782ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0a2ad6ff375a85e08a3226e3267286"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#aff0a2ad6ff375a85e08a3226e3267286">getEllipsoidTranslation</a> () const =0</td></tr>
<tr class="memdesc:aff0a2ad6ff375a85e08a3226e3267286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the translation of the ellipsoid for collision detection.  <a href="#aff0a2ad6ff375a85e08a3226e3267286">More...</a><br /></td></tr>
<tr class="separator:aff0a2ad6ff375a85e08a3226e3267286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a42aa84d4843a734f8dd1f20b5c92ef06">setWorld</a> (<a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *newWorld)=0</td></tr>
<tr class="memdesc:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a triangle selector holding all triangles of the world with which the scene node may collide.  <a href="#a42aa84d4843a734f8dd1f20b5c92ef06">More...</a><br /></td></tr>
<tr class="separator:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e106171ca57a4877d7a6f0edd9762f"><td class="memItemLeft" align="right" valign="top"><a id="a58e106171ca57a4877d7a6f0edd9762f"></a>
virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a58e106171ca57a4877d7a6f0edd9762f">getWorld</a> () const =0</td></tr>
<tr class="memdesc:a58e106171ca57a4877d7a6f0edd9762f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current triangle selector containing all triangles for collision detection. <br /></td></tr>
<tr class="separator:a58e106171ca57a4877d7a6f0edd9762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b291ba9249c451779f76ab2154aa3c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a5b291ba9249c451779f76ab2154aa3c2">setTargetNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a5b291ba9249c451779f76ab2154aa3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the single node that this animator will act on.  <a href="#a5b291ba9249c451779f76ab2154aa3c2">More...</a><br /></td></tr>
<tr class="separator:a5b291ba9249c451779f76ab2154aa3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a11b1c54ec705f4ba8b0bb3facb0f09cb">getTargetNode</a> (void) const =0</td></tr>
<tr class="memdesc:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the single node that this animator is acting on.  <a href="#a11b1c54ec705f4ba8b0bb3facb0f09cb">More...</a><br /></td></tr>
<tr class="separator:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb04bc4d7de2203879a8392d024f466"><td class="memItemLeft" align="right" valign="top"><a id="a8bb04bc4d7de2203879a8392d024f466"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a8bb04bc4d7de2203879a8392d024f466">collisionOccurred</a> () const =0</td></tr>
<tr class="memdesc:a8bb04bc4d7de2203879a8392d024f466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a collision occurred during the last <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84" title="Animates a scene node. ">animateNode()</a> <br /></td></tr>
<tr class="separator:a8bb04bc4d7de2203879a8392d024f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb39b68d18f721960ac73dc158968479"><td class="memItemLeft" align="right" valign="top"><a id="acb39b68d18f721960ac73dc158968479"></a>
virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#acb39b68d18f721960ac73dc158968479">getCollisionPoint</a> () const =0</td></tr>
<tr class="memdesc:acb39b68d18f721960ac73dc158968479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last point of collision. <br /></td></tr>
<tr class="separator:acb39b68d18f721960ac73dc158968479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d0576446a64e9944ef15a04722591"><td class="memItemLeft" align="right" valign="top"><a id="abb9d0576446a64e9944ef15a04722591"></a>
virtual const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#abb9d0576446a64e9944ef15a04722591">getCollisionTriangle</a> () const =0</td></tr>
<tr class="memdesc:abb9d0576446a64e9944ef15a04722591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last triangle that caused a collision. <br /></td></tr>
<tr class="separator:abb9d0576446a64e9944ef15a04722591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788542083dda874c63e278891535a9f4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a788542083dda874c63e278891535a9f4">getCollisionResultPosition</a> (void) const =0</td></tr>
<tr class="memdesc:a788542083dda874c63e278891535a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position that the target node will be moved to, unless the collision is consumed in a callback.  <a href="#a788542083dda874c63e278891535a9f4">More...</a><br /></td></tr>
<tr class="separator:a788542083dda874c63e278891535a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="memItemLeft" align="right" valign="top"><a id="a5a975ddf3d776d6bb4c6d44c36cc74fd"></a>
virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a5a975ddf3d776d6bb4c6d44c36cc74fd">getCollisionNode</a> (void) const =0</td></tr>
<tr class="memdesc:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node that was collided with. <br /></td></tr>
<tr class="separator:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b97f977b446200c5dd22230aec5d275"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a2b97f977b446200c5dd22230aec5d275">setCollisionCallback</a> (<a class="el" href="classirr_1_1scene_1_1ICollisionCallback.html">ICollisionCallback</a> *callback)=0</td></tr>
<tr class="memdesc:a2b97f977b446200c5dd22230aec5d275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback interface which will be called if a collision occurs.  <a href="#a2b97f977b446200c5dd22230aec5d275">More...</a><br /></td></tr>
<tr class="separator:a2b97f977b446200c5dd22230aec5d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="memItemLeft" align="right" valign="top"><a id="ab6b85fb4f76e2d0c03cf2c6b326bddde"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#ab6b85fb4f76e2d0c03cf2c6b326bddde">~ISceneNodeAnimatorCollisionResponse</a> ()</td></tr>
<tr class="memdesc:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab6b85fb4f76e2d0c03cf2c6b326bddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a66f5534c1d2ac0e2ea52e7b21a3c91d7">isFalling</a> () const =0</td></tr>
<tr class="memdesc:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the attached scene node is falling.  <a href="#a66f5534c1d2ac0e2ea52e7b21a3c91d7">More...</a><br /></td></tr>
<tr class="separator:a66f5534c1d2ac0e2ea52e7b21a3c91d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71af73590016ba936340a79467690d3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a71af73590016ba936340a79467690d3f">setEllipsoidRadius</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;radius)=0</td></tr>
<tr class="memdesc:a71af73590016ba936340a79467690d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the radius of the ellipsoid for collision detection and response.  <a href="#a71af73590016ba936340a79467690d3f">More...</a><br /></td></tr>
<tr class="separator:a71af73590016ba936340a79467690d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92965919db3dfbaab2d1f4987a2c52c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a92965919db3dfbaab2d1f4987a2c52c1">getEllipsoidRadius</a> () const =0</td></tr>
<tr class="memdesc:a92965919db3dfbaab2d1f4987a2c52c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radius of the ellipsoid for collision detection and response.  <a href="#a92965919db3dfbaab2d1f4987a2c52c1">More...</a><br /></td></tr>
<tr class="separator:a92965919db3dfbaab2d1f4987a2c52c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af366695a82153c144b58c65cb4d092f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#af366695a82153c144b58c65cb4d092f3">setGravity</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;gravity)=0</td></tr>
<tr class="memdesc:af366695a82153c144b58c65cb4d092f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gravity of the environment.  <a href="#af366695a82153c144b58c65cb4d092f3">More...</a><br /></td></tr>
<tr class="separator:af366695a82153c144b58c65cb4d092f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c86e8948691ce00f2aa6253c5683a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a1b7c86e8948691ce00f2aa6253c5683a">getGravity</a> () const =0</td></tr>
<tr class="memdesc:a1b7c86e8948691ce00f2aa6253c5683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current vector of gravity.  <a href="#a1b7c86e8948691ce00f2aa6253c5683a">More...</a><br /></td></tr>
<tr class="separator:a1b7c86e8948691ce00f2aa6253c5683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b98d04be89fb06cce3384e0188abf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a409b98d04be89fb06cce3384e0188abf">jump</a> (<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> jumpSpeed)=0</td></tr>
<tr class="memdesc:a409b98d04be89fb06cce3384e0188abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Jump' the animator, by adding a jump speed opposite to its gravity  <a href="#a409b98d04be89fb06cce3384e0188abf">More...</a><br /></td></tr>
<tr class="separator:a409b98d04be89fb06cce3384e0188abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402cbe4934ad10f18762001458c939d9"><td class="memItemLeft" align="right" valign="top"><a id="a402cbe4934ad10f18762001458c939d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a402cbe4934ad10f18762001458c939d9">setAnimateTarget</a> (bool enable)=0</td></tr>
<tr class="memdesc:a402cbe4934ad10f18762001458c939d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should the Target react on collision ( default = true ) <br /></td></tr>
<tr class="separator:a402cbe4934ad10f18762001458c939d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ec747d320d70dd3e2a4143782ffc7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a234ec747d320d70dd3e2a4143782ffc7">setEllipsoidTranslation</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;translation)=0</td></tr>
<tr class="memdesc:a234ec747d320d70dd3e2a4143782ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set translation of the collision ellipsoid.  <a href="#a234ec747d320d70dd3e2a4143782ffc7">More...</a><br /></td></tr>
<tr class="separator:a234ec747d320d70dd3e2a4143782ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0a2ad6ff375a85e08a3226e3267286"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#aff0a2ad6ff375a85e08a3226e3267286">getEllipsoidTranslation</a> () const =0</td></tr>
<tr class="memdesc:aff0a2ad6ff375a85e08a3226e3267286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the translation of the ellipsoid for collision detection.  <a href="#aff0a2ad6ff375a85e08a3226e3267286">More...</a><br /></td></tr>
<tr class="separator:aff0a2ad6ff375a85e08a3226e3267286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a42aa84d4843a734f8dd1f20b5c92ef06">setWorld</a> (<a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *newWorld)=0</td></tr>
<tr class="memdesc:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a triangle selector holding all triangles of the world with which the scene node may collide.  <a href="#a42aa84d4843a734f8dd1f20b5c92ef06">More...</a><br /></td></tr>
<tr class="separator:a42aa84d4843a734f8dd1f20b5c92ef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e106171ca57a4877d7a6f0edd9762f"><td class="memItemLeft" align="right" valign="top"><a id="a58e106171ca57a4877d7a6f0edd9762f"></a>
virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a58e106171ca57a4877d7a6f0edd9762f">getWorld</a> () const =0</td></tr>
<tr class="memdesc:a58e106171ca57a4877d7a6f0edd9762f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current triangle selector containing all triangles for collision detection. <br /></td></tr>
<tr class="separator:a58e106171ca57a4877d7a6f0edd9762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b291ba9249c451779f76ab2154aa3c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a5b291ba9249c451779f76ab2154aa3c2">setTargetNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a5b291ba9249c451779f76ab2154aa3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the single node that this animator will act on.  <a href="#a5b291ba9249c451779f76ab2154aa3c2">More...</a><br /></td></tr>
<tr class="separator:a5b291ba9249c451779f76ab2154aa3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a11b1c54ec705f4ba8b0bb3facb0f09cb">getTargetNode</a> (void) const =0</td></tr>
<tr class="memdesc:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the single node that this animator is acting on.  <a href="#a11b1c54ec705f4ba8b0bb3facb0f09cb">More...</a><br /></td></tr>
<tr class="separator:a11b1c54ec705f4ba8b0bb3facb0f09cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb04bc4d7de2203879a8392d024f466"><td class="memItemLeft" align="right" valign="top"><a id="a8bb04bc4d7de2203879a8392d024f466"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a8bb04bc4d7de2203879a8392d024f466">collisionOccurred</a> () const =0</td></tr>
<tr class="memdesc:a8bb04bc4d7de2203879a8392d024f466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a collision occurred during the last <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84" title="Animates a scene node. ">animateNode()</a> <br /></td></tr>
<tr class="separator:a8bb04bc4d7de2203879a8392d024f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb39b68d18f721960ac73dc158968479"><td class="memItemLeft" align="right" valign="top"><a id="acb39b68d18f721960ac73dc158968479"></a>
virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#acb39b68d18f721960ac73dc158968479">getCollisionPoint</a> () const =0</td></tr>
<tr class="memdesc:acb39b68d18f721960ac73dc158968479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last point of collision. <br /></td></tr>
<tr class="separator:acb39b68d18f721960ac73dc158968479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d0576446a64e9944ef15a04722591"><td class="memItemLeft" align="right" valign="top"><a id="abb9d0576446a64e9944ef15a04722591"></a>
virtual const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#abb9d0576446a64e9944ef15a04722591">getCollisionTriangle</a> () const =0</td></tr>
<tr class="memdesc:abb9d0576446a64e9944ef15a04722591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last triangle that caused a collision. <br /></td></tr>
<tr class="separator:abb9d0576446a64e9944ef15a04722591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788542083dda874c63e278891535a9f4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a788542083dda874c63e278891535a9f4">getCollisionResultPosition</a> (void) const =0</td></tr>
<tr class="memdesc:a788542083dda874c63e278891535a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position that the target node will be moved to, unless the collision is consumed in a callback.  <a href="#a788542083dda874c63e278891535a9f4">More...</a><br /></td></tr>
<tr class="separator:a788542083dda874c63e278891535a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="memItemLeft" align="right" valign="top"><a id="a5a975ddf3d776d6bb4c6d44c36cc74fd"></a>
virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a5a975ddf3d776d6bb4c6d44c36cc74fd">getCollisionNode</a> (void) const =0</td></tr>
<tr class="memdesc:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node that was collided with. <br /></td></tr>
<tr class="separator:a5a975ddf3d776d6bb4c6d44c36cc74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b97f977b446200c5dd22230aec5d275"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a2b97f977b446200c5dd22230aec5d275">setCollisionCallback</a> (<a class="el" href="classirr_1_1scene_1_1ICollisionCallback.html">ICollisionCallback</a> *callback)=0</td></tr>
<tr class="memdesc:a2b97f977b446200c5dd22230aec5d275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback interface which will be called if a collision occurs.  <a href="#a2b97f977b446200c5dd22230aec5d275">More...</a><br /></td></tr>
<tr class="separator:a2b97f977b446200c5dd22230aec5d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">irr::scene::ISceneNodeAnimator</a></td></tr>
<tr class="memitem:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84">animateNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeMs)=0</td></tr>
<tr class="memdesc:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Animates a scene node.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84">More...</a><br /></td></tr>
<tr class="separator:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a9cc261c12459fc7d3da6c2595d721c0d">createClone</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager=0)=0</td></tr>
<tr class="memdesc:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this animator.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a9cc261c12459fc7d3da6c2595d721c0d">More...</a><br /></td></tr>
<tr class="separator:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a37b22b8767dc6adca575223f02458740">isEventReceiverEnabled</a> () const</td></tr>
<tr class="memdesc:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this animator receives events.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a37b22b8767dc6adca575223f02458740">More...</a><br /></td></tr>
<tr class="separator:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top"><a id="aca20b841bb586cd9654464b001a7b6aa"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#aca20b841bb586cd9654464b001a7b6aa">OnEvent</a> (const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;event)</td></tr>
<tr class="memdesc:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event receiver, override this function for camera controlling animators. <br /></td></tr>
<tr class="separator:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top"><a id="a8d00cd0bc44945c617c0b8fa5c6ddcd5"></a>
virtual <a class="el" href="namespaceirr_1_1scene.html#a327a1e43872705cf8f3f3342fb307d19">ESCENE_NODE_ANIMATOR_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a8d00cd0bc44945c617c0b8fa5c6ddcd5">getType</a> () const</td></tr>
<tr class="memdesc:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node animator. <br /></td></tr>
<tr class="separator:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a77fd626155079b11327f0bd775e85425">hasFinished</a> (void) const</td></tr>
<tr class="memdesc:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the animator has finished.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a77fd626155079b11327f0bd775e85425">More...</a><br /></td></tr>
<tr class="separator:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84">animateNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeMs)=0</td></tr>
<tr class="memdesc:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Animates a scene node.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#ab2170d133db16de148d0f6841c06bc84">More...</a><br /></td></tr>
<tr class="separator:ab2170d133db16de148d0f6841c06bc84 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a9cc261c12459fc7d3da6c2595d721c0d">createClone</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager=0)=0</td></tr>
<tr class="memdesc:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this animator.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a9cc261c12459fc7d3da6c2595d721c0d">More...</a><br /></td></tr>
<tr class="separator:a9cc261c12459fc7d3da6c2595d721c0d inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a37b22b8767dc6adca575223f02458740">isEventReceiverEnabled</a> () const</td></tr>
<tr class="memdesc:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this animator receives events.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a37b22b8767dc6adca575223f02458740">More...</a><br /></td></tr>
<tr class="separator:a37b22b8767dc6adca575223f02458740 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top"><a id="aca20b841bb586cd9654464b001a7b6aa"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#aca20b841bb586cd9654464b001a7b6aa">OnEvent</a> (const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;event)</td></tr>
<tr class="memdesc:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event receiver, override this function for camera controlling animators. <br /></td></tr>
<tr class="separator:aca20b841bb586cd9654464b001a7b6aa inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top"><a id="a8d00cd0bc44945c617c0b8fa5c6ddcd5"></a>
virtual <a class="el" href="namespaceirr_1_1scene.html#a327a1e43872705cf8f3f3342fb307d19">ESCENE_NODE_ANIMATOR_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a8d00cd0bc44945c617c0b8fa5c6ddcd5">getType</a> () const</td></tr>
<tr class="memdesc:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node animator. <br /></td></tr>
<tr class="separator:a8d00cd0bc44945c617c0b8fa5c6ddcd5 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a77fd626155079b11327f0bd775e85425">hasFinished</a> (void) const</td></tr>
<tr class="memdesc:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the animator has finished.  <a href="classirr_1_1scene_1_1ISceneNodeAnimator.html#a77fd626155079b11327f0bd775e85425">More...</a><br /></td></tr>
<tr class="separator:a77fd626155079b11327f0bd775e85425 inherit pub_methods_classirr_1_1scene_1_1ISceneNodeAnimator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1io_1_1IAttributeExchangingObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html">irr::io::IAttributeExchangingObject</a></td></tr>
<tr class="memitem:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">serializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *out, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0) const</td></tr>
<tr class="memdesc:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the object.  <a href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">More...</a><br /></td></tr>
<tr class="separator:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">deserializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *in, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)</td></tr>
<tr class="memdesc:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the object.  <a href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">More...</a><br /></td></tr>
<tr class="separator:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">serializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *out, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0) const</td></tr>
<tr class="memdesc:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the object.  <a href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">More...</a><br /></td></tr>
<tr class="separator:a587f7b633366968f0488e1099e9172ef inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">deserializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *in, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)</td></tr>
<tr class="memdesc:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the object.  <a href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">More...</a><br /></td></tr>
<tr class="separator:a013d4ead3736d7fab4bc18c2d61a3e2e inherit pub_methods_classirr_1_1io_1_1IAttributeExchangingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IEventReceiver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IEventReceiver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IEventReceiver.html">irr::IEventReceiver</a></td></tr>
<tr class="memitem:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="memItemLeft" align="right" valign="top"><a id="a4ec011612f02017d95654cf5b5d567b6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IEventReceiver.html#a4ec011612f02017d95654cf5b5d567b6">~IEventReceiver</a> ()</td></tr>
<tr class="memdesc:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="memItemLeft" align="right" valign="top"><a id="a4ec011612f02017d95654cf5b5d567b6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IEventReceiver.html#a4ec011612f02017d95654cf5b5d567b6">~IEventReceiver</a> ()</td></tr>
<tr class="memdesc:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a4ec011612f02017d95654cf5b5d567b6 inherit pub_methods_classirr_1_1IEventReceiver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Special scene node animator for doing automatic collision detection and response. </p>
<p>This scene node animator can be attached to any single scene node and will then prevent it from moving through specified collision geometry (e.g. walls and floors of the) world, as well as having it fall under gravity. This animator provides a simple implementation of first person shooter cameras. Attach it to a camera, and the camera will behave as the player control in a first person shooter game: The camera stops and slides at walls, walks up stairs, falls down if there is no floor under it, and so on.</p>
<p>The animator will treat any change in the position of its target scene node as movement, including a setPosition(), as movement. If you want to teleport the target scene node manually to a location without it being effected by collision geometry, then call setTargetNode(node) after calling node-&gt;setPosition(). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a788542083dda874c63e278891535a9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788542083dda874c63e278891535a9f4">&#9670;&nbsp;</a></span>getCollisionResultPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNodeAnimatorCollisionResponse::getCollisionResultPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position that the target node will be moved to, unless the collision is consumed in a callback. </p>
<p>If you have a collision callback registered, and it consumes the collision, then the node will ignore the collision and will not stop at this position. Instead, it will move fully to the position that caused the collision to occur. </p>

</div>
</div>
<a id="a788542083dda874c63e278891535a9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788542083dda874c63e278891535a9f4">&#9670;&nbsp;</a></span>getCollisionResultPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNodeAnimatorCollisionResponse::getCollisionResultPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position that the target node will be moved to, unless the collision is consumed in a callback. </p>
<p>If you have a collision callback registered, and it consumes the collision, then the node will ignore the collision and will not stop at this position. Instead, it will move fully to the position that caused the collision to occur. </p>

</div>
</div>
<a id="a92965919db3dfbaab2d1f4987a2c52c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92965919db3dfbaab2d1f4987a2c52c1">&#9670;&nbsp;</a></span>getEllipsoidRadius() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getEllipsoidRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radius of the ellipsoid for collision detection and response. </p>
<dl class="section return"><dt>Returns</dt><dd>Radius of the ellipsoid. </dd></dl>

</div>
</div>
<a id="a92965919db3dfbaab2d1f4987a2c52c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92965919db3dfbaab2d1f4987a2c52c1">&#9670;&nbsp;</a></span>getEllipsoidRadius() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getEllipsoidRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radius of the ellipsoid for collision detection and response. </p>
<dl class="section return"><dt>Returns</dt><dd>Radius of the ellipsoid. </dd></dl>

</div>
</div>
<a id="aff0a2ad6ff375a85e08a3226e3267286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0a2ad6ff375a85e08a3226e3267286">&#9670;&nbsp;</a></span>getEllipsoidTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getEllipsoidTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the translation of the ellipsoid for collision detection. </p>
<p>See <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a234ec747d320d70dd3e2a4143782ffc7" title="Set translation of the collision ellipsoid. ">ISceneNodeAnimatorCollisionResponse::setEllipsoidTranslation()</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>Translation of the ellipsoid relative to the position of the scene node. </dd></dl>

</div>
</div>
<a id="aff0a2ad6ff375a85e08a3226e3267286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0a2ad6ff375a85e08a3226e3267286">&#9670;&nbsp;</a></span>getEllipsoidTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getEllipsoidTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the translation of the ellipsoid for collision detection. </p>
<p>See <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorCollisionResponse.html#a234ec747d320d70dd3e2a4143782ffc7" title="Set translation of the collision ellipsoid. ">ISceneNodeAnimatorCollisionResponse::setEllipsoidTranslation()</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>Translation of the ellipsoid relative to the position of the scene node. </dd></dl>

</div>
</div>
<a id="a1b7c86e8948691ce00f2aa6253c5683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c86e8948691ce00f2aa6253c5683a">&#9670;&nbsp;</a></span>getGravity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getGravity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current vector of gravity. </p>
<dl class="section return"><dt>Returns</dt><dd>Gravity vector. */ </dd></dl>

</div>
</div>
<a id="a1b7c86e8948691ce00f2aa6253c5683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c86e8948691ce00f2aa6253c5683a">&#9670;&nbsp;</a></span>getGravity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNodeAnimatorCollisionResponse::getGravity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current vector of gravity. </p>
<dl class="section return"><dt>Returns</dt><dd>Gravity vector. */ </dd></dl>

</div>
</div>
<a id="a11b1c54ec705f4ba8b0bb3facb0f09cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b1c54ec705f4ba8b0bb3facb0f09cb">&#9670;&nbsp;</a></span>getTargetNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneNodeAnimatorCollisionResponse::getTargetNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the single node that this animator is acting on. </p>
<dl class="section return"><dt>Returns</dt><dd>The node that this animator is acting on. </dd></dl>

</div>
</div>
<a id="a11b1c54ec705f4ba8b0bb3facb0f09cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b1c54ec705f4ba8b0bb3facb0f09cb">&#9670;&nbsp;</a></span>getTargetNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneNodeAnimatorCollisionResponse::getTargetNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the single node that this animator is acting on. </p>
<dl class="section return"><dt>Returns</dt><dd>The node that this animator is acting on. </dd></dl>

</div>
</div>
<a id="a66f5534c1d2ac0e2ea52e7b21a3c91d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f5534c1d2ac0e2ea52e7b21a3c91d7">&#9670;&nbsp;</a></span>isFalling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNodeAnimatorCollisionResponse::isFalling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the attached scene node is falling. </p>
<p>Falling means that there is no blocking wall from the scene node in the direction of the gravity. The implementation of this method is very fast, no collision detection is done when invoking it. </p><dl class="section return"><dt>Returns</dt><dd>True if the scene node is falling, false if not. </dd></dl>

</div>
</div>
<a id="a66f5534c1d2ac0e2ea52e7b21a3c91d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f5534c1d2ac0e2ea52e7b21a3c91d7">&#9670;&nbsp;</a></span>isFalling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNodeAnimatorCollisionResponse::isFalling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the attached scene node is falling. </p>
<p>Falling means that there is no blocking wall from the scene node in the direction of the gravity. The implementation of this method is very fast, no collision detection is done when invoking it. </p><dl class="section return"><dt>Returns</dt><dd>True if the scene node is falling, false if not. </dd></dl>

</div>
</div>
<a id="a409b98d04be89fb06cce3384e0188abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409b98d04be89fb06cce3384e0188abf">&#9670;&nbsp;</a></span>jump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::jump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>jumpSpeed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Jump' the animator, by adding a jump speed opposite to its gravity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumpSpeed</td><td>The initial speed of the jump; the velocity will be opposite to this animator's gravity vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409b98d04be89fb06cce3384e0188abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409b98d04be89fb06cce3384e0188abf">&#9670;&nbsp;</a></span>jump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::jump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>jumpSpeed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Jump' the animator, by adding a jump speed opposite to its gravity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumpSpeed</td><td>The initial speed of the jump; the velocity will be opposite to this animator's gravity vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b97f977b446200c5dd22230aec5d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b97f977b446200c5dd22230aec5d275">&#9670;&nbsp;</a></span>setCollisionCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setCollisionCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ICollisionCallback.html">ICollisionCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a callback interface which will be called if a collision occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>collision callback handler that will be called when a collision occurs. Set this to 0 to disable the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b97f977b446200c5dd22230aec5d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b97f977b446200c5dd22230aec5d275">&#9670;&nbsp;</a></span>setCollisionCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setCollisionCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ICollisionCallback.html">ICollisionCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a callback interface which will be called if a collision occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>collision callback handler that will be called when a collision occurs. Set this to 0 to disable the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71af73590016ba936340a79467690d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71af73590016ba936340a79467690d3f">&#9670;&nbsp;</a></span>setEllipsoidRadius() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setEllipsoidRadius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the radius of the ellipsoid for collision detection and response. </p>
<p>If you have a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it: </p><div class="fragment"><div class="line">core::aabbox&lt;f32&gt; box = yourSceneNode-&gt;getBoundingBox();</div><div class="line"><a class="code" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> radius = box.MaxEdge - box.getCenter();</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>New radius of the ellipsoid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71af73590016ba936340a79467690d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71af73590016ba936340a79467690d3f">&#9670;&nbsp;</a></span>setEllipsoidRadius() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setEllipsoidRadius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the radius of the ellipsoid for collision detection and response. </p>
<p>If you have a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it: </p><div class="fragment"><div class="line">core::aabbox&lt;f32&gt; box = yourSceneNode-&gt;getBoundingBox();</div><div class="line"><a class="code" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> radius = box.MaxEdge - box.getCenter();</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>New radius of the ellipsoid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a234ec747d320d70dd3e2a4143782ffc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234ec747d320d70dd3e2a4143782ffc7">&#9670;&nbsp;</a></span>setEllipsoidTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setEllipsoidTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set translation of the collision ellipsoid. </p>
<p>By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>Translation of the ellipsoid relative to the position of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a234ec747d320d70dd3e2a4143782ffc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234ec747d320d70dd3e2a4143782ffc7">&#9670;&nbsp;</a></span>setEllipsoidTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setEllipsoidTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set translation of the collision ellipsoid. </p>
<p>By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>Translation of the ellipsoid relative to the position of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af366695a82153c144b58c65cb4d092f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af366695a82153c144b58c65cb4d092f3">&#9670;&nbsp;</a></span>setGravity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setGravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>gravity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gravity of the environment. </p>
<p>A good example value would be <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b" title="Typedef for a f32 3d vector. ">core::vector3df</a>(0,-100.0f,0) for letting gravity affect all object to fall down. For bigger gravity, make increase the length of the vector. You can disable gravity by setting it to core::vector3df(0,0,0); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gravity</td><td>New gravity vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af366695a82153c144b58c65cb4d092f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af366695a82153c144b58c65cb4d092f3">&#9670;&nbsp;</a></span>setGravity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setGravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>gravity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gravity of the environment. </p>
<p>A good example value would be <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b" title="Typedef for a f32 3d vector. ">core::vector3df</a>(0,-100.0f,0) for letting gravity affect all object to fall down. For bigger gravity, make increase the length of the vector. You can disable gravity by setting it to core::vector3df(0,0,0); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gravity</td><td>New gravity vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b291ba9249c451779f76ab2154aa3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b291ba9249c451779f76ab2154aa3c2">&#9670;&nbsp;</a></span>setTargetNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setTargetNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the single node that this animator will act on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The new target node. Setting this will force the animator to update its last target position for the node, allowing setPosition() to teleport the node through collision geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b291ba9249c451779f76ab2154aa3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b291ba9249c451779f76ab2154aa3c2">&#9670;&nbsp;</a></span>setTargetNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setTargetNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the single node that this animator will act on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The new target node. Setting this will force the animator to update its last target position for the node, allowing setPosition() to teleport the node through collision geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42aa84d4843a734f8dd1f20b5c92ef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42aa84d4843a734f8dd1f20b5c92ef06">&#9670;&nbsp;</a></span>setWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>newWorld</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a triangle selector holding all triangles of the world with which the scene node may collide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWorld</td><td>New triangle selector containing triangles to let the scene node collide with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42aa84d4843a734f8dd1f20b5c92ef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42aa84d4843a734f8dd1f20b5c92ef06">&#9670;&nbsp;</a></span>setWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNodeAnimatorCollisionResponse::setWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>newWorld</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a triangle selector holding all triangles of the world with which the scene node may collide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWorld</td><td>New triangle selector containing triangles to let the scene node collide with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>indie_share/controller/include/<a class="el" href="indie__share_2controller_2include_2ISceneNodeAnimatorCollisionResponse_8h_source.html">ISceneNodeAnimatorCollisionResponse.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
