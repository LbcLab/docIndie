<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Indie Studio: irr::core::map&lt; KeyType, ValueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Indie Studio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classirr_1_1core_1_1map.html">map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1core_1_1map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::core::map&lt; KeyType, ValueType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>map template for associative arrays using a red-black tree  
 <a href="classirr_1_1core_1_1map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indie__share_2controller_2include_2irrMap_8h_source.html">irrMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map_1_1ConstIterator.html">ConstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const <a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html" title="Normal Iterator. ">Iterator</a>.  <a href="classirr_1_1core_1_1map_1_1ConstIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal <a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html" title="Normal Iterator. ">Iterator</a>.  <a href="classirr_1_1core_1_1map_1_1Iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html">ParentFirstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent First <a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html" title="Normal Iterator. ">Iterator</a>.  <a href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map_1_1ParentLastIterator.html">ParentLastIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent Last <a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html" title="Normal Iterator. ">Iterator</a>.  <a href="classirr_1_1core_1_1map_1_1ParentLastIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#af9f8f34cab620e3bdc1ae72715ab9d15">insert</a> (const KeyType &amp;keyNew, const ValueType &amp;v)</td></tr>
<tr class="memdesc:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node into the tree.  <a href="#af9f8f34cab620e3bdc1ae72715ab9d15">More...</a><br /></td></tr>
<tr class="separator:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31213e9478dd259bdd79c7fd3249584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ae31213e9478dd259bdd79c7fd3249584">set</a> (const KeyType &amp;k, const ValueType &amp;v)</td></tr>
<tr class="memdesc:ae31213e9478dd259bdd79c7fd3249584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value if the key already exists, otherwise inserts a new element.  <a href="#ae31213e9478dd259bdd79c7fd3249584">More...</a><br /></td></tr>
<tr class="separator:ae31213e9478dd259bdd79c7fd3249584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95533c709ef2dbe17148442aa26984"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a6f95533c709ef2dbe17148442aa26984">delink</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a6f95533c709ef2dbe17148442aa26984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and returns it.  <a href="#a6f95533c709ef2dbe17148442aa26984">More...</a><br /></td></tr>
<tr class="separator:a6f95533c709ef2dbe17148442aa26984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a83d8a6261249668ae6a0f2bbd6e84c26">remove</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and deletes it.  <a href="#a83d8a6261249668ae6a0f2bbd6e84c26">More...</a><br /></td></tr>
<tr class="separator:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ee85b87b3764be03d78ba696e75f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a8f8ee85b87b3764be03d78ba696e75f2">remove</a> (Node *p)</td></tr>
<tr class="memdesc:a8f8ee85b87b3764be03d78ba696e75f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and deletes it.  <a href="#a8f8ee85b87b3764be03d78ba696e75f2">More...</a><br /></td></tr>
<tr class="separator:a8f8ee85b87b3764be03d78ba696e75f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="memItemLeft" align="right" valign="top"><a id="a0f7e7fdbb5ec7794851e32c9716dace0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a0f7e7fdbb5ec7794851e32c9716dace0">clear</a> ()</td></tr>
<tr class="memdesc:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire tree. <br /></td></tr>
<tr class="separator:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253070a62165cc9881cc75bc774f7034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a253070a62165cc9881cc75bc774f7034">empty</a> () const</td></tr>
<tr class="memdesc:a253070a62165cc9881cc75bc774f7034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the tree empty?  <a href="#a253070a62165cc9881cc75bc774f7034">More...</a><br /></td></tr>
<tr class="separator:a253070a62165cc9881cc75bc774f7034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b309f8737e2aca9668e32c71f05ed"><td class="memItemLeft" align="right" valign="top">_IRR_DEPRECATED_ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a2a5b309f8737e2aca9668e32c71f05ed">isEmpty</a> () const</td></tr>
<tr class="separator:a2a5b309f8737e2aca9668e32c71f05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a62579dceda1da7605ee78bca3e318"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ad6a62579dceda1da7605ee78bca3e318">find</a> (const KeyType &amp;keyToFind) const</td></tr>
<tr class="memdesc:ad6a62579dceda1da7605ee78bca3e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a node with the specified key.  <a href="#ad6a62579dceda1da7605ee78bca3e318">More...</a><br /></td></tr>
<tr class="separator:ad6a62579dceda1da7605ee78bca3e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6666acf9724e2e20cd338a6a5ff66c65"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a6666acf9724e2e20cd338a6a5ff66c65">getRoot</a> () const</td></tr>
<tr class="memdesc:a6666acf9724e2e20cd338a6a5ff66c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root element.  <a href="#a6666acf9724e2e20cd338a6a5ff66c65">More...</a><br /></td></tr>
<tr class="separator:a6666acf9724e2e20cd338a6a5ff66c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="memItemLeft" align="right" valign="top"><a id="aa4d56d82c7fe2a72327f91f2f6c92465"></a>
<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#aa4d56d82c7fe2a72327f91f2f6c92465">size</a> () const</td></tr>
<tr class="memdesc:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the tree. <br /></td></tr>
<tr class="separator:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411cde5df191c16616e20eb7027b9a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a411cde5df191c16616e20eb7027b9a20">swap</a> (<a class="el" href="classirr_1_1core_1_1map.html">map</a>&lt; KeyType, ValueType &gt; &amp;other)</td></tr>
<tr class="memdesc:a411cde5df191c16616e20eb7027b9a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the content of this map container with the content of another map.  <a href="#a411cde5df191c16616e20eb7027b9a20">More...</a><br /></td></tr>
<tr class="separator:a411cde5df191c16616e20eb7027b9a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c4970e278272eaf28f010d8b82a4dc"><td class="memItemLeft" align="right" valign="top"><a id="ac5c4970e278272eaf28f010d8b82a4dc"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ac5c4970e278272eaf28f010d8b82a4dc">getIterator</a> () const</td></tr>
<tr class="memdesc:ac5c4970e278272eaf28f010d8b82a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator. <br /></td></tr>
<tr class="separator:ac5c4970e278272eaf28f010d8b82a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad187f7170dd13dfa6d182b478c92942a"><td class="memItemLeft" align="right" valign="top"><a id="ad187f7170dd13dfa6d182b478c92942a"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ad187f7170dd13dfa6d182b478c92942a">getConstIterator</a> () const</td></tr>
<tr class="memdesc:ad187f7170dd13dfa6d182b478c92942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Constiterator. <br /></td></tr>
<tr class="separator:ad187f7170dd13dfa6d182b478c92942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55db71cb9dca4272fd8f99e5a045de"><td class="memItemLeft" align="right" valign="top"><a id="a3c55db71cb9dca4272fd8f99e5a045de"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html">ParentFirstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a3c55db71cb9dca4272fd8f99e5a045de">getParentFirstIterator</a> () const</td></tr>
<tr class="memdesc:a3c55db71cb9dca4272fd8f99e5a045de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html" title="Parent First Iterator. ">ParentFirstIterator</a>. Traverses the tree from top to bottom. Typical usage is when storing the tree structure, because when reading it later (and inserting elements) the tree structure will be the same. <br /></td></tr>
<tr class="separator:a3c55db71cb9dca4272fd8f99e5a045de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="memItemLeft" align="right" valign="top"><a id="a36bb25e9cf8b1d13cd0b5cc2301e1130"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ParentLastIterator.html">ParentLastIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a36bb25e9cf8b1d13cd0b5cc2301e1130">getParentLastIterator</a> () const</td></tr>
<tr class="memdesc:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classirr_1_1core_1_1map_1_1ParentLastIterator.html" title="Parent Last Iterator. ">ParentLastIterator</a> to traverse the tree from bottom to top. Typical usage is when deleting all elements in the tree because you must delete the children before you delete their parent. <br /></td></tr>
<tr class="separator:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b601a40d70eb34aa6571e29f55992"><td class="memItemLeft" align="right" valign="top">AccessClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a396b601a40d70eb34aa6571e29f55992">operator[]</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a396b601a40d70eb34aa6571e29f55992"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator [] for access to elements  <a href="#a396b601a40d70eb34aa6571e29f55992">More...</a><br /></td></tr>
<tr class="separator:a396b601a40d70eb34aa6571e29f55992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#af9f8f34cab620e3bdc1ae72715ab9d15">insert</a> (const KeyType &amp;keyNew, const ValueType &amp;v)</td></tr>
<tr class="memdesc:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node into the tree.  <a href="#af9f8f34cab620e3bdc1ae72715ab9d15">More...</a><br /></td></tr>
<tr class="separator:af9f8f34cab620e3bdc1ae72715ab9d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31213e9478dd259bdd79c7fd3249584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ae31213e9478dd259bdd79c7fd3249584">set</a> (const KeyType &amp;k, const ValueType &amp;v)</td></tr>
<tr class="memdesc:ae31213e9478dd259bdd79c7fd3249584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value if the key already exists, otherwise inserts a new element.  <a href="#ae31213e9478dd259bdd79c7fd3249584">More...</a><br /></td></tr>
<tr class="separator:ae31213e9478dd259bdd79c7fd3249584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95533c709ef2dbe17148442aa26984"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a6f95533c709ef2dbe17148442aa26984">delink</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a6f95533c709ef2dbe17148442aa26984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and returns it.  <a href="#a6f95533c709ef2dbe17148442aa26984">More...</a><br /></td></tr>
<tr class="separator:a6f95533c709ef2dbe17148442aa26984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a83d8a6261249668ae6a0f2bbd6e84c26">remove</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and deletes it.  <a href="#a83d8a6261249668ae6a0f2bbd6e84c26">More...</a><br /></td></tr>
<tr class="separator:a83d8a6261249668ae6a0f2bbd6e84c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ee85b87b3764be03d78ba696e75f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a8f8ee85b87b3764be03d78ba696e75f2">remove</a> (Node *p)</td></tr>
<tr class="memdesc:a8f8ee85b87b3764be03d78ba696e75f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the tree and deletes it.  <a href="#a8f8ee85b87b3764be03d78ba696e75f2">More...</a><br /></td></tr>
<tr class="separator:a8f8ee85b87b3764be03d78ba696e75f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="memItemLeft" align="right" valign="top"><a id="a0f7e7fdbb5ec7794851e32c9716dace0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a0f7e7fdbb5ec7794851e32c9716dace0">clear</a> ()</td></tr>
<tr class="memdesc:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire tree. <br /></td></tr>
<tr class="separator:a0f7e7fdbb5ec7794851e32c9716dace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253070a62165cc9881cc75bc774f7034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a253070a62165cc9881cc75bc774f7034">empty</a> () const</td></tr>
<tr class="memdesc:a253070a62165cc9881cc75bc774f7034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the tree empty?  <a href="#a253070a62165cc9881cc75bc774f7034">More...</a><br /></td></tr>
<tr class="separator:a253070a62165cc9881cc75bc774f7034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b309f8737e2aca9668e32c71f05ed"><td class="memItemLeft" align="right" valign="top">_IRR_DEPRECATED_ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a2a5b309f8737e2aca9668e32c71f05ed">isEmpty</a> () const</td></tr>
<tr class="separator:a2a5b309f8737e2aca9668e32c71f05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a62579dceda1da7605ee78bca3e318"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ad6a62579dceda1da7605ee78bca3e318">find</a> (const KeyType &amp;keyToFind) const</td></tr>
<tr class="memdesc:ad6a62579dceda1da7605ee78bca3e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a node with the specified key.  <a href="#ad6a62579dceda1da7605ee78bca3e318">More...</a><br /></td></tr>
<tr class="separator:ad6a62579dceda1da7605ee78bca3e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6666acf9724e2e20cd338a6a5ff66c65"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a6666acf9724e2e20cd338a6a5ff66c65">getRoot</a> () const</td></tr>
<tr class="memdesc:a6666acf9724e2e20cd338a6a5ff66c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root element.  <a href="#a6666acf9724e2e20cd338a6a5ff66c65">More...</a><br /></td></tr>
<tr class="separator:a6666acf9724e2e20cd338a6a5ff66c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="memItemLeft" align="right" valign="top"><a id="aa4d56d82c7fe2a72327f91f2f6c92465"></a>
<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#aa4d56d82c7fe2a72327f91f2f6c92465">size</a> () const</td></tr>
<tr class="memdesc:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the tree. <br /></td></tr>
<tr class="separator:aa4d56d82c7fe2a72327f91f2f6c92465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411cde5df191c16616e20eb7027b9a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a411cde5df191c16616e20eb7027b9a20">swap</a> (<a class="el" href="classirr_1_1core_1_1map.html">map</a>&lt; KeyType, ValueType &gt; &amp;other)</td></tr>
<tr class="memdesc:a411cde5df191c16616e20eb7027b9a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the content of this map container with the content of another map.  <a href="#a411cde5df191c16616e20eb7027b9a20">More...</a><br /></td></tr>
<tr class="separator:a411cde5df191c16616e20eb7027b9a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c4970e278272eaf28f010d8b82a4dc"><td class="memItemLeft" align="right" valign="top"><a id="ac5c4970e278272eaf28f010d8b82a4dc"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ac5c4970e278272eaf28f010d8b82a4dc">getIterator</a> () const</td></tr>
<tr class="memdesc:ac5c4970e278272eaf28f010d8b82a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator. <br /></td></tr>
<tr class="separator:ac5c4970e278272eaf28f010d8b82a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad187f7170dd13dfa6d182b478c92942a"><td class="memItemLeft" align="right" valign="top"><a id="ad187f7170dd13dfa6d182b478c92942a"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#ad187f7170dd13dfa6d182b478c92942a">getConstIterator</a> () const</td></tr>
<tr class="memdesc:ad187f7170dd13dfa6d182b478c92942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Constiterator. <br /></td></tr>
<tr class="separator:ad187f7170dd13dfa6d182b478c92942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55db71cb9dca4272fd8f99e5a045de"><td class="memItemLeft" align="right" valign="top"><a id="a3c55db71cb9dca4272fd8f99e5a045de"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html">ParentFirstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a3c55db71cb9dca4272fd8f99e5a045de">getParentFirstIterator</a> () const</td></tr>
<tr class="memdesc:a3c55db71cb9dca4272fd8f99e5a045de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classirr_1_1core_1_1map_1_1ParentFirstIterator.html" title="Parent First Iterator. ">ParentFirstIterator</a>. Traverses the tree from top to bottom. Typical usage is when storing the tree structure, because when reading it later (and inserting elements) the tree structure will be the same. <br /></td></tr>
<tr class="separator:a3c55db71cb9dca4272fd8f99e5a045de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="memItemLeft" align="right" valign="top"><a id="a36bb25e9cf8b1d13cd0b5cc2301e1130"></a>
<a class="el" href="classirr_1_1core_1_1map_1_1ParentLastIterator.html">ParentLastIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a36bb25e9cf8b1d13cd0b5cc2301e1130">getParentLastIterator</a> () const</td></tr>
<tr class="memdesc:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classirr_1_1core_1_1map_1_1ParentLastIterator.html" title="Parent Last Iterator. ">ParentLastIterator</a> to traverse the tree from bottom to top. Typical usage is when deleting all elements in the tree because you must delete the children before you delete their parent. <br /></td></tr>
<tr class="separator:a36bb25e9cf8b1d13cd0b5cc2301e1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b601a40d70eb34aa6571e29f55992"><td class="memItemLeft" align="right" valign="top">AccessClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1map.html#a396b601a40d70eb34aa6571e29f55992">operator[]</a> (const KeyType &amp;k)</td></tr>
<tr class="memdesc:a396b601a40d70eb34aa6571e29f55992"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator [] for access to elements  <a href="#a396b601a40d70eb34aa6571e29f55992">More...</a><br /></td></tr>
<tr class="separator:a396b601a40d70eb34aa6571e29f55992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class KeyType, class ValueType&gt;<br />
class irr::core::map&lt; KeyType, ValueType &gt;</h3>

<p>map template for associative arrays using a red-black tree </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6f95533c709ef2dbe17148442aa26984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f95533c709ef2dbe17148442aa26984">&#9670;&nbsp;</a></span>delink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::delink </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and returns it. </p>
<p>The returned node must be deleted by the user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node, or 0 if not found </dd></dl>

</div>
</div>
<a id="a6f95533c709ef2dbe17148442aa26984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f95533c709ef2dbe17148442aa26984">&#9670;&nbsp;</a></span>delink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::delink </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and returns it. </p>
<p>The returned node must be deleted by the user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node, or 0 if not found </dd></dl>

</div>
</div>
<a id="a253070a62165cc9881cc75bc774f7034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253070a62165cc9881cc75bc774f7034">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the tree empty? </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if empty, false if not </dd></dl>

</div>
</div>
<a id="a253070a62165cc9881cc75bc774f7034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253070a62165cc9881cc75bc774f7034">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the tree empty? </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if empty, false if not </dd></dl>

</div>
</div>
<a id="ad6a62579dceda1da7605ee78bca3e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a62579dceda1da7605ee78bca3e318">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyToFind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for a node with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyToFind</td><td>The key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if node couldn't be found. </dd></dl>

</div>
</div>
<a id="ad6a62579dceda1da7605ee78bca3e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a62579dceda1da7605ee78bca3e318">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyToFind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for a node with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyToFind</td><td>The key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if node couldn't be found. </dd></dl>

</div>
</div>
<a id="a6666acf9724e2e20cd338a6a5ff66c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6666acf9724e2e20cd338a6a5ff66c65">&#9670;&nbsp;</a></span>getRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the root element. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the root node, or 0 if the tree is empty. </dd></dl>

</div>
</div>
<a id="a6666acf9724e2e20cd338a6a5ff66c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6666acf9724e2e20cd338a6a5ff66c65">&#9670;&nbsp;</a></span>getRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node* <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the root element. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the root node, or 0 if the tree is empty. </dd></dl>

</div>
</div>
<a id="af9f8f34cab620e3bdc1ae72715ab9d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f8f34cab620e3bdc1ae72715ab9d15">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new node into the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyNew</td><td>the index for this value </td></tr>
    <tr><td class="paramname">v</td><td>the value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false if it fails (already exists) </dd></dl>

</div>
</div>
<a id="af9f8f34cab620e3bdc1ae72715ab9d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f8f34cab620e3bdc1ae72715ab9d15">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new node into the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyNew</td><td>the index for this value </td></tr>
    <tr><td class="paramname">v</td><td>the value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false if it fails (already exists) </dd></dl>

</div>
</div>
<a id="a2a5b309f8737e2aca9668e32c71f05ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b309f8737e2aca9668e32c71f05ed">&#9670;&nbsp;</a></span>isEmpty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_IRR_DEPRECATED_ bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use <a class="el" href="classirr_1_1core_1_1map.html#a253070a62165cc9881cc75bc774f7034" title="Is the tree empty? ">empty()</a> instead. This method may be removed by Irrlicht 1.9 </dd></dl>

</div>
</div>
<a id="a2a5b309f8737e2aca9668e32c71f05ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b309f8737e2aca9668e32c71f05ed">&#9670;&nbsp;</a></span>isEmpty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_IRR_DEPRECATED_ bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="classirr_1_1core_1_1map.html#a253070a62165cc9881cc75bc774f7034" title="Is the tree empty? ">empty()</a> instead. This method may be removed by Irrlicht 1.9 </dd></dl>

</div>
</div>
<a id="a396b601a40d70eb34aa6571e29f55992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396b601a40d70eb34aa6571e29f55992">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AccessClass <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator [] for access to elements </p>
<p>for example myMap["key"] </p>

</div>
</div>
<a id="a396b601a40d70eb34aa6571e29f55992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396b601a40d70eb34aa6571e29f55992">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AccessClass <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator [] for access to elements </p>
<p>for example myMap["key"] </p>

</div>
</div>
<a id="a83d8a6261249668ae6a0f2bbd6e84c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d8a6261249668ae6a0f2bbd6e84c26">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and deletes it. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node was found and deleted </dd></dl>

</div>
</div>
<a id="a83d8a6261249668ae6a0f2bbd6e84c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d8a6261249668ae6a0f2bbd6e84c26">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and deletes it. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node was found and deleted </dd></dl>

</div>
</div>
<a id="a8f8ee85b87b3764be03d78ba696e75f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ee85b87b3764be03d78ba696e75f2">&#9670;&nbsp;</a></span>remove() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">Node *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and deletes it. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node was found and deleted </dd></dl>

</div>
</div>
<a id="a8f8ee85b87b3764be03d78ba696e75f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ee85b87b3764be03d78ba696e75f2">&#9670;&nbsp;</a></span>remove() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">Node *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the tree and deletes it. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node was found and deleted </dd></dl>

</div>
</div>
<a id="ae31213e9478dd259bdd79c7fd3249584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31213e9478dd259bdd79c7fd3249584">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value if the key already exists, otherwise inserts a new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The index for this value </td></tr>
    <tr><td class="paramname">v</td><td>The new value of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31213e9478dd259bdd79c7fd3249584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31213e9478dd259bdd79c7fd3249584">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value if the key already exists, otherwise inserts a new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The index for this value </td></tr>
    <tr><td class="paramname">v</td><td>The new value of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a411cde5df191c16616e20eb7027b9a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411cde5df191c16616e20eb7027b9a20">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1map.html">map</a>&lt; KeyType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the content of this map container with the content of another map. </p>
<p>Afterwards this object will contain the content of the other object and the other object will contain the content of this object. Iterators will afterwards be valid for the swapped object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Swap content with this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a411cde5df191c16616e20eb7027b9a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411cde5df191c16616e20eb7027b9a20">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType, class ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1map.html">irr::core::map</a>&lt; KeyType, ValueType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1map.html">map</a>&lt; KeyType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the content of this map container with the content of another map. </p>
<p>Afterwards this object will contain the content of the other object and the other object will contain the content of this object. Iterators will afterwards be valid for the swapped object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Swap content with this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>indie_share/controller/include/<a class="el" href="indie__share_2controller_2include_2irrMap_8h_source.html">irrMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
