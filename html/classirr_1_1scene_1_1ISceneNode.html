<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Indie Studio: irr::scene::ISceneNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Indie Studio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1scene.html">scene</a></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classirr_1_1scene_1_1ISceneNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::ISceneNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Scene node interface.  
 <a href="classirr_1_1scene_1_1ISceneNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indie__share_2controller_2include_2ISceneNode_8h_source.html">ISceneNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::scene::ISceneNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1ISceneNode.png" usemap="#irr::scene::ISceneNode_map" alt=""/>
  <map id="irr::scene::ISceneNode_map" name="irr::scene::ISceneNode_map">
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="137,56,402,80"/>
<area href="classirr_1_1io_1_1IAttributeExchangingObject.html" title="An object which is able to serialize and deserialize its attributes into an attributes object..." alt="irr::io::IAttributeExchangingObject" shape="rect" coords="687,56,952,80"/>
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="0,0,265,24"/>
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="275,0,540,24"/>
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="550,0,815,24"/>
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="825,0,1090,24"/>
<area href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html" title="Scene node capable of displaying an animated mesh and its shadow. " alt="irr::scene::IAnimatedMeshSceneNode" shape="rect" coords="687,168,952,192"/>
<area href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html" title="Scene node capable of displaying an animated mesh and its shadow. " alt="irr::scene::IAnimatedMeshSceneNode" shape="rect" coords="687,224,952,248"/>
<area href="classirr_1_1scene_1_1IBillboardSceneNode.html" title="A billboard scene node. " alt="irr::scene::IBillboardSceneNode" shape="rect" coords="687,280,952,304"/>
<area href="classirr_1_1scene_1_1IBillboardSceneNode.html" title="A billboard scene node. " alt="irr::scene::IBillboardSceneNode" shape="rect" coords="687,336,952,360"/>
<area href="classirr_1_1scene_1_1IBoneSceneNode.html" title="Interface for bones used for skeletal animation. " alt="irr::scene::IBoneSceneNode" shape="rect" coords="687,392,952,416"/>
<area href="classirr_1_1scene_1_1IBoneSceneNode.html" title="Interface for bones used for skeletal animation. " alt="irr::scene::IBoneSceneNode" shape="rect" coords="687,448,952,472"/>
<area href="classirr_1_1scene_1_1ICameraSceneNode.html" title="Scene Node which is a (controlable) camera. " alt="irr::scene::ICameraSceneNode" shape="rect" coords="687,504,952,528"/>
<area href="classirr_1_1scene_1_1ICameraSceneNode.html" title="Scene Node which is a (controlable) camera. " alt="irr::scene::ICameraSceneNode" shape="rect" coords="687,560,952,584"/>
<area href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html" title="Dummy scene node for adding additional transformations to the scene graph. " alt="irr::scene::IDummyTransformationSceneNode" shape="rect" coords="687,616,952,640"/>
<area href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html" title="Dummy scene node for adding additional transformations to the scene graph. " alt="irr::scene::IDummyTransformationSceneNode" shape="rect" coords="687,672,952,696"/>
<area href="classirr_1_1scene_1_1ILightSceneNode.html" title="Scene node which is a dynamic light. " alt="irr::scene::ILightSceneNode" shape="rect" coords="687,728,952,752"/>
<area href="classirr_1_1scene_1_1ILightSceneNode.html" title="Scene node which is a dynamic light. " alt="irr::scene::ILightSceneNode" shape="rect" coords="687,784,952,808"/>
<area href="classirr_1_1scene_1_1IMeshSceneNode.html" title="A scene node displaying a static mesh. " alt="irr::scene::IMeshSceneNode" shape="rect" coords="687,840,952,864"/>
<area href="classirr_1_1scene_1_1IMeshSceneNode.html" title="A scene node displaying a static mesh. " alt="irr::scene::IMeshSceneNode" shape="rect" coords="687,896,952,920"/>
<area href="classirr_1_1scene_1_1IParticleSystemSceneNode.html" title="A particle system scene node for creating snow, fire, exlosions, smoke... " alt="irr::scene::IParticleSystemSceneNode" shape="rect" coords="687,952,952,976"/>
<area href="classirr_1_1scene_1_1IParticleSystemSceneNode.html" title="A particle system scene node for creating snow, fire, exlosions, smoke... " alt="irr::scene::IParticleSystemSceneNode" shape="rect" coords="687,1008,952,1032"/>
<area href="classirr_1_1scene_1_1IShadowVolumeSceneNode.html" title="Scene node for rendering a shadow volume into a stencil buffer. " alt="irr::scene::IShadowVolumeSceneNode" shape="rect" coords="687,1064,952,1088"/>
<area href="classirr_1_1scene_1_1IShadowVolumeSceneNode.html" title="Scene node for rendering a shadow volume into a stencil buffer. " alt="irr::scene::IShadowVolumeSceneNode" shape="rect" coords="687,1120,952,1144"/>
<area href="classirr_1_1scene_1_1ITerrainSceneNode.html" title="A scene node for displaying terrain using the geo mip map algorithm. " alt="irr::scene::ITerrainSceneNode" shape="rect" coords="687,1176,952,1200"/>
<area href="classirr_1_1scene_1_1ITerrainSceneNode.html" title="A scene node for displaying terrain using the geo mip map algorithm. " alt="irr::scene::ITerrainSceneNode" shape="rect" coords="687,1232,952,1256"/>
<area href="classirr_1_1scene_1_1ITextSceneNode.html" title="A scene node for displaying 2d text at a position in three dimensional space. " alt="irr::scene::ITextSceneNode" shape="rect" coords="687,1288,952,1312"/>
<area href="classirr_1_1scene_1_1ITextSceneNode.html" title="A scene node for displaying 2d text at a position in three dimensional space. " alt="irr::scene::ITextSceneNode" shape="rect" coords="687,1344,952,1368"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9894d951df2f720924f891e0a7b9fac2"><td class="memItemLeft" align="right" valign="top"><a id="a9894d951df2f720924f891e0a7b9fac2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9894d951df2f720924f891e0a7b9fac2">ISceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *mgr, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:a9894d951df2f720924f891e0a7b9fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9894d951df2f720924f891e0a7b9fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064ed436d731f072e55873577724fbc"><td class="memItemLeft" align="right" valign="top"><a id="a3064ed436d731f072e55873577724fbc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3064ed436d731f072e55873577724fbc">~ISceneNode</a> ()</td></tr>
<tr class="memdesc:a3064ed436d731f072e55873577724fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a3064ed436d731f072e55873577724fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0">OnRegisterSceneNode</a> ()</td></tr>
<tr class="memdesc:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called just before the rendering process of the whole scene.  <a href="#ac9795bfcb88dcaf8cba6ea3296e5d8d0">More...</a><br /></td></tr>
<tr class="separator:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">OnAnimate</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeMs)</td></tr>
<tr class="memdesc:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> is called just before rendering the whole scene.  <a href="#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">More...</a><br /></td></tr>
<tr class="separator:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff530cc4856792101d0aedee51ce35fa"><td class="memItemLeft" align="right" valign="top"><a id="aff530cc4856792101d0aedee51ce35fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aff530cc4856792101d0aedee51ce35fa">render</a> ()=0</td></tr>
<tr class="memdesc:aff530cc4856792101d0aedee51ce35fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the node. <br /></td></tr>
<tr class="separator:aff530cc4856792101d0aedee51ce35fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72b38949f926a1929468cd2b1ce16"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab0e72b38949f926a1929468cd2b1ce16">getName</a> () const</td></tr>
<tr class="memdesc:ab0e72b38949f926a1929468cd2b1ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the node.  <a href="#ab0e72b38949f926a1929468cd2b1ce16">More...</a><br /></td></tr>
<tr class="separator:ab0e72b38949f926a1929468cd2b1ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a54a2fc178b9a0e731513865f67d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a810a54a2fc178b9a0e731513865f67d0">setName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name)</td></tr>
<tr class="memdesc:a810a54a2fc178b9a0e731513865f67d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the node.  <a href="#a810a54a2fc178b9a0e731513865f67d0">More...</a><br /></td></tr>
<tr class="separator:a810a54a2fc178b9a0e731513865f67d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a22d956974f4817a20663361f20042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a20a22d956974f4817a20663361f20042">setName</a> (const <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a> &amp;name)</td></tr>
<tr class="memdesc:a20a22d956974f4817a20663361f20042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the node.  <a href="#a20a22d956974f4817a20663361f20042">More...</a><br /></td></tr>
<tr class="separator:a20a22d956974f4817a20663361f20042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a223f718fc2f4944b5ad28c592f6cc8c6">getBoundingBox</a> () const =0</td></tr>
<tr class="memdesc:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis aligned, not transformed bounding box of this node.  <a href="#a223f718fc2f4944b5ad28c592f6cc8c6">More...</a><br /></td></tr>
<tr class="separator:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77746edcc479107067fbf1f4471ab412"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a77746edcc479107067fbf1f4471ab412">getTransformedBoundingBox</a> () const</td></tr>
<tr class="memdesc:a77746edcc479107067fbf1f4471ab412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis aligned, transformed and animated absolute bounding box of this node.  <a href="#a77746edcc479107067fbf1f4471ab412">More...</a><br /></td></tr>
<tr class="separator:a77746edcc479107067fbf1f4471ab412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13dc546a7be796cc0868a2eec51e508"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508">getAbsoluteTransformation</a> () const</td></tr>
<tr class="memdesc:af13dc546a7be796cc0868a2eec51e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute transformation of the node. Is recalculated every <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a>-call.  <a href="#af13dc546a7be796cc0868a2eec51e508">More...</a><br /></td></tr>
<tr class="separator:af13dc546a7be796cc0868a2eec51e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c47ec49174315af83cf5f5d24edb24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac7c47ec49174315af83cf5f5d24edb24">getRelativeTransformation</a> () const</td></tr>
<tr class="memdesc:ac7c47ec49174315af83cf5f5d24edb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relative transformation of the scene node.  <a href="#ac7c47ec49174315af83cf5f5d24edb24">More...</a><br /></td></tr>
<tr class="separator:ac7c47ec49174315af83cf5f5d24edb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e4e8be0055e8182eb26b055abf339"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9e8e4e8be0055e8182eb26b055abf339">isVisible</a> () const</td></tr>
<tr class="memdesc:a9e8e4e8be0055e8182eb26b055abf339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the node should be visible (if all of its parents are visible).  <a href="#a9e8e4e8be0055e8182eb26b055abf339">More...</a><br /></td></tr>
<tr class="separator:a9e8e4e8be0055e8182eb26b055abf339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fda8e5bca28a1c7af1691fefd4f75"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a457fda8e5bca28a1c7af1691fefd4f75">isTrulyVisible</a> () const</td></tr>
<tr class="memdesc:a457fda8e5bca28a1c7af1691fefd4f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the node is truly visible, taking into accounts its parents' visibility.  <a href="#a457fda8e5bca28a1c7af1691fefd4f75">More...</a><br /></td></tr>
<tr class="separator:a457fda8e5bca28a1c7af1691fefd4f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a88fe87d11caa7986a203afe6838c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2e3a88fe87d11caa7986a203afe6838c">setVisible</a> (bool <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9e8e4e8be0055e8182eb26b055abf339">isVisible</a>)</td></tr>
<tr class="memdesc:a2e3a88fe87d11caa7986a203afe6838c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the node should be visible or not.  <a href="#a2e3a88fe87d11caa7986a203afe6838c">More...</a><br /></td></tr>
<tr class="separator:a2e3a88fe87d11caa7986a203afe6838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1a3b5b32f54bc1b6617756fc48a2cb17">getID</a> () const</td></tr>
<tr class="memdesc:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the scene node.  <a href="#a1a3b5b32f54bc1b6617756fc48a2cb17">More...</a><br /></td></tr>
<tr class="separator:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade60c630c4768200b1d15debbd00fe0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ade60c630c4768200b1d15debbd00fe0e">setID</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id)</td></tr>
<tr class="memdesc:ade60c630c4768200b1d15debbd00fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the id of the scene node.  <a href="#ade60c630c4768200b1d15debbd00fe0e">More...</a><br /></td></tr>
<tr class="separator:ade60c630c4768200b1d15debbd00fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceef4fbb68f6cc7bb40035225350970"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acceef4fbb68f6cc7bb40035225350970">addChild</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *child)</td></tr>
<tr class="memdesc:acceef4fbb68f6cc7bb40035225350970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to this scene node.  <a href="#acceef4fbb68f6cc7bb40035225350970">More...</a><br /></td></tr>
<tr class="separator:acceef4fbb68f6cc7bb40035225350970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e371142fc883c7dd229552e0340de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a831e371142fc883c7dd229552e0340de">removeChild</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *child)</td></tr>
<tr class="memdesc:a831e371142fc883c7dd229552e0340de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from this scene node.  <a href="#a831e371142fc883c7dd229552e0340de">More...</a><br /></td></tr>
<tr class="separator:a831e371142fc883c7dd229552e0340de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348767bb5b9262d997067c50e079e5be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a348767bb5b9262d997067c50e079e5be">removeAll</a> ()</td></tr>
<tr class="memdesc:a348767bb5b9262d997067c50e079e5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children of this scene node.  <a href="#a348767bb5b9262d997067c50e079e5be">More...</a><br /></td></tr>
<tr class="separator:a348767bb5b9262d997067c50e079e5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2efa2670e29d6bb33b0dd99403b8b69c">remove</a> ()</td></tr>
<tr class="memdesc:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this scene node from the scene.  <a href="#a2efa2670e29d6bb33b0dd99403b8b69c">More...</a><br /></td></tr>
<tr class="separator:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0e5cd342cd7293c136e53e2c2c5e0f3a">addAnimator</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *animator)</td></tr>
<tr class="memdesc:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an animator which should animate this node.  <a href="#a0e5cd342cd7293c136e53e2c2c5e0f3a">More...</a><br /></td></tr>
<tr class="separator:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454fc115d9afa89623c55deba8a4add1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a454fc115d9afa89623c55deba8a4add1">getAnimators</a> () const</td></tr>
<tr class="memdesc:a454fc115d9afa89623c55deba8a4add1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all scene node animators.  <a href="#a454fc115d9afa89623c55deba8a4add1">More...</a><br /></td></tr>
<tr class="separator:a454fc115d9afa89623c55deba8a4add1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa67f8f91d4ec99f82955641f1f9e521"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aaa67f8f91d4ec99f82955641f1f9e521">removeAnimator</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *animator)</td></tr>
<tr class="memdesc:aaa67f8f91d4ec99f82955641f1f9e521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an animator from this scene node.  <a href="#aaa67f8f91d4ec99f82955641f1f9e521">More...</a><br /></td></tr>
<tr class="separator:aaa67f8f91d4ec99f82955641f1f9e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f198bd566e9a7290cbefa531d8d31e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a28f198bd566e9a7290cbefa531d8d31e">removeAnimators</a> ()</td></tr>
<tr class="memdesc:a28f198bd566e9a7290cbefa531d8d31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all animators from this scene node.  <a href="#a28f198bd566e9a7290cbefa531d8d31e">More...</a><br /></td></tr>
<tr class="separator:a28f198bd566e9a7290cbefa531d8d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1f44d8cf753b2e4c17c90d4fc2ed05b2">getMaterial</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> num)</td></tr>
<tr class="memdesc:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the material based on the zero based index i.  <a href="#a1f44d8cf753b2e4c17c90d4fc2ed05b2">More...</a><br /></td></tr>
<tr class="separator:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe">getMaterialCount</a> () const</td></tr>
<tr class="memdesc:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of materials used by this scene node.  <a href="#a8e75e9baede63e31e6aa6e42e6c8ddfe">More...</a><br /></td></tr>
<tr class="separator:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2841d5077854b9981711a403f33762cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2841d5077854b9981711a403f33762cd">setMaterialFlag</a> (<a class="el" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3">video::E_MATERIAL_FLAG</a> flag, bool newvalue)</td></tr>
<tr class="memdesc:a2841d5077854b9981711a403f33762cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all material flags at once to a new value.  <a href="#a2841d5077854b9981711a403f33762cd">More...</a><br /></td></tr>
<tr class="separator:a2841d5077854b9981711a403f33762cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">setMaterialTexture</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> textureLayer, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture)</td></tr>
<tr class="memdesc:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture of the specified layer in all materials of this scene node to the new texture.  <a href="#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">More...</a><br /></td></tr>
<tr class="separator:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302c7dedd776b52111823df5ed8446de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a302c7dedd776b52111823df5ed8446de">setMaterialType</a> (<a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">video::E_MATERIAL_TYPE</a> newType)</td></tr>
<tr class="memdesc:a302c7dedd776b52111823df5ed8446de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the material type of all materials in this scene node to a new material type.  <a href="#a302c7dedd776b52111823df5ed8446de">More...</a><br /></td></tr>
<tr class="separator:a302c7dedd776b52111823df5ed8446de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a97a5963f8b7b3cdf6fa196863c641c1d">getScale</a> () const</td></tr>
<tr class="memdesc:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scale of the scene node relative to its parent.  <a href="#a97a5963f8b7b3cdf6fa196863c641c1d">More...</a><br /></td></tr>
<tr class="separator:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d710e1e20546bd89affe09fa943b0e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1d710e1e20546bd89affe09fa943b0e2">setScale</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;scale)</td></tr>
<tr class="memdesc:a1d710e1e20546bd89affe09fa943b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative scale of the scene node.  <a href="#a1d710e1e20546bd89affe09fa943b0e2">More...</a><br /></td></tr>
<tr class="separator:a1d710e1e20546bd89affe09fa943b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfef9f174e2398b479915791e4084061"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acfef9f174e2398b479915791e4084061">getRotation</a> () const</td></tr>
<tr class="memdesc:acfef9f174e2398b479915791e4084061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rotation of the node relative to its parent.  <a href="#acfef9f174e2398b479915791e4084061">More...</a><br /></td></tr>
<tr class="separator:acfef9f174e2398b479915791e4084061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ff54f52d3a9e1514cd487a550935c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#adb6ff54f52d3a9e1514cd487a550935c">setRotation</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;rotation)</td></tr>
<tr class="memdesc:adb6ff54f52d3a9e1514cd487a550935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation of the node relative to its parent.  <a href="#adb6ff54f52d3a9e1514cd487a550935c">More...</a><br /></td></tr>
<tr class="separator:adb6ff54f52d3a9e1514cd487a550935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5686d35e868e7d295c2d2cb84799d20"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af5686d35e868e7d295c2d2cb84799d20">getPosition</a> () const</td></tr>
<tr class="memdesc:af5686d35e868e7d295c2d2cb84799d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node relative to its parent.  <a href="#af5686d35e868e7d295c2d2cb84799d20">More...</a><br /></td></tr>
<tr class="separator:af5686d35e868e7d295c2d2cb84799d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166eb0a92cc0e46c49266f41a68ed50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2166eb0a92cc0e46c49266f41a68ed50">setPosition</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;newpos)</td></tr>
<tr class="memdesc:a2166eb0a92cc0e46c49266f41a68ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to its parent.  <a href="#a2166eb0a92cc0e46c49266f41a68ed50">More...</a><br /></td></tr>
<tr class="separator:a2166eb0a92cc0e46c49266f41a68ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a09a1c2ce3cf5448197a0c7b0bb16a516">getAbsolutePosition</a> () const</td></tr>
<tr class="memdesc:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute position of the node in world coordinates.  <a href="#a09a1c2ce3cf5448197a0c7b0bb16a516">More...</a><br /></td></tr>
<tr class="separator:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a5fcd62dbf524b8d2d6daa61c7d6cf119">setAutomaticCulling</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> state)</td></tr>
<tr class="memdesc:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables automatic culling based on the bounding box.  <a href="#a5fcd62dbf524b8d2d6daa61c7d6cf119">More...</a><br /></td></tr>
<tr class="separator:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748cd5c678e41a4fcff0514937c77be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0748cd5c678e41a4fcff0514937c77be">getAutomaticCulling</a> () const</td></tr>
<tr class="memdesc:a0748cd5c678e41a4fcff0514937c77be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the automatic culling state.  <a href="#a0748cd5c678e41a4fcff0514937c77be">More...</a><br /></td></tr>
<tr class="separator:a0748cd5c678e41a4fcff0514937c77be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83877ca84fa9cde95f099f961e80577"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ad83877ca84fa9cde95f099f961e80577">setDebugDataVisible</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> state)</td></tr>
<tr class="memdesc:ad83877ca84fa9cde95f099f961e80577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if debug data like bounding boxes should be drawn.  <a href="#ad83877ca84fa9cde95f099f961e80577">More...</a><br /></td></tr>
<tr class="separator:ad83877ca84fa9cde95f099f961e80577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35515d81242e24c8b831bf29a555221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ad35515d81242e24c8b831bf29a555221">isDebugDataVisible</a> () const</td></tr>
<tr class="memdesc:ad35515d81242e24c8b831bf29a555221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if debug data like bounding boxes are drawn.  <a href="#ad35515d81242e24c8b831bf29a555221">More...</a><br /></td></tr>
<tr class="separator:ad35515d81242e24c8b831bf29a555221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceda3eb747a353ffeda02c26e697cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a7ceda3eb747a353ffeda02c26e697cbd">setIsDebugObject</a> (bool debugObject)</td></tr>
<tr class="memdesc:a7ceda3eb747a353ffeda02c26e697cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if this scene node is a debug object.  <a href="#a7ceda3eb747a353ffeda02c26e697cbd">More...</a><br /></td></tr>
<tr class="separator:a7ceda3eb747a353ffeda02c26e697cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304529a50ee58361a84d1db012bbc476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a304529a50ee58361a84d1db012bbc476">isDebugObject</a> () const</td></tr>
<tr class="memdesc:a304529a50ee58361a84d1db012bbc476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this scene node is a debug object.  <a href="#a304529a50ee58361a84d1db012bbc476">More...</a><br /></td></tr>
<tr class="separator:a304529a50ee58361a84d1db012bbc476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9a0e01ebfbf9f05e0caa147b290ffaf5">getChildren</a> () const</td></tr>
<tr class="memdesc:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the list of all children.  <a href="#a9a0e01ebfbf9f05e0caa147b290ffaf5">More...</a><br /></td></tr>
<tr class="separator:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a59e7f36cb5c9c4895e06fce0ca5eb276">setParent</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *newParent)</td></tr>
<tr class="memdesc:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the parent of the scene node.  <a href="#a59e7f36cb5c9c4895e06fce0ca5eb276">More...</a><br /></td></tr>
<tr class="separator:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab820f7ccfdd317d3913316b6991ea5d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab820f7ccfdd317d3913316b6991ea5d9">getTriangleSelector</a> () const</td></tr>
<tr class="memdesc:ab820f7ccfdd317d3913316b6991ea5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangle selector attached to this scene node.  <a href="#ab820f7ccfdd317d3913316b6991ea5d9">More...</a><br /></td></tr>
<tr class="separator:ab820f7ccfdd317d3913316b6991ea5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb52ec54bf3ae117340d8defd1255f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a87fb52ec54bf3ae117340d8defd1255f">setTriangleSelector</a> (<a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *selector)</td></tr>
<tr class="memdesc:a87fb52ec54bf3ae117340d8defd1255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the triangle selector of the scene node.  <a href="#a87fb52ec54bf3ae117340d8defd1255f">More...</a><br /></td></tr>
<tr class="separator:a87fb52ec54bf3ae117340d8defd1255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e">updateAbsolutePosition</a> ()</td></tr>
<tr class="memdesc:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the absolute position based on the relative and the parents position.  <a href="#aeb6e0dc034bb2101600ce87acbcf0f6e">More...</a><br /></td></tr>
<tr class="separator:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf77e3715d63e436cc691bf881c4eb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#adf77e3715d63e436cc691bf881c4eb5b">getParent</a> () const</td></tr>
<tr class="memdesc:adf77e3715d63e436cc691bf881c4eb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of this scene node.  <a href="#adf77e3715d63e436cc691bf881c4eb5b">More...</a><br /></td></tr>
<tr class="separator:adf77e3715d63e436cc691bf881c4eb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3468b09e4afa009d2036efbea9c09b8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3468b09e4afa009d2036efbea9c09b8c">getType</a> () const</td></tr>
<tr class="memdesc:a3468b09e4afa009d2036efbea9c09b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node.  <a href="#a3468b09e4afa009d2036efbea9c09b8c">More...</a><br /></td></tr>
<tr class="separator:a3468b09e4afa009d2036efbea9c09b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3210345b70227c03c7f889c94754fdaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3210345b70227c03c7f889c94754fdaa">serializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *out, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0) const</td></tr>
<tr class="memdesc:a3210345b70227c03c7f889c94754fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the scene node.  <a href="#a3210345b70227c03c7f889c94754fdaa">More...</a><br /></td></tr>
<tr class="separator:a3210345b70227c03c7f889c94754fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb609b08fc89a92f928c19ce3b181eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a5fb609b08fc89a92f928c19ce3b181eb">deserializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *in, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)</td></tr>
<tr class="memdesc:a5fb609b08fc89a92f928c19ce3b181eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the scene node.  <a href="#a5fb609b08fc89a92f928c19ce3b181eb">More...</a><br /></td></tr>
<tr class="separator:a5fb609b08fc89a92f928c19ce3b181eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39832b55855dc59196053adbaec95cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac39832b55855dc59196053adbaec95cc">clone</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *newParent=0, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager=0)</td></tr>
<tr class="memdesc:ac39832b55855dc59196053adbaec95cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this scene node and its children.  <a href="#ac39832b55855dc59196053adbaec95cc">More...</a><br /></td></tr>
<tr class="separator:ac39832b55855dc59196053adbaec95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a394f112e9b4a1c66f7d58e873a3f8a1d">getSceneManager</a> (void) const</td></tr>
<tr class="memdesc:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scene manager for this node.  <a href="#a394f112e9b4a1c66f7d58e873a3f8a1d">More...</a><br /></td></tr>
<tr class="separator:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894d951df2f720924f891e0a7b9fac2"><td class="memItemLeft" align="right" valign="top"><a id="a9894d951df2f720924f891e0a7b9fac2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9894d951df2f720924f891e0a7b9fac2">ISceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *mgr, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:a9894d951df2f720924f891e0a7b9fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9894d951df2f720924f891e0a7b9fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064ed436d731f072e55873577724fbc"><td class="memItemLeft" align="right" valign="top"><a id="a3064ed436d731f072e55873577724fbc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3064ed436d731f072e55873577724fbc">~ISceneNode</a> ()</td></tr>
<tr class="memdesc:a3064ed436d731f072e55873577724fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a3064ed436d731f072e55873577724fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0">OnRegisterSceneNode</a> ()</td></tr>
<tr class="memdesc:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called just before the rendering process of the whole scene.  <a href="#ac9795bfcb88dcaf8cba6ea3296e5d8d0">More...</a><br /></td></tr>
<tr class="separator:ac9795bfcb88dcaf8cba6ea3296e5d8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">OnAnimate</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeMs)</td></tr>
<tr class="memdesc:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> is called just before rendering the whole scene.  <a href="#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">More...</a><br /></td></tr>
<tr class="separator:afc1dcb5cb19116d0c7aa3d4ebdf04cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff530cc4856792101d0aedee51ce35fa"><td class="memItemLeft" align="right" valign="top"><a id="aff530cc4856792101d0aedee51ce35fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aff530cc4856792101d0aedee51ce35fa">render</a> ()=0</td></tr>
<tr class="memdesc:aff530cc4856792101d0aedee51ce35fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the node. <br /></td></tr>
<tr class="separator:aff530cc4856792101d0aedee51ce35fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e72b38949f926a1929468cd2b1ce16"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab0e72b38949f926a1929468cd2b1ce16">getName</a> () const</td></tr>
<tr class="memdesc:ab0e72b38949f926a1929468cd2b1ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the node.  <a href="#ab0e72b38949f926a1929468cd2b1ce16">More...</a><br /></td></tr>
<tr class="separator:ab0e72b38949f926a1929468cd2b1ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a54a2fc178b9a0e731513865f67d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a810a54a2fc178b9a0e731513865f67d0">setName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name)</td></tr>
<tr class="memdesc:a810a54a2fc178b9a0e731513865f67d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the node.  <a href="#a810a54a2fc178b9a0e731513865f67d0">More...</a><br /></td></tr>
<tr class="separator:a810a54a2fc178b9a0e731513865f67d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a22d956974f4817a20663361f20042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a20a22d956974f4817a20663361f20042">setName</a> (const <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a> &amp;name)</td></tr>
<tr class="memdesc:a20a22d956974f4817a20663361f20042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the node.  <a href="#a20a22d956974f4817a20663361f20042">More...</a><br /></td></tr>
<tr class="separator:a20a22d956974f4817a20663361f20042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a223f718fc2f4944b5ad28c592f6cc8c6">getBoundingBox</a> () const =0</td></tr>
<tr class="memdesc:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis aligned, not transformed bounding box of this node.  <a href="#a223f718fc2f4944b5ad28c592f6cc8c6">More...</a><br /></td></tr>
<tr class="separator:a223f718fc2f4944b5ad28c592f6cc8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77746edcc479107067fbf1f4471ab412"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a77746edcc479107067fbf1f4471ab412">getTransformedBoundingBox</a> () const</td></tr>
<tr class="memdesc:a77746edcc479107067fbf1f4471ab412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis aligned, transformed and animated absolute bounding box of this node.  <a href="#a77746edcc479107067fbf1f4471ab412">More...</a><br /></td></tr>
<tr class="separator:a77746edcc479107067fbf1f4471ab412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13dc546a7be796cc0868a2eec51e508"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508">getAbsoluteTransformation</a> () const</td></tr>
<tr class="memdesc:af13dc546a7be796cc0868a2eec51e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute transformation of the node. Is recalculated every <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a>-call.  <a href="#af13dc546a7be796cc0868a2eec51e508">More...</a><br /></td></tr>
<tr class="separator:af13dc546a7be796cc0868a2eec51e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c47ec49174315af83cf5f5d24edb24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac7c47ec49174315af83cf5f5d24edb24">getRelativeTransformation</a> () const</td></tr>
<tr class="memdesc:ac7c47ec49174315af83cf5f5d24edb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relative transformation of the scene node.  <a href="#ac7c47ec49174315af83cf5f5d24edb24">More...</a><br /></td></tr>
<tr class="separator:ac7c47ec49174315af83cf5f5d24edb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e4e8be0055e8182eb26b055abf339"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9e8e4e8be0055e8182eb26b055abf339">isVisible</a> () const</td></tr>
<tr class="memdesc:a9e8e4e8be0055e8182eb26b055abf339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the node should be visible (if all of its parents are visible).  <a href="#a9e8e4e8be0055e8182eb26b055abf339">More...</a><br /></td></tr>
<tr class="separator:a9e8e4e8be0055e8182eb26b055abf339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fda8e5bca28a1c7af1691fefd4f75"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a457fda8e5bca28a1c7af1691fefd4f75">isTrulyVisible</a> () const</td></tr>
<tr class="memdesc:a457fda8e5bca28a1c7af1691fefd4f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the node is truly visible, taking into accounts its parents' visibility.  <a href="#a457fda8e5bca28a1c7af1691fefd4f75">More...</a><br /></td></tr>
<tr class="separator:a457fda8e5bca28a1c7af1691fefd4f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a88fe87d11caa7986a203afe6838c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2e3a88fe87d11caa7986a203afe6838c">setVisible</a> (bool <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9e8e4e8be0055e8182eb26b055abf339">isVisible</a>)</td></tr>
<tr class="memdesc:a2e3a88fe87d11caa7986a203afe6838c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the node should be visible or not.  <a href="#a2e3a88fe87d11caa7986a203afe6838c">More...</a><br /></td></tr>
<tr class="separator:a2e3a88fe87d11caa7986a203afe6838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1a3b5b32f54bc1b6617756fc48a2cb17">getID</a> () const</td></tr>
<tr class="memdesc:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the scene node.  <a href="#a1a3b5b32f54bc1b6617756fc48a2cb17">More...</a><br /></td></tr>
<tr class="separator:a1a3b5b32f54bc1b6617756fc48a2cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade60c630c4768200b1d15debbd00fe0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ade60c630c4768200b1d15debbd00fe0e">setID</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id)</td></tr>
<tr class="memdesc:ade60c630c4768200b1d15debbd00fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the id of the scene node.  <a href="#ade60c630c4768200b1d15debbd00fe0e">More...</a><br /></td></tr>
<tr class="separator:ade60c630c4768200b1d15debbd00fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceef4fbb68f6cc7bb40035225350970"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acceef4fbb68f6cc7bb40035225350970">addChild</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *child)</td></tr>
<tr class="memdesc:acceef4fbb68f6cc7bb40035225350970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to this scene node.  <a href="#acceef4fbb68f6cc7bb40035225350970">More...</a><br /></td></tr>
<tr class="separator:acceef4fbb68f6cc7bb40035225350970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e371142fc883c7dd229552e0340de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a831e371142fc883c7dd229552e0340de">removeChild</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *child)</td></tr>
<tr class="memdesc:a831e371142fc883c7dd229552e0340de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from this scene node.  <a href="#a831e371142fc883c7dd229552e0340de">More...</a><br /></td></tr>
<tr class="separator:a831e371142fc883c7dd229552e0340de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348767bb5b9262d997067c50e079e5be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a348767bb5b9262d997067c50e079e5be">removeAll</a> ()</td></tr>
<tr class="memdesc:a348767bb5b9262d997067c50e079e5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children of this scene node.  <a href="#a348767bb5b9262d997067c50e079e5be">More...</a><br /></td></tr>
<tr class="separator:a348767bb5b9262d997067c50e079e5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2efa2670e29d6bb33b0dd99403b8b69c">remove</a> ()</td></tr>
<tr class="memdesc:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this scene node from the scene.  <a href="#a2efa2670e29d6bb33b0dd99403b8b69c">More...</a><br /></td></tr>
<tr class="separator:a2efa2670e29d6bb33b0dd99403b8b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0e5cd342cd7293c136e53e2c2c5e0f3a">addAnimator</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *animator)</td></tr>
<tr class="memdesc:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an animator which should animate this node.  <a href="#a0e5cd342cd7293c136e53e2c2c5e0f3a">More...</a><br /></td></tr>
<tr class="separator:a0e5cd342cd7293c136e53e2c2c5e0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454fc115d9afa89623c55deba8a4add1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a454fc115d9afa89623c55deba8a4add1">getAnimators</a> () const</td></tr>
<tr class="memdesc:a454fc115d9afa89623c55deba8a4add1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all scene node animators.  <a href="#a454fc115d9afa89623c55deba8a4add1">More...</a><br /></td></tr>
<tr class="separator:a454fc115d9afa89623c55deba8a4add1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa67f8f91d4ec99f82955641f1f9e521"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aaa67f8f91d4ec99f82955641f1f9e521">removeAnimator</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *animator)</td></tr>
<tr class="memdesc:aaa67f8f91d4ec99f82955641f1f9e521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an animator from this scene node.  <a href="#aaa67f8f91d4ec99f82955641f1f9e521">More...</a><br /></td></tr>
<tr class="separator:aaa67f8f91d4ec99f82955641f1f9e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f198bd566e9a7290cbefa531d8d31e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a28f198bd566e9a7290cbefa531d8d31e">removeAnimators</a> ()</td></tr>
<tr class="memdesc:a28f198bd566e9a7290cbefa531d8d31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all animators from this scene node.  <a href="#a28f198bd566e9a7290cbefa531d8d31e">More...</a><br /></td></tr>
<tr class="separator:a28f198bd566e9a7290cbefa531d8d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1f44d8cf753b2e4c17c90d4fc2ed05b2">getMaterial</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> num)</td></tr>
<tr class="memdesc:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the material based on the zero based index i.  <a href="#a1f44d8cf753b2e4c17c90d4fc2ed05b2">More...</a><br /></td></tr>
<tr class="separator:a1f44d8cf753b2e4c17c90d4fc2ed05b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe">getMaterialCount</a> () const</td></tr>
<tr class="memdesc:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of materials used by this scene node.  <a href="#a8e75e9baede63e31e6aa6e42e6c8ddfe">More...</a><br /></td></tr>
<tr class="separator:a8e75e9baede63e31e6aa6e42e6c8ddfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2841d5077854b9981711a403f33762cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2841d5077854b9981711a403f33762cd">setMaterialFlag</a> (<a class="el" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3">video::E_MATERIAL_FLAG</a> flag, bool newvalue)</td></tr>
<tr class="memdesc:a2841d5077854b9981711a403f33762cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all material flags at once to a new value.  <a href="#a2841d5077854b9981711a403f33762cd">More...</a><br /></td></tr>
<tr class="separator:a2841d5077854b9981711a403f33762cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">setMaterialTexture</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> textureLayer, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture)</td></tr>
<tr class="memdesc:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture of the specified layer in all materials of this scene node to the new texture.  <a href="#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">More...</a><br /></td></tr>
<tr class="separator:a0d5d2e05ebe08e6a432fbb4fd1d28dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302c7dedd776b52111823df5ed8446de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a302c7dedd776b52111823df5ed8446de">setMaterialType</a> (<a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">video::E_MATERIAL_TYPE</a> newType)</td></tr>
<tr class="memdesc:a302c7dedd776b52111823df5ed8446de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the material type of all materials in this scene node to a new material type.  <a href="#a302c7dedd776b52111823df5ed8446de">More...</a><br /></td></tr>
<tr class="separator:a302c7dedd776b52111823df5ed8446de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a97a5963f8b7b3cdf6fa196863c641c1d">getScale</a> () const</td></tr>
<tr class="memdesc:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scale of the scene node relative to its parent.  <a href="#a97a5963f8b7b3cdf6fa196863c641c1d">More...</a><br /></td></tr>
<tr class="separator:a97a5963f8b7b3cdf6fa196863c641c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d710e1e20546bd89affe09fa943b0e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1d710e1e20546bd89affe09fa943b0e2">setScale</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;scale)</td></tr>
<tr class="memdesc:a1d710e1e20546bd89affe09fa943b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relative scale of the scene node.  <a href="#a1d710e1e20546bd89affe09fa943b0e2">More...</a><br /></td></tr>
<tr class="separator:a1d710e1e20546bd89affe09fa943b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfef9f174e2398b479915791e4084061"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acfef9f174e2398b479915791e4084061">getRotation</a> () const</td></tr>
<tr class="memdesc:acfef9f174e2398b479915791e4084061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rotation of the node relative to its parent.  <a href="#acfef9f174e2398b479915791e4084061">More...</a><br /></td></tr>
<tr class="separator:acfef9f174e2398b479915791e4084061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ff54f52d3a9e1514cd487a550935c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#adb6ff54f52d3a9e1514cd487a550935c">setRotation</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;rotation)</td></tr>
<tr class="memdesc:adb6ff54f52d3a9e1514cd487a550935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation of the node relative to its parent.  <a href="#adb6ff54f52d3a9e1514cd487a550935c">More...</a><br /></td></tr>
<tr class="separator:adb6ff54f52d3a9e1514cd487a550935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5686d35e868e7d295c2d2cb84799d20"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af5686d35e868e7d295c2d2cb84799d20">getPosition</a> () const</td></tr>
<tr class="memdesc:af5686d35e868e7d295c2d2cb84799d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node relative to its parent.  <a href="#af5686d35e868e7d295c2d2cb84799d20">More...</a><br /></td></tr>
<tr class="separator:af5686d35e868e7d295c2d2cb84799d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166eb0a92cc0e46c49266f41a68ed50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2166eb0a92cc0e46c49266f41a68ed50">setPosition</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;newpos)</td></tr>
<tr class="memdesc:a2166eb0a92cc0e46c49266f41a68ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to its parent.  <a href="#a2166eb0a92cc0e46c49266f41a68ed50">More...</a><br /></td></tr>
<tr class="separator:a2166eb0a92cc0e46c49266f41a68ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a09a1c2ce3cf5448197a0c7b0bb16a516">getAbsolutePosition</a> () const</td></tr>
<tr class="memdesc:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute position of the node in world coordinates.  <a href="#a09a1c2ce3cf5448197a0c7b0bb16a516">More...</a><br /></td></tr>
<tr class="separator:a09a1c2ce3cf5448197a0c7b0bb16a516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a5fcd62dbf524b8d2d6daa61c7d6cf119">setAutomaticCulling</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> state)</td></tr>
<tr class="memdesc:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables automatic culling based on the bounding box.  <a href="#a5fcd62dbf524b8d2d6daa61c7d6cf119">More...</a><br /></td></tr>
<tr class="separator:a5fcd62dbf524b8d2d6daa61c7d6cf119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748cd5c678e41a4fcff0514937c77be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0748cd5c678e41a4fcff0514937c77be">getAutomaticCulling</a> () const</td></tr>
<tr class="memdesc:a0748cd5c678e41a4fcff0514937c77be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the automatic culling state.  <a href="#a0748cd5c678e41a4fcff0514937c77be">More...</a><br /></td></tr>
<tr class="separator:a0748cd5c678e41a4fcff0514937c77be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83877ca84fa9cde95f099f961e80577"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ad83877ca84fa9cde95f099f961e80577">setDebugDataVisible</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> state)</td></tr>
<tr class="memdesc:ad83877ca84fa9cde95f099f961e80577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if debug data like bounding boxes should be drawn.  <a href="#ad83877ca84fa9cde95f099f961e80577">More...</a><br /></td></tr>
<tr class="separator:ad83877ca84fa9cde95f099f961e80577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35515d81242e24c8b831bf29a555221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ad35515d81242e24c8b831bf29a555221">isDebugDataVisible</a> () const</td></tr>
<tr class="memdesc:ad35515d81242e24c8b831bf29a555221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if debug data like bounding boxes are drawn.  <a href="#ad35515d81242e24c8b831bf29a555221">More...</a><br /></td></tr>
<tr class="separator:ad35515d81242e24c8b831bf29a555221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceda3eb747a353ffeda02c26e697cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a7ceda3eb747a353ffeda02c26e697cbd">setIsDebugObject</a> (bool debugObject)</td></tr>
<tr class="memdesc:a7ceda3eb747a353ffeda02c26e697cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if this scene node is a debug object.  <a href="#a7ceda3eb747a353ffeda02c26e697cbd">More...</a><br /></td></tr>
<tr class="separator:a7ceda3eb747a353ffeda02c26e697cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304529a50ee58361a84d1db012bbc476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a304529a50ee58361a84d1db012bbc476">isDebugObject</a> () const</td></tr>
<tr class="memdesc:a304529a50ee58361a84d1db012bbc476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this scene node is a debug object.  <a href="#a304529a50ee58361a84d1db012bbc476">More...</a><br /></td></tr>
<tr class="separator:a304529a50ee58361a84d1db012bbc476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a9a0e01ebfbf9f05e0caa147b290ffaf5">getChildren</a> () const</td></tr>
<tr class="memdesc:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the list of all children.  <a href="#a9a0e01ebfbf9f05e0caa147b290ffaf5">More...</a><br /></td></tr>
<tr class="separator:a9a0e01ebfbf9f05e0caa147b290ffaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a59e7f36cb5c9c4895e06fce0ca5eb276">setParent</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *newParent)</td></tr>
<tr class="memdesc:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the parent of the scene node.  <a href="#a59e7f36cb5c9c4895e06fce0ca5eb276">More...</a><br /></td></tr>
<tr class="separator:a59e7f36cb5c9c4895e06fce0ca5eb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab820f7ccfdd317d3913316b6991ea5d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab820f7ccfdd317d3913316b6991ea5d9">getTriangleSelector</a> () const</td></tr>
<tr class="memdesc:ab820f7ccfdd317d3913316b6991ea5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangle selector attached to this scene node.  <a href="#ab820f7ccfdd317d3913316b6991ea5d9">More...</a><br /></td></tr>
<tr class="separator:ab820f7ccfdd317d3913316b6991ea5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb52ec54bf3ae117340d8defd1255f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a87fb52ec54bf3ae117340d8defd1255f">setTriangleSelector</a> (<a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *selector)</td></tr>
<tr class="memdesc:a87fb52ec54bf3ae117340d8defd1255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the triangle selector of the scene node.  <a href="#a87fb52ec54bf3ae117340d8defd1255f">More...</a><br /></td></tr>
<tr class="separator:a87fb52ec54bf3ae117340d8defd1255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e">updateAbsolutePosition</a> ()</td></tr>
<tr class="memdesc:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the absolute position based on the relative and the parents position.  <a href="#aeb6e0dc034bb2101600ce87acbcf0f6e">More...</a><br /></td></tr>
<tr class="separator:aeb6e0dc034bb2101600ce87acbcf0f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf77e3715d63e436cc691bf881c4eb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#adf77e3715d63e436cc691bf881c4eb5b">getParent</a> () const</td></tr>
<tr class="memdesc:adf77e3715d63e436cc691bf881c4eb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of this scene node.  <a href="#adf77e3715d63e436cc691bf881c4eb5b">More...</a><br /></td></tr>
<tr class="separator:adf77e3715d63e436cc691bf881c4eb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3468b09e4afa009d2036efbea9c09b8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3468b09e4afa009d2036efbea9c09b8c">getType</a> () const</td></tr>
<tr class="memdesc:a3468b09e4afa009d2036efbea9c09b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node.  <a href="#a3468b09e4afa009d2036efbea9c09b8c">More...</a><br /></td></tr>
<tr class="separator:a3468b09e4afa009d2036efbea9c09b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3210345b70227c03c7f889c94754fdaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a3210345b70227c03c7f889c94754fdaa">serializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *out, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0) const</td></tr>
<tr class="memdesc:a3210345b70227c03c7f889c94754fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the scene node.  <a href="#a3210345b70227c03c7f889c94754fdaa">More...</a><br /></td></tr>
<tr class="separator:a3210345b70227c03c7f889c94754fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb609b08fc89a92f928c19ce3b181eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a5fb609b08fc89a92f928c19ce3b181eb">deserializeAttributes</a> (<a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *in, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)</td></tr>
<tr class="memdesc:a5fb609b08fc89a92f928c19ce3b181eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the scene node.  <a href="#a5fb609b08fc89a92f928c19ce3b181eb">More...</a><br /></td></tr>
<tr class="separator:a5fb609b08fc89a92f928c19ce3b181eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39832b55855dc59196053adbaec95cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac39832b55855dc59196053adbaec95cc">clone</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *newParent=0, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager=0)</td></tr>
<tr class="memdesc:ac39832b55855dc59196053adbaec95cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this scene node and its children.  <a href="#ac39832b55855dc59196053adbaec95cc">More...</a><br /></td></tr>
<tr class="separator:ac39832b55855dc59196053adbaec95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a394f112e9b4a1c66f7d58e873a3f8a1d">getSceneManager</a> (void) const</td></tr>
<tr class="memdesc:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scene manager for this node.  <a href="#a394f112e9b4a1c66f7d58e873a3f8a1d">More...</a><br /></td></tr>
<tr class="separator:a394f112e9b4a1c66f7d58e873a3f8a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a00a4ef0212b5d4b005202519859689bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a00a4ef0212b5d4b005202519859689bd">cloneMembers</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *toCopyFrom, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager)</td></tr>
<tr class="memdesc:a00a4ef0212b5d4b005202519859689bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clone function for the <a class="el" href="classirr_1_1scene_1_1ISceneNode.html" title="Scene node interface. ">ISceneNode</a> members.  <a href="#a00a4ef0212b5d4b005202519859689bd">More...</a><br /></td></tr>
<tr class="separator:a00a4ef0212b5d4b005202519859689bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513d09ae37f71391d7c4838e29164a3e"><td class="memItemLeft" align="right" valign="top"><a id="a513d09ae37f71391d7c4838e29164a3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a513d09ae37f71391d7c4838e29164a3e">setSceneManager</a> (<a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager)</td></tr>
<tr class="memdesc:a513d09ae37f71391d7c4838e29164a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new scene manager for this node and all children. Called by addChild when moving nodes between scene managers. <br /></td></tr>
<tr class="separator:a513d09ae37f71391d7c4838e29164a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a4ef0212b5d4b005202519859689bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a00a4ef0212b5d4b005202519859689bd">cloneMembers</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *toCopyFrom, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager)</td></tr>
<tr class="memdesc:a00a4ef0212b5d4b005202519859689bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clone function for the <a class="el" href="classirr_1_1scene_1_1ISceneNode.html" title="Scene node interface. ">ISceneNode</a> members.  <a href="#a00a4ef0212b5d4b005202519859689bd">More...</a><br /></td></tr>
<tr class="separator:a00a4ef0212b5d4b005202519859689bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513d09ae37f71391d7c4838e29164a3e"><td class="memItemLeft" align="right" valign="top"><a id="a513d09ae37f71391d7c4838e29164a3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a513d09ae37f71391d7c4838e29164a3e">setSceneManager</a> (<a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *newManager)</td></tr>
<tr class="memdesc:a513d09ae37f71391d7c4838e29164a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new scene manager for this node and all children. Called by addChild when moving nodes between scene managers. <br /></td></tr>
<tr class="separator:a513d09ae37f71391d7c4838e29164a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2527ec038f7e400fc141efa7fdc6327b"><td class="memItemLeft" align="right" valign="top"><a id="a2527ec038f7e400fc141efa7fdc6327b"></a>
<a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2527ec038f7e400fc141efa7fdc6327b">Name</a></td></tr>
<tr class="memdesc:a2527ec038f7e400fc141efa7fdc6327b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the scene node. <br /></td></tr>
<tr class="separator:a2527ec038f7e400fc141efa7fdc6327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7d4bc865d0c7ccf361515a154a8cf0"><td class="memItemLeft" align="right" valign="top"><a id="aab7d4bc865d0c7ccf361515a154a8cf0"></a>
<a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aab7d4bc865d0c7ccf361515a154a8cf0">AbsoluteTransformation</a></td></tr>
<tr class="memdesc:aab7d4bc865d0c7ccf361515a154a8cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute transformation of the node. <br /></td></tr>
<tr class="separator:aab7d4bc865d0c7ccf361515a154a8cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8af3d0185a787209b7be576a411281"><td class="memItemLeft" align="right" valign="top"><a id="a1d8af3d0185a787209b7be576a411281"></a>
<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a1d8af3d0185a787209b7be576a411281">RelativeTranslation</a></td></tr>
<tr class="memdesc:a1d8af3d0185a787209b7be576a411281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative translation of the scene node. <br /></td></tr>
<tr class="separator:a1d8af3d0185a787209b7be576a411281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fef4c36dcab69bbf94cf6e3e1323e1"><td class="memItemLeft" align="right" valign="top"><a id="a83fef4c36dcab69bbf94cf6e3e1323e1"></a>
<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a83fef4c36dcab69bbf94cf6e3e1323e1">RelativeRotation</a></td></tr>
<tr class="memdesc:a83fef4c36dcab69bbf94cf6e3e1323e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative rotation of the scene node. <br /></td></tr>
<tr class="separator:a83fef4c36dcab69bbf94cf6e3e1323e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e41eb5e7a5baf51350ec627a458a3d"><td class="memItemLeft" align="right" valign="top"><a id="a76e41eb5e7a5baf51350ec627a458a3d"></a>
<a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a76e41eb5e7a5baf51350ec627a458a3d">RelativeScale</a></td></tr>
<tr class="memdesc:a76e41eb5e7a5baf51350ec627a458a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative scale of the scene node. <br /></td></tr>
<tr class="separator:a76e41eb5e7a5baf51350ec627a458a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685d6b14961688be135e6084c21a025"><td class="memItemLeft" align="right" valign="top"><a id="ad685d6b14961688be135e6084c21a025"></a>
<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ad685d6b14961688be135e6084c21a025">Parent</a></td></tr>
<tr class="memdesc:ad685d6b14961688be135e6084c21a025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the parent. <br /></td></tr>
<tr class="separator:ad685d6b14961688be135e6084c21a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cf45268a3b60f3fa6ac04246511800"><td class="memItemLeft" align="right" valign="top"><a id="a48cf45268a3b60f3fa6ac04246511800"></a>
<a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a48cf45268a3b60f3fa6ac04246511800">Children</a></td></tr>
<tr class="memdesc:a48cf45268a3b60f3fa6ac04246511800"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all children of this node. <br /></td></tr>
<tr class="separator:a48cf45268a3b60f3fa6ac04246511800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424997b1b2f66f1db98dea3c2b8b0ffc"><td class="memItemLeft" align="right" valign="top"><a id="a424997b1b2f66f1db98dea3c2b8b0ffc"></a>
<a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a424997b1b2f66f1db98dea3c2b8b0ffc">Animators</a></td></tr>
<tr class="memdesc:a424997b1b2f66f1db98dea3c2b8b0ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all animator nodes. <br /></td></tr>
<tr class="separator:a424997b1b2f66f1db98dea3c2b8b0ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679d313cbe74b0c62285494a54334311"><td class="memItemLeft" align="right" valign="top"><a id="a679d313cbe74b0c62285494a54334311"></a>
<a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a679d313cbe74b0c62285494a54334311">SceneManager</a></td></tr>
<tr class="memdesc:a679d313cbe74b0c62285494a54334311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the scene manager. <br /></td></tr>
<tr class="separator:a679d313cbe74b0c62285494a54334311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a8af9768196d3fd00f79f8a441600c"><td class="memItemLeft" align="right" valign="top"><a id="a91a8af9768196d3fd00f79f8a441600c"></a>
<a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a91a8af9768196d3fd00f79f8a441600c">TriangleSelector</a></td></tr>
<tr class="memdesc:a91a8af9768196d3fd00f79f8a441600c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the triangle selector. <br /></td></tr>
<tr class="separator:a91a8af9768196d3fd00f79f8a441600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001b5cf9866fae4092b9b2cc89f3ebef"><td class="memItemLeft" align="right" valign="top"><a id="a001b5cf9866fae4092b9b2cc89f3ebef"></a>
<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a001b5cf9866fae4092b9b2cc89f3ebef">ID</a></td></tr>
<tr class="memdesc:a001b5cf9866fae4092b9b2cc89f3ebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of the node. <br /></td></tr>
<tr class="separator:a001b5cf9866fae4092b9b2cc89f3ebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0906d6df682ef3b1cbbe117907c0b995"><td class="memItemLeft" align="right" valign="top"><a id="a0906d6df682ef3b1cbbe117907c0b995"></a>
<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a0906d6df682ef3b1cbbe117907c0b995">AutomaticCullingState</a></td></tr>
<tr class="memdesc:a0906d6df682ef3b1cbbe117907c0b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic culling state. <br /></td></tr>
<tr class="separator:a0906d6df682ef3b1cbbe117907c0b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223a66d82d1c56e5f3730aeb9f83589c"><td class="memItemLeft" align="right" valign="top"><a id="a223a66d82d1c56e5f3730aeb9f83589c"></a>
<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a223a66d82d1c56e5f3730aeb9f83589c">DebugDataVisible</a></td></tr>
<tr class="memdesc:a223a66d82d1c56e5f3730aeb9f83589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag if debug data should be drawn, such as Bounding Boxes. <br /></td></tr>
<tr class="separator:a223a66d82d1c56e5f3730aeb9f83589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa834128c57215457914ef46d9b18cc5e"><td class="memItemLeft" align="right" valign="top"><a id="aa834128c57215457914ef46d9b18cc5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aa834128c57215457914ef46d9b18cc5e">IsVisible</a></td></tr>
<tr class="memdesc:aa834128c57215457914ef46d9b18cc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the node visible? <br /></td></tr>
<tr class="separator:aa834128c57215457914ef46d9b18cc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1ba7c5e77eecc2adc6d12df0d27dd6"><td class="memItemLeft" align="right" valign="top"><a id="a8f1ba7c5e77eecc2adc6d12df0d27dd6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8f1ba7c5e77eecc2adc6d12df0d27dd6">IsDebugObject</a></td></tr>
<tr class="memdesc:a8f1ba7c5e77eecc2adc6d12df0d27dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is debug object? <br /></td></tr>
<tr class="separator:a8f1ba7c5e77eecc2adc6d12df0d27dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Scene node interface. </p>
<p>A scene node is a node in the hierarchical scene graph. Every scene node may have children, which are also scene nodes. Children move relative to their parent's position. If the parent of a node is not visible, its children won't be visible either. In this way, it is for example easily possible to attach a light to a moving car, or to place a walking character on a moving platform on a moving ship. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e5cd342cd7293c136e53e2c2c5e0f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5cd342cd7293c136e53e2c2c5e0f3a">&#9670;&nbsp;</a></span>addAnimator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::addAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td>
          <td class="paramname"><em>animator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an animator which should animate this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">animator</td><td>A pointer to the new animator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e5cd342cd7293c136e53e2c2c5e0f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5cd342cd7293c136e53e2c2c5e0f3a">&#9670;&nbsp;</a></span>addAnimator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::addAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td>
          <td class="paramname"><em>animator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an animator which should animate this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">animator</td><td>A pointer to the new animator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acceef4fbb68f6cc7bb40035225350970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceef4fbb68f6cc7bb40035225350970">&#9670;&nbsp;</a></span>addChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to this scene node. </p>
<p>If the scene node already has a parent it is first removed from the other parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A pointer to the new child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acceef4fbb68f6cc7bb40035225350970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceef4fbb68f6cc7bb40035225350970">&#9670;&nbsp;</a></span>addChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to this scene node. </p>
<p>If the scene node already has a parent it is first removed from the other parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A pointer to the new child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac39832b55855dc59196053adbaec95cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39832b55855dc59196053adbaec95cc">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneNode::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>newParent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td>
          <td class="paramname"><em>newManager</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of this scene node and its children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>An optional new parent. </td></tr>
    <tr><td class="paramname">newManager</td><td>An optional new scene manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created clone of this node. </dd></dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html#a47aabf6554e3f91bbb033edb8668cec8">irr::scene::IAnimatedMeshSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html#a47aabf6554e3f91bbb033edb8668cec8">irr::scene::IAnimatedMeshSceneNode</a>.</p>

</div>
</div>
<a id="ac39832b55855dc59196053adbaec95cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39832b55855dc59196053adbaec95cc">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneNode::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>newParent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td>
          <td class="paramname"><em>newManager</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of this scene node and its children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>An optional new parent. </td></tr>
    <tr><td class="paramname">newManager</td><td>An optional new scene manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created clone of this node. </dd></dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html#a47aabf6554e3f91bbb033edb8668cec8">irr::scene::IAnimatedMeshSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html#a47aabf6554e3f91bbb033edb8668cec8">irr::scene::IAnimatedMeshSceneNode</a>.</p>

</div>
</div>
<a id="a00a4ef0212b5d4b005202519859689bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a4ef0212b5d4b005202519859689bd">&#9670;&nbsp;</a></span>cloneMembers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::cloneMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>toCopyFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td>
          <td class="paramname"><em>newManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clone function for the <a class="el" href="classirr_1_1scene_1_1ISceneNode.html" title="Scene node interface. ">ISceneNode</a> members. </p>
<p>This method can be used by <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac39832b55855dc59196053adbaec95cc" title="Creates a clone of this scene node and its children. ">clone()</a> implementations of derived classes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toCopyFrom</td><td>The node from which the values are copied </td></tr>
    <tr><td class="paramname">newManager</td><td>The new scene manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00a4ef0212b5d4b005202519859689bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a4ef0212b5d4b005202519859689bd">&#9670;&nbsp;</a></span>cloneMembers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::cloneMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>toCopyFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td>
          <td class="paramname"><em>newManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clone function for the <a class="el" href="classirr_1_1scene_1_1ISceneNode.html" title="Scene node interface. ">ISceneNode</a> members. </p>
<p>This method can be used by <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac39832b55855dc59196053adbaec95cc" title="Creates a clone of this scene node and its children. ">clone()</a> implementations of derived classes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toCopyFrom</td><td>The node from which the values are copied </td></tr>
    <tr><td class="paramname">newManager</td><td>The new scene manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb609b08fc89a92f928c19ce3b181eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb609b08fc89a92f928c19ce3b181eb">&#9670;&nbsp;</a></span>deserializeAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::deserializeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads attributes of the scene node. </p>
<p>Implement this to set the attributes of your scene node for scripting languages, editors, debuggers or xml deserialization purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The attribute container to read from. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the deserialization. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">irr::io::IAttributeExchangingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0df881cb5e2a55562399281061151ae8">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0df881cb5e2a55562399281061151ae8">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="a5fb609b08fc89a92f928c19ce3b181eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb609b08fc89a92f928c19ce3b181eb">&#9670;&nbsp;</a></span>deserializeAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::deserializeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads attributes of the scene node. </p>
<p>Implement this to set the attributes of your scene node for scripting languages, editors, debuggers or xml deserialization purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The attribute container to read from. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the deserialization. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a013d4ead3736d7fab4bc18c2d61a3e2e">irr::io::IAttributeExchangingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0df881cb5e2a55562399281061151ae8">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0df881cb5e2a55562399281061151ae8">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="a09a1c2ce3cf5448197a0c7b0bb16a516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a1c2ce3cf5448197a0c7b0bb16a516">&#9670;&nbsp;</a></span>getAbsolutePosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNode::getAbsolutePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the absolute position of the node in world coordinates. </p>
<p>If you want the position of the node relative to its parent, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af5686d35e868e7d295c2d2cb84799d20" title="Gets the position of the node relative to its parent. ">getPosition()</a> instead. NOTE: For speed reasons the absolute position is not automatically recalculated on each change of the relative position or by a position change of an parent. Instead the update usually happens once per frame in OnAnimate. You can enforce an update with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e" title="Updates the absolute position based on the relative and the parents position. ">updateAbsolutePosition()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The current absolute position of the scene node (updated on last call of updateAbsolutePosition). </dd></dl>

</div>
</div>
<a id="a09a1c2ce3cf5448197a0c7b0bb16a516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a1c2ce3cf5448197a0c7b0bb16a516">&#9670;&nbsp;</a></span>getAbsolutePosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> irr::scene::ISceneNode::getAbsolutePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the absolute position of the node in world coordinates. </p>
<p>If you want the position of the node relative to its parent, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af5686d35e868e7d295c2d2cb84799d20" title="Gets the position of the node relative to its parent. ">getPosition()</a> instead. NOTE: For speed reasons the absolute position is not automatically recalculated on each change of the relative position or by a position change of an parent. Instead the update usually happens once per frame in OnAnimate. You can enforce an update with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e" title="Updates the absolute position based on the relative and the parents position. ">updateAbsolutePosition()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The current absolute position of the scene node (updated on last call of updateAbsolutePosition). </dd></dl>

</div>
</div>
<a id="af13dc546a7be796cc0868a2eec51e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13dc546a7be796cc0868a2eec51e508">&#9670;&nbsp;</a></span>getAbsoluteTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&amp; irr::scene::ISceneNode::getAbsoluteTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute transformation of the node. Is recalculated every <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a>-call. </p>
<p>NOTE: For speed reasons the absolute transformation is not automatically recalculated on each change of the relative transformation or by a transformation change of an parent. Instead the update usually happens once per frame in OnAnimate. You can enforce an update with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e" title="Updates the absolute position based on the relative and the parents position. ">updateAbsolutePosition()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The absolute transformation matrix. </dd></dl>

</div>
</div>
<a id="af13dc546a7be796cc0868a2eec51e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13dc546a7be796cc0868a2eec51e508">&#9670;&nbsp;</a></span>getAbsoluteTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&amp; irr::scene::ISceneNode::getAbsoluteTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute transformation of the node. Is recalculated every <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a>-call. </p>
<p>NOTE: For speed reasons the absolute transformation is not automatically recalculated on each change of the relative transformation or by a transformation change of an parent. Instead the update usually happens once per frame in OnAnimate. You can enforce an update with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#aeb6e0dc034bb2101600ce87acbcf0f6e" title="Updates the absolute position based on the relative and the parents position. ">updateAbsolutePosition()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The absolute transformation matrix. </dd></dl>

</div>
</div>
<a id="a454fc115d9afa89623c55deba8a4add1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454fc115d9afa89623c55deba8a4add1">&#9670;&nbsp;</a></span>getAnimators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt;<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>*&gt;&amp; irr::scene::ISceneNode::getAnimators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all scene node animators. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of animators attached to this node. </dd></dl>

</div>
</div>
<a id="a454fc115d9afa89623c55deba8a4add1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454fc115d9afa89623c55deba8a4add1">&#9670;&nbsp;</a></span>getAnimators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt;<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>*&gt;&amp; irr::scene::ISceneNode::getAnimators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all scene node animators. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of animators attached to this node. </dd></dl>

</div>
</div>
<a id="a0748cd5c678e41a4fcff0514937c77be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748cd5c678e41a4fcff0514937c77be">&#9670;&nbsp;</a></span>getAutomaticCulling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::getAutomaticCulling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the automatic culling state. </p>
<dl class="section return"><dt>Returns</dt><dd>The automatic culling state. </dd></dl>

</div>
</div>
<a id="a0748cd5c678e41a4fcff0514937c77be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748cd5c678e41a4fcff0514937c77be">&#9670;&nbsp;</a></span>getAutomaticCulling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::getAutomaticCulling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the automatic culling state. </p>
<dl class="section return"><dt>Returns</dt><dd>The automatic culling state. </dd></dl>

</div>
</div>
<a id="a223f718fc2f4944b5ad28c592f6cc8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223f718fc2f4944b5ad28c592f6cc8c6">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&gt;&amp; irr::scene::ISceneNode::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the axis aligned, not transformed bounding box of this node. </p>
<p>This means that if this node is an animated 3d character, moving in a room, the bounding box will always be around the origin. To get the box in real world coordinates, just transform it with the matrix you receive with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a> or simply use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a77746edcc479107067fbf1f4471ab412" title="Get the axis aligned, transformed and animated absolute bounding box of this node. ">getTransformedBoundingBox()</a>, which does the same. </p><dl class="section return"><dt>Returns</dt><dd>The non-transformed bounding box. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#ac5d0a610b0a24a7501f29ad000d28b3b">irr::scene::IBoneSceneNode</a>, <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#ac5d0a610b0a24a7501f29ad000d28b3b">irr::scene::IBoneSceneNode</a>, <a class="el" href="classirr_1_1scene_1_1ITerrainSceneNode.html#a02a14fe28f5a326fca819c36bee2e92e">irr::scene::ITerrainSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ITerrainSceneNode.html#a02a14fe28f5a326fca819c36bee2e92e">irr::scene::ITerrainSceneNode</a>.</p>

</div>
</div>
<a id="a223f718fc2f4944b5ad28c592f6cc8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223f718fc2f4944b5ad28c592f6cc8c6">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&gt;&amp; irr::scene::ISceneNode::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the axis aligned, not transformed bounding box of this node. </p>
<p>This means that if this node is an animated 3d character, moving in a room, the bounding box will always be around the origin. To get the box in real world coordinates, just transform it with the matrix you receive with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a> or simply use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a77746edcc479107067fbf1f4471ab412" title="Get the axis aligned, transformed and animated absolute bounding box of this node. ">getTransformedBoundingBox()</a>, which does the same. </p><dl class="section return"><dt>Returns</dt><dd>The non-transformed bounding box. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#ac5d0a610b0a24a7501f29ad000d28b3b">irr::scene::IBoneSceneNode</a>, <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#ac5d0a610b0a24a7501f29ad000d28b3b">irr::scene::IBoneSceneNode</a>, <a class="el" href="classirr_1_1scene_1_1ITerrainSceneNode.html#a02a14fe28f5a326fca819c36bee2e92e">irr::scene::ITerrainSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ITerrainSceneNode.html#a02a14fe28f5a326fca819c36bee2e92e">irr::scene::ITerrainSceneNode</a>.</p>

</div>
</div>
<a id="a9a0e01ebfbf9f05e0caa147b290ffaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0e01ebfbf9f05e0caa147b290ffaf5">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt;<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>*&gt;&amp; irr::scene::ISceneNode::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the list of all children. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of all children of this node. </dd></dl>

</div>
</div>
<a id="a9a0e01ebfbf9f05e0caa147b290ffaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0e01ebfbf9f05e0caa147b290ffaf5">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classirr_1_1core_1_1list.html">core::list</a>&lt;<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>*&gt;&amp; irr::scene::ISceneNode::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the list of all children. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of all children of this node. </dd></dl>

</div>
</div>
<a id="a1a3b5b32f54bc1b6617756fc48a2cb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3b5b32f54bc1b6617756fc48a2cb17">&#9670;&nbsp;</a></span>getID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::scene::ISceneNode::getID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of the scene node. </p>
<p>This id can be used to identify the node. </p><dl class="section return"><dt>Returns</dt><dd>The id. </dd></dl>

</div>
</div>
<a id="a1a3b5b32f54bc1b6617756fc48a2cb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3b5b32f54bc1b6617756fc48a2cb17">&#9670;&nbsp;</a></span>getID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::scene::ISceneNode::getID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of the scene node. </p>
<p>This id can be used to identify the node. </p><dl class="section return"><dt>Returns</dt><dd>The id. </dd></dl>

</div>
</div>
<a id="a1f44d8cf753b2e4c17c90d4fc2ed05b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f44d8cf753b2e4c17c90d4fc2ed05b2">&#9670;&nbsp;</a></span>getMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a>&amp; irr::scene::ISceneNode::getMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the material based on the zero based index i. </p>
<p>To get the amount of materials used by this scene node, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe" title="Get amount of materials used by this scene node. ">getMaterialCount()</a>. This function is needed for inserting the node into the scene hierarchy at an optimal position for minimizing renderstate changes, but can also be used to directly modify the material of a scene node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Zero based index. The maximal value is <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe" title="Get amount of materials used by this scene node. ">getMaterialCount()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The material at that index. </dd></dl>

</div>
</div>
<a id="a1f44d8cf753b2e4c17c90d4fc2ed05b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f44d8cf753b2e4c17c90d4fc2ed05b2">&#9670;&nbsp;</a></span>getMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a>&amp; irr::scene::ISceneNode::getMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the material based on the zero based index i. </p>
<p>To get the amount of materials used by this scene node, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe" title="Get amount of materials used by this scene node. ">getMaterialCount()</a>. This function is needed for inserting the node into the scene hierarchy at an optimal position for minimizing renderstate changes, but can also be used to directly modify the material of a scene node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Zero based index. The maximal value is <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a8e75e9baede63e31e6aa6e42e6c8ddfe" title="Get amount of materials used by this scene node. ">getMaterialCount()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The material at that index. </dd></dl>

</div>
</div>
<a id="a8e75e9baede63e31e6aa6e42e6c8ddfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e75e9baede63e31e6aa6e42e6c8ddfe">&#9670;&nbsp;</a></span>getMaterialCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::getMaterialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get amount of materials used by this scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>Current amount of materials of this scene node. </dd></dl>

</div>
</div>
<a id="a8e75e9baede63e31e6aa6e42e6c8ddfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e75e9baede63e31e6aa6e42e6c8ddfe">&#9670;&nbsp;</a></span>getMaterialCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::getMaterialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get amount of materials used by this scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>Current amount of materials of this scene node. </dd></dl>

</div>
</div>
<a id="ab0e72b38949f926a1929468cd2b1ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e72b38949f926a1929468cd2b1ce16">&#9670;&nbsp;</a></span>getName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a>* irr::scene::ISceneNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the node. </p>
<dl class="section return"><dt>Returns</dt><dd>Name as character string. </dd></dl>

</div>
</div>
<a id="ab0e72b38949f926a1929468cd2b1ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e72b38949f926a1929468cd2b1ce16">&#9670;&nbsp;</a></span>getName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a>* irr::scene::ISceneNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the node. </p>
<dl class="section return"><dt>Returns</dt><dd>Name as character string. </dd></dl>

</div>
</div>
<a id="adf77e3715d63e436cc691bf881c4eb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf77e3715d63e436cc691bf881c4eb5b">&#9670;&nbsp;</a></span>getParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a>* irr::scene::ISceneNode::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent of this scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent. </dd></dl>

</div>
</div>
<a id="adf77e3715d63e436cc691bf881c4eb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf77e3715d63e436cc691bf881c4eb5b">&#9670;&nbsp;</a></span>getParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a>* irr::scene::ISceneNode::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent of this scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent. </dd></dl>

</div>
</div>
<a id="af5686d35e868e7d295c2d2cb84799d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5686d35e868e7d295c2d2cb84799d20">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the node relative to its parent. </p>
<p>Note that the position is relative to the parent. If you want the position in world coordinates, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a09a1c2ce3cf5448197a0c7b0bb16a516" title="Gets the absolute position of the node in world coordinates. ">getAbsolutePosition()</a> instead. </p><dl class="section return"><dt>Returns</dt><dd>The current position of the node relative to the parent. </dd></dl>

</div>
</div>
<a id="af5686d35e868e7d295c2d2cb84799d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5686d35e868e7d295c2d2cb84799d20">&#9670;&nbsp;</a></span>getPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the node relative to its parent. </p>
<p>Note that the position is relative to the parent. If you want the position in world coordinates, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a09a1c2ce3cf5448197a0c7b0bb16a516" title="Gets the absolute position of the node in world coordinates. ">getAbsolutePosition()</a> instead. </p><dl class="section return"><dt>Returns</dt><dd>The current position of the node relative to the parent. </dd></dl>

</div>
</div>
<a id="ac7c47ec49174315af83cf5f5d24edb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c47ec49174315af83cf5f5d24edb24">&#9670;&nbsp;</a></span>getRelativeTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> irr::scene::ISceneNode::getRelativeTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the relative transformation of the scene node. </p>
<p>The relative transformation is stored internally as 3 vectors: translation, rotation and scale. To get the relative transformation matrix, it is calculated from these values. </p><dl class="section return"><dt>Returns</dt><dd>The relative transformation matrix. </dd></dl>

</div>
</div>
<a id="ac7c47ec49174315af83cf5f5d24edb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c47ec49174315af83cf5f5d24edb24">&#9670;&nbsp;</a></span>getRelativeTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> irr::scene::ISceneNode::getRelativeTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the relative transformation of the scene node. </p>
<p>The relative transformation is stored internally as 3 vectors: translation, rotation and scale. To get the relative transformation matrix, it is calculated from these values. </p><dl class="section return"><dt>Returns</dt><dd>The relative transformation matrix. </dd></dl>

</div>
</div>
<a id="acfef9f174e2398b479915791e4084061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfef9f174e2398b479915791e4084061">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rotation of the node relative to its parent. </p>
<p>Note that this is the relative rotation of the node. If you want the absolute rotation, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a>.<a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acfef9f174e2398b479915791e4084061" title="Gets the rotation of the node relative to its parent. ">getRotation()</a> </p><dl class="section return"><dt>Returns</dt><dd>Current relative rotation of the scene node. </dd></dl>

</div>
</div>
<a id="acfef9f174e2398b479915791e4084061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfef9f174e2398b479915791e4084061">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rotation of the node relative to its parent. </p>
<p>Note that this is the relative rotation of the node. If you want the absolute rotation, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a>.<a class="el" href="classirr_1_1scene_1_1ISceneNode.html#acfef9f174e2398b479915791e4084061" title="Gets the rotation of the node relative to its parent. ">getRotation()</a> </p><dl class="section return"><dt>Returns</dt><dd>Current relative rotation of the scene node. </dd></dl>

</div>
</div>
<a id="a97a5963f8b7b3cdf6fa196863c641c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a5963f8b7b3cdf6fa196863c641c1d">&#9670;&nbsp;</a></span>getScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scale of the scene node relative to its parent. </p>
<p>This is the scale of this node relative to its parent. If you want the absolute scale, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a>.<a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a97a5963f8b7b3cdf6fa196863c641c1d" title="Gets the scale of the scene node relative to its parent. ">getScale()</a> </p><dl class="section return"><dt>Returns</dt><dd>The scale of the scene node. </dd></dl>

</div>
</div>
<a id="a97a5963f8b7b3cdf6fa196863c641c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a5963f8b7b3cdf6fa196863c641c1d">&#9670;&nbsp;</a></span>getScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a>&amp; irr::scene::ISceneNode::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scale of the scene node relative to its parent. </p>
<p>This is the scale of this node relative to its parent. If you want the absolute scale, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#af13dc546a7be796cc0868a2eec51e508" title="Get the absolute transformation of the node. Is recalculated every OnAnimate()-call. ">getAbsoluteTransformation()</a>.<a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a97a5963f8b7b3cdf6fa196863c641c1d" title="Gets the scale of the scene node relative to its parent. ">getScale()</a> </p><dl class="section return"><dt>Returns</dt><dd>The scale of the scene node. </dd></dl>

</div>
</div>
<a id="a394f112e9b4a1c66f7d58e873a3f8a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394f112e9b4a1c66f7d58e873a3f8a1d">&#9670;&nbsp;</a></span>getSceneManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a>* irr::scene::ISceneNode::getSceneManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the scene manager for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's scene manager. </dd></dl>

</div>
</div>
<a id="a394f112e9b4a1c66f7d58e873a3f8a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394f112e9b4a1c66f7d58e873a3f8a1d">&#9670;&nbsp;</a></span>getSceneManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a>* irr::scene::ISceneNode::getSceneManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the scene manager for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's scene manager. </dd></dl>

</div>
</div>
<a id="a77746edcc479107067fbf1f4471ab412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77746edcc479107067fbf1f4471ab412">&#9670;&nbsp;</a></span>getTransformedBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&gt; irr::scene::ISceneNode::getTransformedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the axis aligned, transformed and animated absolute bounding box of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The transformed bounding box. </dd></dl>

</div>
</div>
<a id="a77746edcc479107067fbf1f4471ab412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77746edcc479107067fbf1f4471ab412">&#9670;&nbsp;</a></span>getTransformedBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&gt; irr::scene::ISceneNode::getTransformedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the axis aligned, transformed and animated absolute bounding box of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The transformed bounding box. </dd></dl>

</div>
</div>
<a id="ab820f7ccfdd317d3913316b6991ea5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab820f7ccfdd317d3913316b6991ea5d9">&#9670;&nbsp;</a></span>getTriangleSelector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a>* irr::scene::ISceneNode::getTriangleSelector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangle selector attached to this scene node. </p>
<p>The Selector can be used by the engine for doing collision detection. You can create a TriangleSelector with <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a266625379b1558e9be1dc062ea4e71f7" title="Creates a simple ITriangleSelector, based on a mesh. ">ISceneManager::createTriangleSelector()</a> or <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4ed7d3b34f4d0c70395b6d464fe32b96" title="Creates a Triangle Selector, optimized by an octree. ">ISceneManager::createOctreeTriangleSelector</a> and set it with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a87fb52ec54bf3ae117340d8defd1255f" title="Sets the triangle selector of the scene node. ">ISceneNode::setTriangleSelector()</a>. If a scene node got no triangle selector, but collision tests should be done with it, a triangle selector is created using the bounding box of the scene node. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the TriangleSelector or 0, if there is none. </dd></dl>

</div>
</div>
<a id="ab820f7ccfdd317d3913316b6991ea5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab820f7ccfdd317d3913316b6991ea5d9">&#9670;&nbsp;</a></span>getTriangleSelector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a>* irr::scene::ISceneNode::getTriangleSelector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangle selector attached to this scene node. </p>
<p>The Selector can be used by the engine for doing collision detection. You can create a TriangleSelector with <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a266625379b1558e9be1dc062ea4e71f7" title="Creates a simple ITriangleSelector, based on a mesh. ">ISceneManager::createTriangleSelector()</a> or <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4ed7d3b34f4d0c70395b6d464fe32b96" title="Creates a Triangle Selector, optimized by an octree. ">ISceneManager::createOctreeTriangleSelector</a> and set it with <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a87fb52ec54bf3ae117340d8defd1255f" title="Sets the triangle selector of the scene node. ">ISceneNode::setTriangleSelector()</a>. If a scene node got no triangle selector, but collision tests should be done with it, a triangle selector is created using the bounding box of the scene node. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the TriangleSelector or 0, if there is none. </dd></dl>

</div>
</div>
<a id="a3468b09e4afa009d2036efbea9c09b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3468b09e4afa009d2036efbea9c09b8c">&#9670;&nbsp;</a></span>getType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a> irr::scene::ISceneNode::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type of the scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of this node. </dd></dl>

</div>
</div>
<a id="a3468b09e4afa009d2036efbea9c09b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3468b09e4afa009d2036efbea9c09b8c">&#9670;&nbsp;</a></span>getType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a> irr::scene::ISceneNode::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type of the scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of this node. </dd></dl>

</div>
</div>
<a id="ad35515d81242e24c8b831bf29a555221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35515d81242e24c8b831bf29a555221">&#9670;&nbsp;</a></span>isDebugDataVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::isDebugDataVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if debug data like bounding boxes are drawn. </p>
<dl class="section return"><dt>Returns</dt><dd>A bitwise OR of the debug data values from <a class="el" href="namespaceirr_1_1scene.html#a52b664c4c988113735042b168fc32dbe">irr::scene::E_DEBUG_SCENE_TYPE</a> that are currently visible. </dd></dl>

</div>
</div>
<a id="ad35515d81242e24c8b831bf29a555221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35515d81242e24c8b831bf29a555221">&#9670;&nbsp;</a></span>isDebugDataVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneNode::isDebugDataVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if debug data like bounding boxes are drawn. </p>
<dl class="section return"><dt>Returns</dt><dd>A bitwise OR of the debug data values from <a class="el" href="namespaceirr_1_1scene.html#a52b664c4c988113735042b168fc32dbe">irr::scene::E_DEBUG_SCENE_TYPE</a> that are currently visible. </dd></dl>

</div>
</div>
<a id="a304529a50ee58361a84d1db012bbc476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304529a50ee58361a84d1db012bbc476">&#9670;&nbsp;</a></span>isDebugObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::ISceneNode::isDebugObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this scene node is a debug object. </p>
<p>Debug objects have some special properties, for example they can be easily excluded from collision detection or from serialization, etc. </p><dl class="section return"><dt>Returns</dt><dd>If this node is a debug object, true is returned. </dd></dl>

</div>
</div>
<a id="a304529a50ee58361a84d1db012bbc476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304529a50ee58361a84d1db012bbc476">&#9670;&nbsp;</a></span>isDebugObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::ISceneNode::isDebugObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this scene node is a debug object. </p>
<p>Debug objects have some special properties, for example they can be easily excluded from collision detection or from serialization, etc. </p><dl class="section return"><dt>Returns</dt><dd>If this node is a debug object, true is returned. </dd></dl>

</div>
</div>
<a id="a457fda8e5bca28a1c7af1691fefd4f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457fda8e5bca28a1c7af1691fefd4f75">&#9670;&nbsp;</a></span>isTrulyVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::isTrulyVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the node is truly visible, taking into accounts its parents' visibility. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the node and all its parents are visible, false if this or any parent node is invisible. </dd></dl>

</div>
</div>
<a id="a457fda8e5bca28a1c7af1691fefd4f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457fda8e5bca28a1c7af1691fefd4f75">&#9670;&nbsp;</a></span>isTrulyVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::isTrulyVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the node is truly visible, taking into accounts its parents' visibility. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the node and all its parents are visible, false if this or any parent node is invisible. </dd></dl>

</div>
</div>
<a id="a9e8e4e8be0055e8182eb26b055abf339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8e4e8be0055e8182eb26b055abf339">&#9670;&nbsp;</a></span>isVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the node should be visible (if all of its parents are visible). </p>
<p>This is only an option set by the user, but has nothing to do with geometry culling </p><dl class="section return"><dt>Returns</dt><dd>The requested visibility of the node, true means visible (if all parents are also visible). </dd></dl>

</div>
</div>
<a id="a9e8e4e8be0055e8182eb26b055abf339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8e4e8be0055e8182eb26b055abf339">&#9670;&nbsp;</a></span>isVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the node should be visible (if all of its parents are visible). </p>
<p>This is only an option set by the user, but has nothing to do with geometry culling </p><dl class="section return"><dt>Returns</dt><dd>The requested visibility of the node, true means visible (if all parents are also visible). </dd></dl>

</div>
</div>
<a id="afc1dcb5cb19116d0c7aa3d4ebdf04cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">&#9670;&nbsp;</a></span>OnAnimate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::OnAnimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>timeMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> is called just before rendering the whole scene. </p>
<p>Nodes may calculate or store animations here, and may do other useful things, depending on what they are. Also, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> should be called for all child scene nodes here. This method will be called once per frame, independent of whether the scene node is visible or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeMs</td><td>Current time in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#a7e21d0722e5b105e4d2a956bff110a7f">irr::scene::IBoneSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#a7e21d0722e5b105e4d2a956bff110a7f">irr::scene::IBoneSceneNode</a>.</p>

</div>
</div>
<a id="afc1dcb5cb19116d0c7aa3d4ebdf04cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1dcb5cb19116d0c7aa3d4ebdf04cc5">&#9670;&nbsp;</a></span>OnAnimate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::OnAnimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>timeMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> is called just before rendering the whole scene. </p>
<p>Nodes may calculate or store animations here, and may do other useful things, depending on what they are. Also, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#afc1dcb5cb19116d0c7aa3d4ebdf04cc5" title="OnAnimate() is called just before rendering the whole scene. ">OnAnimate()</a> should be called for all child scene nodes here. This method will be called once per frame, independent of whether the scene node is visible or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeMs</td><td>Current time in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#a7e21d0722e5b105e4d2a956bff110a7f">irr::scene::IBoneSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1IBoneSceneNode.html#a7e21d0722e5b105e4d2a956bff110a7f">irr::scene::IBoneSceneNode</a>.</p>

</div>
</div>
<a id="ac9795bfcb88dcaf8cba6ea3296e5d8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9795bfcb88dcaf8cba6ea3296e5d8d0">&#9670;&nbsp;</a></span>OnRegisterSceneNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::OnRegisterSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called just before the rendering process of the whole scene. </p>
<p>Nodes may register themselves in the render pipeline during this call, precalculate the geometry which should be renderered, and prevent their children from being able to register themselves if they are clipped by simply not calling their OnRegisterSceneNode method. If you are implementing your own scene node, you should overwrite this method with an implementation code looking like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classirr_1_1scene_1_1ISceneNode.html#aa834128c57215457914ef46d9b18cc5e">IsVisible</a>)</div><div class="line">    <a class="code" href="classirr_1_1scene_1_1ISceneNode.html#a679d313cbe74b0c62285494a54334311">SceneManager</a>-&gt;<a class="code" href="classirr_1_1scene_1_1ISceneManager.html#aaf17bdde6d4e9ef61a76f3b43100ecb8">registerNodeForRendering</a>(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><a class="code" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0">ISceneNode::OnRegisterSceneNode</a>();</div></div><!-- fragment --> 
</div>
</div>
<a id="ac9795bfcb88dcaf8cba6ea3296e5d8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9795bfcb88dcaf8cba6ea3296e5d8d0">&#9670;&nbsp;</a></span>OnRegisterSceneNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::OnRegisterSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called just before the rendering process of the whole scene. </p>
<p>Nodes may register themselves in the render pipeline during this call, precalculate the geometry which should be renderered, and prevent their children from being able to register themselves if they are clipped by simply not calling their OnRegisterSceneNode method. If you are implementing your own scene node, you should overwrite this method with an implementation code looking like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classirr_1_1scene_1_1ISceneNode.html#aa834128c57215457914ef46d9b18cc5e">IsVisible</a>)</div><div class="line">    <a class="code" href="classirr_1_1scene_1_1ISceneNode.html#a679d313cbe74b0c62285494a54334311">SceneManager</a>-&gt;<a class="code" href="classirr_1_1scene_1_1ISceneManager.html#aaf17bdde6d4e9ef61a76f3b43100ecb8">registerNodeForRendering</a>(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><a class="code" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0">ISceneNode::OnRegisterSceneNode</a>();</div></div><!-- fragment --> 
</div>
</div>
<a id="a2efa2670e29d6bb33b0dd99403b8b69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efa2670e29d6bb33b0dd99403b8b69c">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes this scene node from the scene. </p>
<p>If no other grab exists for this node, it will be deleted. </p>

</div>
</div>
<a id="a2efa2670e29d6bb33b0dd99403b8b69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efa2670e29d6bb33b0dd99403b8b69c">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes this scene node from the scene. </p>
<p>If no other grab exists for this node, it will be deleted. </p>

</div>
</div>
<a id="a348767bb5b9262d997067c50e079e5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348767bb5b9262d997067c50e079e5be">&#9670;&nbsp;</a></span>removeAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all children of this scene node. </p>
<p>The scene nodes found in the children list are also dropped and might be deleted if no other grab exists on them. </p>

</div>
</div>
<a id="a348767bb5b9262d997067c50e079e5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348767bb5b9262d997067c50e079e5be">&#9670;&nbsp;</a></span>removeAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all children of this scene node. </p>
<p>The scene nodes found in the children list are also dropped and might be deleted if no other grab exists on them. </p>

</div>
</div>
<a id="aaa67f8f91d4ec99f82955641f1f9e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa67f8f91d4ec99f82955641f1f9e521">&#9670;&nbsp;</a></span>removeAnimator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td>
          <td class="paramname"><em>animator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an animator from this scene node. </p>
<p>If the animator is found, it is also dropped and might be deleted if not other grab exists for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">animator</td><td>A pointer to the animator to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa67f8f91d4ec99f82955641f1f9e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa67f8f91d4ec99f82955641f1f9e521">&#9670;&nbsp;</a></span>removeAnimator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td>
          <td class="paramname"><em>animator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an animator from this scene node. </p>
<p>If the animator is found, it is also dropped and might be deleted if not other grab exists for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">animator</td><td>A pointer to the animator to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f198bd566e9a7290cbefa531d8d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f198bd566e9a7290cbefa531d8d31e">&#9670;&nbsp;</a></span>removeAnimators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAnimators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all animators from this scene node. </p>
<p>The animators might also be deleted if no other grab exists for them. </p>

</div>
</div>
<a id="a28f198bd566e9a7290cbefa531d8d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f198bd566e9a7290cbefa531d8d31e">&#9670;&nbsp;</a></span>removeAnimators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::removeAnimators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all animators from this scene node. </p>
<p>The animators might also be deleted if no other grab exists for them. </p>

</div>
</div>
<a id="a831e371142fc883c7dd229552e0340de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e371142fc883c7dd229552e0340de">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a child from this scene node. </p>
<p>If found in the children list, the child pointer is also dropped and might be deleted if no other grab exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A pointer to the child which shall be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the child was removed, and false if not, e.g. because it couldn't be found in the children list. </dd></dl>

</div>
</div>
<a id="a831e371142fc883c7dd229552e0340de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e371142fc883c7dd229552e0340de">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneNode::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a child from this scene node. </p>
<p>If found in the children list, the child pointer is also dropped and might be deleted if no other grab exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A pointer to the child which shall be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the child was removed, and false if not, e.g. because it couldn't be found in the children list. </dd></dl>

</div>
</div>
<a id="a3210345b70227c03c7f889c94754fdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3210345b70227c03c7f889c94754fdaa">&#9670;&nbsp;</a></span>serializeAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::serializeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes attributes of the scene node. </p>
<p>Implement this to expose the attributes of your scene node for scripting languages, editors, debuggers or xml serialization purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The attribute container to write into. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the serialization. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">irr::io::IAttributeExchangingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0a78a29638be1665ee5dba22c2c3b846">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0a78a29638be1665ee5dba22c2c3b846">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="a3210345b70227c03c7f889c94754fdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3210345b70227c03c7f889c94754fdaa">&#9670;&nbsp;</a></span>serializeAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::serializeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes attributes of the scene node. </p>
<p>Implement this to expose the attributes of your scene node for scripting languages, editors, debuggers or xml serialization purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The attribute container to write into. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the serialization. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classirr_1_1io_1_1IAttributeExchangingObject.html#a587f7b633366968f0488e1099e9172ef">irr::io::IAttributeExchangingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0a78a29638be1665ee5dba22c2c3b846">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a0a78a29638be1665ee5dba22c2c3b846">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="a5fcd62dbf524b8d2d6daa61c7d6cf119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd62dbf524b8d2d6daa61c7d6cf119">&#9670;&nbsp;</a></span>setAutomaticCulling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setAutomaticCulling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables automatic culling based on the bounding box. </p>
<p>Automatic culling is enabled by default. Note that not all SceneNodes support culling and that some nodes always cull their geometry because it is their only reason for existence, for example the OctreeSceneNode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The culling state to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fcd62dbf524b8d2d6daa61c7d6cf119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd62dbf524b8d2d6daa61c7d6cf119">&#9670;&nbsp;</a></span>setAutomaticCulling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setAutomaticCulling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables automatic culling based on the bounding box. </p>
<p>Automatic culling is enabled by default. Note that not all SceneNodes support culling and that some nodes always cull their geometry because it is their only reason for existence, for example the OctreeSceneNode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The culling state to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83877ca84fa9cde95f099f961e80577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83877ca84fa9cde95f099f961e80577">&#9670;&nbsp;</a></span>setDebugDataVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setDebugDataVisible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if debug data like bounding boxes should be drawn. </p>
<p>A bitwise OR of the types from <a class="el" href="namespaceirr_1_1scene.html#a52b664c4c988113735042b168fc32dbe">irr::scene::E_DEBUG_SCENE_TYPE</a>. Please note that not all scene nodes support all debug data types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The debug data visibility state to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83877ca84fa9cde95f099f961e80577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83877ca84fa9cde95f099f961e80577">&#9670;&nbsp;</a></span>setDebugDataVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setDebugDataVisible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if debug data like bounding boxes should be drawn. </p>
<p>A bitwise OR of the types from <a class="el" href="namespaceirr_1_1scene.html#a52b664c4c988113735042b168fc32dbe">irr::scene::E_DEBUG_SCENE_TYPE</a>. Please note that not all scene nodes support all debug data types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The debug data visibility state to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade60c630c4768200b1d15debbd00fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade60c630c4768200b1d15debbd00fe0e">&#9670;&nbsp;</a></span>setID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the id of the scene node. </p>
<p>This id can be used to identify the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The new id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade60c630c4768200b1d15debbd00fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade60c630c4768200b1d15debbd00fe0e">&#9670;&nbsp;</a></span>setID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the id of the scene node. </p>
<p>This id can be used to identify the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The new id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ceda3eb747a353ffeda02c26e697cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceda3eb747a353ffeda02c26e697cbd">&#9670;&nbsp;</a></span>setIsDebugObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setIsDebugObject </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debugObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if this scene node is a debug object. </p>
<p>Debug objects have some special properties, for example they can be easily excluded from collision detection or from serialization, etc. </p>

</div>
</div>
<a id="a7ceda3eb747a353ffeda02c26e697cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceda3eb747a353ffeda02c26e697cbd">&#9670;&nbsp;</a></span>setIsDebugObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setIsDebugObject </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debugObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if this scene node is a debug object. </p>
<p>Debug objects have some special properties, for example they can be easily excluded from collision detection or from serialization, etc. </p>

</div>
</div>
<a id="a2841d5077854b9981711a403f33762cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2841d5077854b9981711a403f33762cd">&#9670;&nbsp;</a></span>setMaterialFlag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3">video::E_MATERIAL_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all material flags at once to a new value. </p>
<p>Useful, for example, if you want the whole mesh to be affected by light. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Which flag of all materials to be set. </td></tr>
    <tr><td class="paramname">newvalue</td><td>New value of that flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2841d5077854b9981711a403f33762cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2841d5077854b9981711a403f33762cd">&#9670;&nbsp;</a></span>setMaterialFlag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3">video::E_MATERIAL_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all material flags at once to a new value. </p>
<p>Useful, for example, if you want the whole mesh to be affected by light. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Which flag of all materials to be set. </td></tr>
    <tr><td class="paramname">newvalue</td><td>New value of that flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5d2e05ebe08e6a432fbb4fd1d28dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">&#9670;&nbsp;</a></span>setMaterialTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>textureLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture of the specified layer in all materials of this scene node to the new texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureLayer</td><td>Layer of texture to be set. Must be a value smaller than MATERIAL_MAX_TEXTURES. </td></tr>
    <tr><td class="paramname">texture</td><td>New texture to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5d2e05ebe08e6a432fbb4fd1d28dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5d2e05ebe08e6a432fbb4fd1d28dd0">&#9670;&nbsp;</a></span>setMaterialTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>textureLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture of the specified layer in all materials of this scene node to the new texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureLayer</td><td>Layer of texture to be set. Must be a value smaller than MATERIAL_MAX_TEXTURES. </td></tr>
    <tr><td class="paramname">texture</td><td>New texture to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302c7dedd776b52111823df5ed8446de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302c7dedd776b52111823df5ed8446de">&#9670;&nbsp;</a></span>setMaterialType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">video::E_MATERIAL_TYPE</a>&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the material type of all materials in this scene node to a new material type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newType</td><td>New type of material to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302c7dedd776b52111823df5ed8446de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302c7dedd776b52111823df5ed8446de">&#9670;&nbsp;</a></span>setMaterialType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::ISceneNode::setMaterialType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">video::E_MATERIAL_TYPE</a>&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the material type of all materials in this scene node to a new material type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newType</td><td>New type of material to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a810a54a2fc178b9a0e731513865f67d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810a54a2fc178b9a0e731513865f67d0">&#9670;&nbsp;</a></span>setName() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>New name of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a810a54a2fc178b9a0e731513865f67d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810a54a2fc178b9a0e731513865f67d0">&#9670;&nbsp;</a></span>setName() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>New name of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20a22d956974f4817a20663361f20042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a22d956974f4817a20663361f20042">&#9670;&nbsp;</a></span>setName() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>New name of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20a22d956974f4817a20663361f20042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a22d956974f4817a20663361f20042">&#9670;&nbsp;</a></span>setName() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>New name of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e7f36cb5c9c4895e06fce0ca5eb276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e7f36cb5c9c4895e06fce0ca5eb276">&#9670;&nbsp;</a></span>setParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the parent of the scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>The new parent to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e7f36cb5c9c4895e06fce0ca5eb276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e7f36cb5c9c4895e06fce0ca5eb276">&#9670;&nbsp;</a></span>setParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the parent of the scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>The new parent to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2166eb0a92cc0e46c49266f41a68ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2166eb0a92cc0e46c49266f41a68ed50">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>newpos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the position of the node relative to its parent. </p>
<p>Note that the position is relative to the parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpos</td><td>New relative position of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2166eb0a92cc0e46c49266f41a68ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2166eb0a92cc0e46c49266f41a68ed50">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>newpos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the position of the node relative to its parent. </p>
<p>Note that the position is relative to the parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpos</td><td>New relative position of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6ff54f52d3a9e1514cd487a550935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6ff54f52d3a9e1514cd487a550935c">&#9670;&nbsp;</a></span>setRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the rotation of the node relative to its parent. </p>
<p>This only modifies the relative rotation of the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>New rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#af95d5f50c192f212e11f3f050e92a470">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#af95d5f50c192f212e11f3f050e92a470">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="adb6ff54f52d3a9e1514cd487a550935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6ff54f52d3a9e1514cd487a550935c">&#9670;&nbsp;</a></span>setRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the rotation of the node relative to its parent. </p>
<p>This only modifies the relative rotation of the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>New rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#af95d5f50c192f212e11f3f050e92a470">irr::scene::ICameraSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#af95d5f50c192f212e11f3f050e92a470">irr::scene::ICameraSceneNode</a>.</p>

</div>
</div>
<a id="a1d710e1e20546bd89affe09fa943b0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d710e1e20546bd89affe09fa943b0e2">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the relative scale of the scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>New scale of the node, relative to its parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d710e1e20546bd89affe09fa943b0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d710e1e20546bd89affe09fa943b0e2">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the relative scale of the scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>New scale of the node, relative to its parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87fb52ec54bf3ae117340d8defd1255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fb52ec54bf3ae117340d8defd1255f">&#9670;&nbsp;</a></span>setTriangleSelector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setTriangleSelector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the triangle selector of the scene node. </p>
<p>The Selector can be used by the engine for doing collision detection. You can create a TriangleSelector with <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a266625379b1558e9be1dc062ea4e71f7" title="Creates a simple ITriangleSelector, based on a mesh. ">ISceneManager::createTriangleSelector()</a> or <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4ed7d3b34f4d0c70395b6d464fe32b96" title="Creates a Triangle Selector, optimized by an octree. ">ISceneManager::createOctreeTriangleSelector()</a>. Some nodes may create their own selector by default, so it would be good to check if there is already a selector in this node by calling <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab820f7ccfdd317d3913316b6991ea5d9" title="Returns the triangle selector attached to this scene node. ">ISceneNode::getTriangleSelector()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>New triangle selector for this scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87fb52ec54bf3ae117340d8defd1255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fb52ec54bf3ae117340d8defd1255f">&#9670;&nbsp;</a></span>setTriangleSelector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setTriangleSelector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ITriangleSelector.html">ITriangleSelector</a> *&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the triangle selector of the scene node. </p>
<p>The Selector can be used by the engine for doing collision detection. You can create a TriangleSelector with <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a266625379b1558e9be1dc062ea4e71f7" title="Creates a simple ITriangleSelector, based on a mesh. ">ISceneManager::createTriangleSelector()</a> or <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4ed7d3b34f4d0c70395b6d464fe32b96" title="Creates a Triangle Selector, optimized by an octree. ">ISceneManager::createOctreeTriangleSelector()</a>. Some nodes may create their own selector by default, so it would be good to check if there is already a selector in this node by calling <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ab820f7ccfdd317d3913316b6991ea5d9" title="Returns the triangle selector attached to this scene node. ">ISceneNode::getTriangleSelector()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>New triangle selector for this scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e3a88fe87d11caa7986a203afe6838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a88fe87d11caa7986a203afe6838c">&#9670;&nbsp;</a></span>setVisible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if the node should be visible or not. </p>
<p>All children of this node won't be visible either, when set to false. Invisible nodes are not valid candidates for selection by collision manager bounding box methods. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isVisible</td><td>If the node shall be visible. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html#a3a6a6681a665ec4c214cda8a84a29337">irr::scene::ILightSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html#a3a6a6681a665ec4c214cda8a84a29337">irr::scene::ILightSceneNode</a>.</p>

</div>
</div>
<a id="a2e3a88fe87d11caa7986a203afe6838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a88fe87d11caa7986a203afe6838c">&#9670;&nbsp;</a></span>setVisible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if the node should be visible or not. </p>
<p>All children of this node won't be visible either, when set to false. Invisible nodes are not valid candidates for selection by collision manager bounding box methods. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isVisible</td><td>If the node shall be visible. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html#a3a6a6681a665ec4c214cda8a84a29337">irr::scene::ILightSceneNode</a>, and <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html#a3a6a6681a665ec4c214cda8a84a29337">irr::scene::ILightSceneNode</a>.</p>

</div>
</div>
<a id="aeb6e0dc034bb2101600ce87acbcf0f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6e0dc034bb2101600ce87acbcf0f6e">&#9670;&nbsp;</a></span>updateAbsolutePosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::updateAbsolutePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the absolute position based on the relative and the parents position. </p>
<p>Note: This does not recursively update the parents absolute positions, so if you have a deeper hierarchy you might want to update the parents first. </p>

</div>
</div>
<a id="aeb6e0dc034bb2101600ce87acbcf0f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6e0dc034bb2101600ce87acbcf0f6e">&#9670;&nbsp;</a></span>updateAbsolutePosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneNode::updateAbsolutePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the absolute position based on the relative and the parents position. </p>
<p>Note: This does not recursively update the parents absolute positions, so if you have a deeper hierarchy you might want to update the parents first. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>indie_share/controller/include/<a class="el" href="indie__share_2controller_2include_2ISceneNode_8h_source.html">ISceneNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
