<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Indie Studio: irr::video::IVideoDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Indie Studio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1video.html">video</a></li><li class="navelem"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html">IVideoDriver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1video_1_1IVideoDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::video::IVideoDriver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface to driver which is able to perform 2d and 3d graphics functions.  
 <a href="classirr_1_1video_1_1IVideoDriver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indie__share_2controller_2include_2IVideoDriver_8h_source.html">IVideoDriver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::video::IVideoDriver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1video_1_1IVideoDriver.png" usemap="#irr::video::IVideoDriver_map" alt=""/>
  <map id="irr::video::IVideoDriver_map" name="irr::video::IVideoDriver_map">
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="0,0,140,24"/>
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="150,0,290,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a015b8f2f18c260a00a858181be1e9945"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945">beginScene</a> (bool backBuffer=true, bool zBuffer=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 0, 0, 0), const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;videoData=<a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>(), <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *sourceRect=0)=0</td></tr>
<tr class="memdesc:a015b8f2f18c260a00a858181be1e9945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applications must call this method before performing any rendering.  <a href="#a015b8f2f18c260a00a858181be1e9945">More...</a><br /></td></tr>
<tr class="separator:a015b8f2f18c260a00a858181be1e9945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f61a93c5fc9fdf161c044d27bc994e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a75f61a93c5fc9fdf161c044d27bc994e">endScene</a> ()=0</td></tr>
<tr class="memdesc:a75f61a93c5fc9fdf161c044d27bc994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the rendered image to the screen.  <a href="#a75f61a93c5fc9fdf161c044d27bc994e">More...</a><br /></td></tr>
<tr class="separator:a75f61a93c5fc9fdf161c044d27bc994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde468368b77441ada246e1603da4f47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#adde468368b77441ada246e1603da4f47">queryFeature</a> (<a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a> feature) const =0</td></tr>
<tr class="memdesc:adde468368b77441ada246e1603da4f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the features of the driver.  <a href="#adde468368b77441ada246e1603da4f47">More...</a><br /></td></tr>
<tr class="separator:adde468368b77441ada246e1603da4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea64c03fc205f23ec7575884fb7309c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aea64c03fc205f23ec7575884fb7309c8">disableFeature</a> (<a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a> feature, bool flag=true)=0</td></tr>
<tr class="memdesc:aea64c03fc205f23ec7575884fb7309c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a feature of the driver.  <a href="#aea64c03fc205f23ec7575884fb7309c8">More...</a><br /></td></tr>
<tr class="separator:aea64c03fc205f23ec7575884fb7309c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2b43d2215f2e5aad9b4f92aa635bcc85">getDriverAttributes</a> () const =0</td></tr>
<tr class="memdesc:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes of the actual video driver.  <a href="#a2b43d2215f2e5aad9b4f92aa635bcc85">More...</a><br /></td></tr>
<tr class="separator:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba84ee992939fc913d4935caffce87b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4ba84ee992939fc913d4935caffce87b">checkDriverReset</a> ()=0</td></tr>
<tr class="memdesc:a4ba84ee992939fc913d4935caffce87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the driver was recently reset.  <a href="#a4ba84ee992939fc913d4935caffce87b">More...</a><br /></td></tr>
<tr class="separator:a4ba84ee992939fc913d4935caffce87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf6e88bedf7b91666a2bd34f46e092fc">setTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a> state, const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;mat)=0</td></tr>
<tr class="memdesc:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transformation matrices.  <a href="#aaf6e88bedf7b91666a2bd34f46e092fc">More...</a><br /></td></tr>
<tr class="separator:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c7d04aee02c2d5d8102279f9233101"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a85c7d04aee02c2d5d8102279f9233101">getTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a> state) const =0</td></tr>
<tr class="memdesc:a85c7d04aee02c2d5d8102279f9233101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transformation set by setTransform.  <a href="#a85c7d04aee02c2d5d8102279f9233101">More...</a><br /></td></tr>
<tr class="separator:a85c7d04aee02c2d5d8102279f9233101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92535921ad01c90570533ba60b0b76b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a92535921ad01c90570533ba60b0b76b2">getImageLoaderCount</a> () const =0</td></tr>
<tr class="memdesc:a92535921ad01c90570533ba60b0b76b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of image loaders.  <a href="#a92535921ad01c90570533ba60b0b76b2">More...</a><br /></td></tr>
<tr class="separator:a92535921ad01c90570533ba60b0b76b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5cc08e7cd2ce2a30275e22ce13bb1013">getImageLoader</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> n)=0</td></tr>
<tr class="memdesc:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given image loader.  <a href="#a5cc08e7cd2ce2a30275e22ce13bb1013">More...</a><br /></td></tr>
<tr class="separator:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173f33f0537a1511abdf35ed235a683a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a173f33f0537a1511abdf35ed235a683a">getImageWriterCount</a> () const =0</td></tr>
<tr class="memdesc:a173f33f0537a1511abdf35ed235a683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of image writers.  <a href="#a173f33f0537a1511abdf35ed235a683a">More...</a><br /></td></tr>
<tr class="separator:a173f33f0537a1511abdf35ed235a683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc5e788993c117efebb22e155ab6a77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#acdc5e788993c117efebb22e155ab6a77">getImageWriter</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> n)=0</td></tr>
<tr class="memdesc:acdc5e788993c117efebb22e155ab6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given image writer.  <a href="#acdc5e788993c117efebb22e155ab6a77">More...</a><br /></td></tr>
<tr class="separator:acdc5e788993c117efebb22e155ab6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c9e31b41b7e6fd26cf65ce538ebab05">setMaterial</a> (const <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;material)=0</td></tr>
<tr class="memdesc:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a material.  <a href="#a8c9e31b41b7e6fd26cf65ce538ebab05">More...</a><br /></td></tr>
<tr class="separator:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4055165190e4adf221c6dc6f2434ea0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0">getTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:af4055165190e4adf221c6dc6f2434ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a named texture.  <a href="#af4055165190e4adf221c6dc6f2434ea0">More...</a><br /></td></tr>
<tr class="separator:af4055165190e4adf221c6dc6f2434ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf989c8688ffe2a28a4b8e7b6ec2bce7">getTexture</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a named texture.  <a href="#aaf989c8688ffe2a28a4b8e7b6ec2bce7">More...</a><br /></td></tr>
<tr class="separator:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe395b1320ac52cea6be0e912135351"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#abfe395b1320ac52cea6be0e912135351">getTextureByIndex</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)=0</td></tr>
<tr class="memdesc:abfe395b1320ac52cea6be0e912135351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a texture by index.  <a href="#abfe395b1320ac52cea6be0e912135351">More...</a><br /></td></tr>
<tr class="separator:abfe395b1320ac52cea6be0e912135351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3f976980dd8387db37feca8c8e2d73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4c3f976980dd8387db37feca8c8e2d73">getTextureCount</a> () const =0</td></tr>
<tr class="memdesc:a4c3f976980dd8387db37feca8c8e2d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of textures currently loaded.  <a href="#a4c3f976980dd8387db37feca8c8e2d73">More...</a><br /></td></tr>
<tr class="separator:a4c3f976980dd8387db37feca8c8e2d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2cefddb9ebd7f46ee946c04b301a5c5b">renameTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;newName)=0</td></tr>
<tr class="memdesc:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a texture.  <a href="#a2cefddb9ebd7f46ee946c04b301a5c5b">More...</a><br /></td></tr>
<tr class="separator:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c02ee280bb738cdf38b77e7a798244e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c02ee280bb738cdf38b77e7a798244e">addTexture</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829edac3d45e946a56d11bd43dc18661dfe7ec">ECF_A8R8G8B8</a>)=0</td></tr>
<tr class="memdesc:a8c02ee280bb738cdf38b77e7a798244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty texture of specified size.  <a href="#a8c02ee280bb738cdf38b77e7a798244e">More...</a><br /></td></tr>
<tr class="separator:a8c02ee280bb738cdf38b77e7a798244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebeb09a692c0d6b4741d952d97668e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#abfebeb09a692c0d6b4741d952d97668e">addTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name, <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, void *mipmapData=0)=0</td></tr>
<tr class="memdesc:abfebeb09a692c0d6b4741d952d97668e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture from an <a class="el" href="classirr_1_1video_1_1IImage.html" title="Interface for software image data. ">IImage</a>.  <a href="#abfebeb09a692c0d6b4741d952d97668e">More...</a><br /></td></tr>
<tr class="separator:abfebeb09a692c0d6b4741d952d97668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa704cece826ee37d02e4bb054b0b8797"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa704cece826ee37d02e4bb054b0b8797">addRenderTargetTexture</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name=&quot;rt&quot;, const <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">ECF_UNKNOWN</a>)=0</td></tr>
<tr class="memdesc:aa704cece826ee37d02e4bb054b0b8797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new render target texture to the texture cache.  <a href="#aa704cece826ee37d02e4bb054b0b8797">More...</a><br /></td></tr>
<tr class="separator:aa704cece826ee37d02e4bb054b0b8797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88319ec41daa23fef2ae935285afcc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac88319ec41daa23fef2ae935285afcc9">removeTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture)=0</td></tr>
<tr class="memdesc:ac88319ec41daa23fef2ae935285afcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a texture from the texture cache and deletes it.  <a href="#ac88319ec41daa23fef2ae935285afcc9">More...</a><br /></td></tr>
<tr class="separator:ac88319ec41daa23fef2ae935285afcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179990e76fa91175d46c891b3508e717"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a179990e76fa91175d46c891b3508e717">removeAllTextures</a> ()=0</td></tr>
<tr class="memdesc:a179990e76fa91175d46c891b3508e717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all textures from the texture cache and deletes them.  <a href="#a179990e76fa91175d46c891b3508e717">More...</a><br /></td></tr>
<tr class="separator:a179990e76fa91175d46c891b3508e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1454ef5ba92de420f35678e2803485f6"><td class="memItemLeft" align="right" valign="top"><a id="a1454ef5ba92de420f35678e2803485f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1454ef5ba92de420f35678e2803485f6">removeHardwareBuffer</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb)=0</td></tr>
<tr class="memdesc:a1454ef5ba92de420f35678e2803485f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove hardware buffer. <br /></td></tr>
<tr class="separator:a1454ef5ba92de420f35678e2803485f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538b3163d6e072f5b3deb905cb2abb0"><td class="memItemLeft" align="right" valign="top"><a id="a2538b3163d6e072f5b3deb905cb2abb0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2538b3163d6e072f5b3deb905cb2abb0">removeAllHardwareBuffers</a> ()=0</td></tr>
<tr class="memdesc:a2538b3163d6e072f5b3deb905cb2abb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all hardware buffers. <br /></td></tr>
<tr class="separator:a2538b3163d6e072f5b3deb905cb2abb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f15814e039772ee43be272e97d1633"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a07f15814e039772ee43be272e97d1633">addOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, const <a class="el" href="classirr_1_1scene_1_1IMesh.html">scene::IMesh</a> *mesh=0)=0</td></tr>
<tr class="memdesc:a07f15814e039772ee43be272e97d1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create occlusion query.  <a href="#a07f15814e039772ee43be272e97d1633">More...</a><br /></td></tr>
<tr class="separator:a07f15814e039772ee43be272e97d1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7d9cec8356edf3e16e264e476d849a"><td class="memItemLeft" align="right" valign="top"><a id="a9f7d9cec8356edf3e16e264e476d849a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9f7d9cec8356edf3e16e264e476d849a">removeOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a9f7d9cec8356edf3e16e264e476d849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove occlusion query. <br /></td></tr>
<tr class="separator:a9f7d9cec8356edf3e16e264e476d849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="memItemLeft" align="right" valign="top"><a id="a5d77478ed4e0896fd2fd8b8d042dc1ff"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5d77478ed4e0896fd2fd8b8d042dc1ff">removeAllOcclusionQueries</a> ()=0</td></tr>
<tr class="memdesc:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occlusion queries. <br /></td></tr>
<tr class="separator:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf92a35268dad06996c4f5edabec249f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf92a35268dad06996c4f5edabec249f">runOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, bool visible=false)=0</td></tr>
<tr class="memdesc:aaf92a35268dad06996c4f5edabec249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run occlusion query. Draws mesh stored in query.  <a href="#aaf92a35268dad06996c4f5edabec249f">More...</a><br /></td></tr>
<tr class="separator:aaf92a35268dad06996c4f5edabec249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ba500924a7d74fe74dd4724b737628"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae2ba500924a7d74fe74dd4724b737628">runAllOcclusionQueries</a> (bool visible=false)=0</td></tr>
<tr class="memdesc:ae2ba500924a7d74fe74dd4724b737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all occlusion queries. Draws all meshes stored in queries.  <a href="#ae2ba500924a7d74fe74dd4724b737628">More...</a><br /></td></tr>
<tr class="separator:ae2ba500924a7d74fe74dd4724b737628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626061128fcf018516c6d931bd616ea7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a626061128fcf018516c6d931bd616ea7">updateOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, bool block=true)=0</td></tr>
<tr class="memdesc:a626061128fcf018516c6d931bd616ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update occlusion query. Retrieves results from GPU.  <a href="#a626061128fcf018516c6d931bd616ea7">More...</a><br /></td></tr>
<tr class="separator:a626061128fcf018516c6d931bd616ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab611513a8cdb3cc62c29b864de0d1de7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab611513a8cdb3cc62c29b864de0d1de7">updateAllOcclusionQueries</a> (bool block=true)=0</td></tr>
<tr class="memdesc:ab611513a8cdb3cc62c29b864de0d1de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all occlusion queries. Retrieves results from GPU.  <a href="#ab611513a8cdb3cc62c29b864de0d1de7">More...</a><br /></td></tr>
<tr class="separator:ab611513a8cdb3cc62c29b864de0d1de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a149ea92e04b2d0fe18bf5b584ccf6de4">getOcclusionQueryResult</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node) const =0</td></tr>
<tr class="memdesc:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return query result.  <a href="#a149ea92e04b2d0fe18bf5b584ccf6de4">More...</a><br /></td></tr>
<tr class="separator:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701e7d2101eb26888f57928134bc2ffb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a701e7d2101eb26888f57928134bc2ffb">makeColorKeyTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> color, bool zeroTexels=false) const =0</td></tr>
<tr class="memdesc:a701e7d2101eb26888f57928134bc2ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a boolean alpha channel on the texture based on a color key.  <a href="#a701e7d2101eb26888f57928134bc2ffb">More...</a><br /></td></tr>
<tr class="separator:a701e7d2101eb26888f57928134bc2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed772902f4fe1185b44ce81b9b0b9add"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aed772902f4fe1185b44ce81b9b0b9add">makeColorKeyTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; colorKeyPixelPos, bool zeroTexels=false) const =0</td></tr>
<tr class="memdesc:aed772902f4fe1185b44ce81b9b0b9add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a boolean alpha channel on the texture based on the color at a position.  <a href="#aed772902f4fe1185b44ce81b9b0b9add">More...</a><br /></td></tr>
<tr class="separator:aed772902f4fe1185b44ce81b9b0b9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">makeNormalMapTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> amplitude=1.0f) const =0</td></tr>
<tr class="memdesc:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a normal map from a height map texture.  <a href="#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">More...</a><br /></td></tr>
<tr class="separator:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb">setRenderTarget</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, bool clearBackBuffer=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new render target.  <a href="#a8c38a8d8d6d49be53bda55eb0749e7eb">More...</a><br /></td></tr>
<tr class="separator:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad75e7606ab186f1e31cc126bcaaeba9c">setRenderTarget</a> (<a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">E_RENDER_TARGET</a> target, bool clearTarget=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set or reset special render targets  <a href="#ad75e7606ab186f1e31cc126bcaaeba9c">More...</a><br /></td></tr>
<tr class="separator:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="memItemLeft" align="right" valign="top"><a id="a1e2bd871ef54ae9bf16c3a49b318d777"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1e2bd871ef54ae9bf16c3a49b318d777">setRenderTarget</a> (const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; video::IRenderTarget &gt; &amp;texture, bool clearBackBuffer=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new multiple render targets. <br /></td></tr>
<tr class="separator:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af03cf9b67bb7b43a8021bbe4baa78a08">setViewPort</a> (const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;area)=0</td></tr>
<tr class="memdesc:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new viewport.  <a href="#af03cf9b67bb7b43a8021bbe4baa78a08">More...</a><br /></td></tr>
<tr class="separator:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21810374736559e937fcad30ac699b4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa21810374736559e937fcad30ac699b4">getViewPort</a> () const =0</td></tr>
<tr class="memdesc:aa21810374736559e937fcad30ac699b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of the current viewport.  <a href="#aa21810374736559e937fcad30ac699b4">More...</a><br /></td></tr>
<tr class="separator:aa21810374736559e937fcad30ac699b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">drawVertexPrimitiveList</a> (const void *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const void *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> primCount, <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a> vType=<a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a>, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> pType=<a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a>, E_INDEX_TYPE iType=EIT_16BIT)=0</td></tr>
<tr class="memdesc:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertex primitive list.  <a href="#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">More...</a><br /></td></tr>
<tr class="separator:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34845920167c68578a78f842af54d140"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a34845920167c68578a78f842af54d140">draw2DVertexPrimitiveList</a> (const void *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const void *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> primCount, <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a> vType=<a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a>, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> pType=<a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a>, E_INDEX_TYPE iType=EIT_16BIT)=0</td></tr>
<tr class="memdesc:a34845920167c68578a78f842af54d140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertex primitive list in 2d.  <a href="#a34845920167c68578a78f842af54d140">More...</a><br /></td></tr>
<tr class="separator:a34845920167c68578a78f842af54d140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eba6140492faaed9dca7e16ad8dde2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a55eba6140492faaed9dca7e16ad8dde2">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a55eba6140492faaed9dca7e16ad8dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a55eba6140492faaed9dca7e16ad8dde2">More...</a><br /></td></tr>
<tr class="separator:a55eba6140492faaed9dca7e16ad8dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a041d8028bc10f33c6707a3d1ddbdea4d">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a041d8028bc10f33c6707a3d1ddbdea4d">More...</a><br /></td></tr>
<tr class="separator:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09777bd8ca7a25e6f6134369e5dfb680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a09777bd8ca7a25e6f6134369e5dfb680">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a09777bd8ca7a25e6f6134369e5dfb680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a09777bd8ca7a25e6f6134369e5dfb680">More...</a><br /></td></tr>
<tr class="separator:a09777bd8ca7a25e6f6134369e5dfb680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8303b9a0f3e941d07d8cdc70c8fc1346">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#a8303b9a0f3e941d07d8cdc70c8fc1346">More...</a><br /></td></tr>
<tr class="separator:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8902326a78075ad1b12d0cfc722aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae0b8902326a78075ad1b12d0cfc722aa">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:ae0b8902326a78075ad1b12d0cfc722aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#ae0b8902326a78075ad1b12d0cfc722aa">More...</a><br /></td></tr>
<tr class="separator:ae0b8902326a78075ad1b12d0cfc722aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbc69e35e987b4d3882e51a62b8030b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7fbc69e35e987b4d3882e51a62b8030b">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a7fbc69e35e987b4d3882e51a62b8030b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#a7fbc69e35e987b4d3882e51a62b8030b">More...</a><br /></td></tr>
<tr class="separator:a7fbc69e35e987b4d3882e51a62b8030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5e4e03dca1720f3d2019b73a4eebb5e6">draw3DLine</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;start, const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;end, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d line.  <a href="#a5e4e03dca1720f3d2019b73a4eebb5e6">More...</a><br /></td></tr>
<tr class="separator:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eb03a333a43d17278dad31be19efca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac5eb03a333a43d17278dad31be19efca">draw3DTriangle</a> (const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;triangle, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:ac5eb03a333a43d17278dad31be19efca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d triangle.  <a href="#ac5eb03a333a43d17278dad31be19efca">More...</a><br /></td></tr>
<tr class="separator:ac5eb03a333a43d17278dad31be19efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7773fce9358ee81db5484b2d21015570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7773fce9358ee81db5484b2d21015570">draw3DBox</a> (const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;box, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a7773fce9358ee81db5484b2d21015570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d axis aligned box.  <a href="#a7773fce9358ee81db5484b2d21015570">More...</a><br /></td></tr>
<tr class="separator:a7773fce9358ee81db5484b2d21015570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f12aefefb24414e03876bca942fb02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac1f12aefefb24414e03876bca942fb02">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destPos)=0</td></tr>
<tr class="memdesc:ac1f12aefefb24414e03876bca942fb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d image without any special effects.  <a href="#ac1f12aefefb24414e03876bca942fb02">More...</a><br /></td></tr>
<tr class="separator:ac1f12aefefb24414e03876bca942fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a167d3a5e2ea5804bfa9ba9e526bbcdb3">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destPos, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;sourceRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d image using a color.  <a href="#a167d3a5e2ea5804bfa9ba9e526bbcdb3">More...</a><br /></td></tr>
<tr class="separator:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7647e900a56f23abb0809fd533617e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1b7647e900a56f23abb0809fd533617e">draw2DImageBatch</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;sourceRects, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;indices, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> kerningWidth=0, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a1b7647e900a56f23abb0809fd533617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a set of 2d images, using a color and the alpha channel of the texture.  <a href="#a1b7647e900a56f23abb0809fd533617e">More...</a><br /></td></tr>
<tr class="separator:a1b7647e900a56f23abb0809fd533617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6485a684c4dfa4d0f94d0edfb46439a6">draw2DImageBatch</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;positions, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;sourceRects, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a set of 2d images, using a color and the alpha channel of the texture.  <a href="#a6485a684c4dfa4d0f94d0edfb46439a6">More...</a><br /></td></tr>
<tr class="separator:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49258725a8c36dbb22d073acf7927354"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a49258725a8c36dbb22d073acf7927354">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;sourceRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, const <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> *const colors=0, bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a49258725a8c36dbb22d073acf7927354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used.  <a href="#a49258725a8c36dbb22d073acf7927354">More...</a><br /></td></tr>
<tr class="separator:a49258725a8c36dbb22d073acf7927354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f452fae0ef8abe01768a78ba7033b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac7f452fae0ef8abe01768a78ba7033b7">draw2DRectangle</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clip=0)=0</td></tr>
<tr class="memdesc:ac7f452fae0ef8abe01768a78ba7033b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d rectangle.  <a href="#ac7f452fae0ef8abe01768a78ba7033b7">More...</a><br /></td></tr>
<tr class="separator:ac7f452fae0ef8abe01768a78ba7033b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a83bb3c30be6c9f960a4d8b625d7dee8c">draw2DRectangle</a> (const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorLeftUp, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorRightUp, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorLeftDown, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorRightDown, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clip=0)=0</td></tr>
<tr class="memdesc:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d rectangle with a gradient.  <a href="#a83bb3c30be6c9f960a4d8b625d7dee8c">More...</a><br /></td></tr>
<tr class="separator:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65efe36e19f0570988848175a8af7bd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a65efe36e19f0570988848175a8af7bd1">draw2DRectangleOutline</a> (const <a class="el" href="namespaceirr_1_1core.html#a816a136b99c60f8c739005f7da7de914">core::recti</a> &amp;pos, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a65efe36e19f0570988848175a8af7bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the outline of a 2D rectangle.  <a href="#a65efe36e19f0570988848175a8af7bd1">More...</a><br /></td></tr>
<tr class="separator:a65efe36e19f0570988848175a8af7bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5388e319a0ae1340c3d81db02dd959"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7b5388e319a0ae1340c3d81db02dd959">draw2DLine</a> (const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;start, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;end, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a7b5388e319a0ae1340c3d81db02dd959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d line. Both start and end will be included in coloring.  <a href="#a7b5388e319a0ae1340c3d81db02dd959">More...</a><br /></td></tr>
<tr class="separator:a7b5388e319a0ae1340c3d81db02dd959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567ced74ed6dc8cb1b325493ae7a093"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6567ced74ed6dc8cb1b325493ae7a093">drawPixel</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> x, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> y, const <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;color)=0</td></tr>
<tr class="memdesc:a6567ced74ed6dc8cb1b325493ae7a093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a pixel.  <a href="#a6567ced74ed6dc8cb1b325493ae7a093">More...</a><br /></td></tr>
<tr class="separator:a6567ced74ed6dc8cb1b325493ae7a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1318379f3d70c9347cfa853b944ad4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf1318379f3d70c9347cfa853b944ad4">draw2DPolygon</a> (core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; center, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> radius, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(100, 255, 255, 255), <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> vertexCount=10)=0</td></tr>
<tr class="memdesc:aaf1318379f3d70c9347cfa853b944ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a non filled concyclic regular 2d polygon.  <a href="#aaf1318379f3d70c9347cfa853b944ad4">More...</a><br /></td></tr>
<tr class="separator:aaf1318379f3d70c9347cfa853b944ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae340fe71939b7c1043071507f3330cad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae340fe71939b7c1043071507f3330cad">drawStencilShadowVolume</a> (const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &gt; &amp;triangles, bool zfail=true, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> debugDataVisible=0)=0</td></tr>
<tr class="memdesc:ae340fe71939b7c1043071507f3330cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a shadow volume into the stencil buffer.  <a href="#ae340fe71939b7c1043071507f3330cad">More...</a><br /></td></tr>
<tr class="separator:ae340fe71939b7c1043071507f3330cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ea57c5cf23b7774044f6ed9f96579"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579">drawStencilShadow</a> (bool clearStencilBuffer=false, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> leftUpEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> rightUpEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> leftDownEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> rightDownEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a985ea57c5cf23b7774044f6ed9f96579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the stencil shadow with color.  <a href="#a985ea57c5cf23b7774044f6ed9f96579">More...</a><br /></td></tr>
<tr class="separator:a985ea57c5cf23b7774044f6ed9f96579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09507d0b00502912b75e31d2c344e5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab09507d0b00502912b75e31d2c344e5c">drawMeshBuffer</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb)=0</td></tr>
<tr class="memdesc:ab09507d0b00502912b75e31d2c344e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a mesh buffer.  <a href="#ab09507d0b00502912b75e31d2c344e5c">More...</a><br /></td></tr>
<tr class="separator:ab09507d0b00502912b75e31d2c344e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2ba3fb555e3c7622f3124799440226"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1c2ba3fb555e3c7622f3124799440226">drawMeshBufferNormals</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> length=10.f, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=0xffffffff)=0</td></tr>
<tr class="memdesc:a1c2ba3fb555e3c7622f3124799440226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws normals of a mesh buffer.  <a href="#a1c2ba3fb555e3c7622f3124799440226">More...</a><br /></td></tr>
<tr class="separator:a1c2ba3fb555e3c7622f3124799440226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cbb090b42198244c1703eb17024bbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af8cbb090b42198244c1703eb17024bbc">setFog</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(0, 255, 255, 255), <a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a> fogType=EFT_FOG_LINEAR, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> start=50.0f, f32 end=100.0f, f32 density=0.01f, bool pixelFog=false, bool rangeFog=false)=0</td></tr>
<tr class="memdesc:af8cbb090b42198244c1703eb17024bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fog mode.  <a href="#af8cbb090b42198244c1703eb17024bbc">More...</a><br /></td></tr>
<tr class="separator:af8cbb090b42198244c1703eb17024bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29435c6a654675bdb276c89fd4a1356c"><td class="memItemLeft" align="right" valign="top"><a id="a29435c6a654675bdb276c89fd4a1356c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a29435c6a654675bdb276c89fd4a1356c">getFog</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;color, <a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a> &amp;fogType, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;start, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;end, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;density, bool &amp;pixelFog, bool &amp;rangeFog)=0</td></tr>
<tr class="memdesc:a29435c6a654675bdb276c89fd4a1356c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fog mode. <br /></td></tr>
<tr class="separator:a29435c6a654675bdb276c89fd4a1356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afc8f27bfd9756f4ca8de2d4bb37b0e15">getColorFormat</a> () const =0</td></tr>
<tr class="memdesc:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current color format of the color buffer.  <a href="#afc8f27bfd9756f4ca8de2d4bb37b0e15">More...</a><br /></td></tr>
<tr class="separator:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106dd9ff233497f9ea9a07dc6441c82"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa106dd9ff233497f9ea9a07dc6441c82">getScreenSize</a> () const =0</td></tr>
<tr class="memdesc:aa106dd9ff233497f9ea9a07dc6441c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the screen or render window.  <a href="#aa106dd9ff233497f9ea9a07dc6441c82">More...</a><br /></td></tr>
<tr class="separator:aa106dd9ff233497f9ea9a07dc6441c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc2aba131b5986d07d92c6888cfc0c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a76fc2aba131b5986d07d92c6888cfc0c">getCurrentRenderTargetSize</a> () const =0</td></tr>
<tr class="memdesc:a76fc2aba131b5986d07d92c6888cfc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the current render target.  <a href="#a76fc2aba131b5986d07d92c6888cfc0c">More...</a><br /></td></tr>
<tr class="separator:a76fc2aba131b5986d07d92c6888cfc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71428402c0b6a3b18b8f2fa408af13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5b71428402c0b6a3b18b8f2fa408af13">getFPS</a> () const =0</td></tr>
<tr class="memdesc:a5b71428402c0b6a3b18b8f2fa408af13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current frames per second value.  <a href="#a5b71428402c0b6a3b18b8f2fa408af13">More...</a><br /></td></tr>
<tr class="separator:a5b71428402c0b6a3b18b8f2fa408af13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2ce9be45cacb4aa034d3afdb489a57a3">getPrimitiveCountDrawn</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> mode=0) const =0</td></tr>
<tr class="memdesc:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of primitives (mostly triangles) which were drawn in the last frame.  <a href="#a2ce9be45cacb4aa034d3afdb489a57a3">More...</a><br /></td></tr>
<tr class="separator:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="memItemLeft" align="right" valign="top"><a id="ab1bd29567ef6eb31a43bebe04c47eb5e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab1bd29567ef6eb31a43bebe04c47eb5e">deleteAllDynamicLights</a> ()=0</td></tr>
<tr class="memdesc:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dynamic lights which were previously added with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">addDynamicLight()</a>. <br /></td></tr>
<tr class="separator:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813a39352eae26c4d30b5882618639be"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be">addDynamicLight</a> (const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;light)=0</td></tr>
<tr class="memdesc:a813a39352eae26c4d30b5882618639be"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a dynamic light, returning an index to the light  <a href="#a813a39352eae26c4d30b5882618639be">More...</a><br /></td></tr>
<tr class="separator:a813a39352eae26c4d30b5882618639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a2875011c8870fd011a486f3503ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab64a2875011c8870fd011a486f3503ec">getMaximalDynamicLightAmount</a> () const =0</td></tr>
<tr class="memdesc:ab64a2875011c8870fd011a486f3503ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal amount of dynamic lights the device can handle.  <a href="#ab64a2875011c8870fd011a486f3503ec">More...</a><br /></td></tr>
<tr class="separator:ab64a2875011c8870fd011a486f3503ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1e5de698f264a9f74a17bdba313138"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b1e5de698f264a9f74a17bdba313138">getDynamicLightCount</a> () const =0</td></tr>
<tr class="memdesc:a9b1e5de698f264a9f74a17bdba313138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of dynamic lights currently set.  <a href="#a9b1e5de698f264a9f74a17bdba313138">More...</a><br /></td></tr>
<tr class="separator:a9b1e5de698f264a9f74a17bdba313138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9ee246e85a56300031f7d7516054e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9eb9ee246e85a56300031f7d7516054e">getDynamicLight</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx) const =0</td></tr>
<tr class="memdesc:a9eb9ee246e85a56300031f7d7516054e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns light data which was previously set by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">IVideoDriver::addDynamicLight()</a>.  <a href="#a9eb9ee246e85a56300031f7d7516054e">More...</a><br /></td></tr>
<tr class="separator:a9eb9ee246e85a56300031f7d7516054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26904f7d1bf0e37d51fe71562346a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a3c26904f7d1bf0e37d51fe71562346a0">turnLightOn</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> lightIndex, bool turnOn)=0</td></tr>
<tr class="memdesc:a3c26904f7d1bf0e37d51fe71562346a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a dynamic light on or off.  <a href="#a3c26904f7d1bf0e37d51fe71562346a0">More...</a><br /></td></tr>
<tr class="separator:a3c26904f7d1bf0e37d51fe71562346a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca51832295b2dceaa1e258daf863f1"><td class="memItemLeft" align="right" valign="top">virtual const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a87ca51832295b2dceaa1e258daf863f1">getName</a> () const =0</td></tr>
<tr class="memdesc:a87ca51832295b2dceaa1e258daf863f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets name of this video driver.  <a href="#a87ca51832295b2dceaa1e258daf863f1">More...</a><br /></td></tr>
<tr class="separator:a87ca51832295b2dceaa1e258daf863f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9479ae15f0e26eaaf15c9420ff289b6d">addExternalImageLoader</a> (<a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *loader)=0</td></tr>
<tr class="memdesc:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external image loader to the engine.  <a href="#a9479ae15f0e26eaaf15c9420ff289b6d">More...</a><br /></td></tr>
<tr class="separator:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56160e0d88346e04db921fbe4635a7ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a56160e0d88346e04db921fbe4635a7ae">addExternalImageWriter</a> (<a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *writer)=0</td></tr>
<tr class="memdesc:a56160e0d88346e04db921fbe4635a7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external image writer to the engine.  <a href="#a56160e0d88346e04db921fbe4635a7ae">More...</a><br /></td></tr>
<tr class="separator:a56160e0d88346e04db921fbe4635a7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93e778fac79f7863da72a50e720f88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afd93e778fac79f7863da72a50e720f88">getMaximalPrimitiveCount</a> () const =0</td></tr>
<tr class="memdesc:afd93e778fac79f7863da72a50e720f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum amount of primitives.  <a href="#afd93e778fac79f7863da72a50e720f88">More...</a><br /></td></tr>
<tr class="separator:afd93e778fac79f7863da72a50e720f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b58a6b86b9e4841ca3879ce246c4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e">setTextureCreationFlag</a> (<a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a> flag, bool enabled=true)=0</td></tr>
<tr class="memdesc:a868b58a6b86b9e4841ca3879ce246c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables a texture creation flag.  <a href="#a868b58a6b86b9e4841ca3879ce246c4e">More...</a><br /></td></tr>
<tr class="separator:a868b58a6b86b9e4841ca3879ce246c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae64d474cbca38f64f2dbb8fcacb1a035">getTextureCreationFlag</a> (<a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a> flag) const =0</td></tr>
<tr class="memdesc:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a texture creation flag is enabled or disabled.  <a href="#ae64d474cbca38f64f2dbb8fcacb1a035">More...</a><br /></td></tr>
<tr class="separator:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac5b4c13f64d96d27fa27f52b68f77b8c">createImageFromFile</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a file.  <a href="#ac5b4c13f64d96d27fa27f52b68f77b8c">More...</a><br /></td></tr>
<tr class="separator:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322c41fa08c1da9de4633cf8a1e68607"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a322c41fa08c1da9de4633cf8a1e68607">createImageFromFile</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:a322c41fa08c1da9de4633cf8a1e68607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a file.  <a href="#a322c41fa08c1da9de4633cf8a1e68607">More...</a><br /></td></tr>
<tr class="separator:a322c41fa08c1da9de4633cf8a1e68607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407d6a1483f995060035340e0a92ce9b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a407d6a1483f995060035340e0a92ce9b">writeImageToFile</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> param=0)=0</td></tr>
<tr class="memdesc:a407d6a1483f995060035340e0a92ce9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the provided image to a file.  <a href="#a407d6a1483f995060035340e0a92ce9b">More...</a><br /></td></tr>
<tr class="separator:a407d6a1483f995060035340e0a92ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12c362cfbc92a7c59b434666c8436c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae12c362cfbc92a7c59b434666c8436c0">writeImageToFile</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, <a class="el" href="classirr_1_1io_1_1IWriteFile.html">io::IWriteFile</a> *file, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> param=0)=0</td></tr>
<tr class="memdesc:ae12c362cfbc92a7c59b434666c8436c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the provided image to a file.  <a href="#ae12c362cfbc92a7c59b434666c8436c0">More...</a><br /></td></tr>
<tr class="separator:ae12c362cfbc92a7c59b434666c8436c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d60f2fcad42d8a79c33c587f41a06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a425d60f2fcad42d8a79c33c587f41a06">createImageFromData</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, void *data, bool ownForeignMemory=false, bool deleteMemory=true)=0</td></tr>
<tr class="memdesc:a425d60f2fcad42d8a79c33c587f41a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a byte array.  <a href="#a425d60f2fcad42d8a79c33c587f41a06">More...</a><br /></td></tr>
<tr class="separator:a425d60f2fcad42d8a79c33c587f41a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1578fdd92118665755f31c0dd1dbb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aee1578fdd92118665755f31c0dd1dbb5">createImage</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:aee1578fdd92118665755f31c0dd1dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty software image.  <a href="#aee1578fdd92118665755f31c0dd1dbb5">More...</a><br /></td></tr>
<tr class="separator:aee1578fdd92118665755f31c0dd1dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92ef735bc8c755f5c201a52a70d05e8"><td class="memItemLeft" align="right" valign="top">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af92ef735bc8c755f5c201a52a70d05e8">createImage</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *imageToCopy)=0</td></tr>
<tr class="memdesc:af92ef735bc8c755f5c201a52a70d05e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image by converting it to given format from another image.  <a href="#af92ef735bc8c755f5c201a52a70d05e8">More...</a><br /></td></tr>
<tr class="separator:af92ef735bc8c755f5c201a52a70d05e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06059abf33e473d7af77e1fbc2b0f75"><td class="memItemLeft" align="right" valign="top">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa06059abf33e473d7af77e1fbc2b0f75">createImage</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *imageToCopy, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:aa06059abf33e473d7af77e1fbc2b0f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a part of another image.  <a href="#aa06059abf33e473d7af77e1fbc2b0f75">More...</a><br /></td></tr>
<tr class="separator:aa06059abf33e473d7af77e1fbc2b0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e722e8dd2d750907e9e059c3dc8fae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a38e722e8dd2d750907e9e059c3dc8fae">createImage</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:a38e722e8dd2d750907e9e059c3dc8fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a part of a texture.  <a href="#a38e722e8dd2d750907e9e059c3dc8fae">More...</a><br /></td></tr>
<tr class="separator:a38e722e8dd2d750907e9e059c3dc8fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1a236e1233fc6fc2c5f36aaa830814fc">OnResize</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for resize events. Only used by the engine internally.  <a href="#a1a236e1233fc6fc2c5f36aaa830814fc">More...</a><br /></td></tr>
<tr class="separator:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6">addMaterialRenderer</a> (<a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *renderer, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name=0)=0</td></tr>
<tr class="memdesc:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new material renderer to the video device.  <a href="#a0dfc3a7168f3a73a6f4323b579f03ff6">More...</a><br /></td></tr>
<tr class="separator:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb321dfb32ad3c76efb99427bc90cc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#accb321dfb32ad3c76efb99427bc90cc8">getMaterialRenderer</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx)=0</td></tr>
<tr class="memdesc:accb321dfb32ad3c76efb99427bc90cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a material renderer by index.  <a href="#accb321dfb32ad3c76efb99427bc90cc8">More...</a><br /></td></tr>
<tr class="separator:accb321dfb32ad3c76efb99427bc90cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0e2e952afdcdbdd915dc106375381"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac1d0e2e952afdcdbdd915dc106375381">getMaterialRendererCount</a> () const =0</td></tr>
<tr class="memdesc:ac1d0e2e952afdcdbdd915dc106375381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of currently available material renderers.  <a href="#ac1d0e2e952afdcdbdd915dc106375381">More...</a><br /></td></tr>
<tr class="separator:ac1d0e2e952afdcdbdd915dc106375381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac6f8c53abcd5a24d94c84185b0ef65e0">getMaterialRendererName</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx) const =0</td></tr>
<tr class="memdesc:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of a material renderer.  <a href="#ac6f8c53abcd5a24d94c84185b0ef65e0">More...</a><br /></td></tr>
<tr class="separator:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef324ed93094f84832e8d31cf0776f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4ef324ed93094f84832e8d31cf0776f2">setMaterialRendererName</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> idx, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name)=0</td></tr>
<tr class="memdesc:a4ef324ed93094f84832e8d31cf0776f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of a material renderer.  <a href="#a4ef324ed93094f84832e8d31cf0776f2">More...</a><br /></td></tr>
<tr class="separator:a4ef324ed93094f84832e8d31cf0776f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4e496fec6b4b0b70d2e95b2576eaffee">createAttributesFromMaterial</a> (const <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;material, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)=0</td></tr>
<tr class="memdesc:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates material attributes list from a material.  <a href="#a4e496fec6b4b0b70d2e95b2576eaffee">More...</a><br /></td></tr>
<tr class="separator:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b7b5942cf2378f9f96d47ec7a0cd881">fillMaterialStructureFromAttributes</a> (<a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;outMaterial, <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *attributes)=0</td></tr>
<tr class="memdesc:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> structure from attributes.  <a href="#a9b7b5942cf2378f9f96d47ec7a0cd881">More...</a><br /></td></tr>
<tr class="separator:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3535b2125e654e2e9645745e50cc49"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4f3535b2125e654e2e9645745e50cc49">getExposedVideoData</a> ()=0</td></tr>
<tr class="memdesc:a4f3535b2125e654e2e9645745e50cc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns driver and operating system specific data about the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions. ">IVideoDriver</a>.  <a href="#a4f3535b2125e654e2e9645745e50cc49">More...</a><br /></td></tr>
<tr class="separator:a4f3535b2125e654e2e9645745e50cc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a0c4fcc0337f3befe8b90424e68aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0">E_DRIVER_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af89a0c4fcc0337f3befe8b90424e68aa">getDriverType</a> () const =0</td></tr>
<tr class="memdesc:af89a0c4fcc0337f3befe8b90424e68aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of video driver.  <a href="#af89a0c4fcc0337f3befe8b90424e68aa">More...</a><br /></td></tr>
<tr class="separator:af89a0c4fcc0337f3befe8b90424e68aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2098a408bbe9dad8053c3f4aea7d856"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html">IGPUProgrammingServices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad2098a408bbe9dad8053c3f4aea7d856">getGPUProgrammingServices</a> ()=0</td></tr>
<tr class="memdesc:ad2098a408bbe9dad8053c3f4aea7d856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a> interface.  <a href="#ad2098a408bbe9dad8053c3f4aea7d856">More...</a><br /></td></tr>
<tr class="separator:ad2098a408bbe9dad8053c3f4aea7d856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b76ea8ba013885c0f3d5f00131431ec"><td class="memItemLeft" align="right" valign="top"><a id="a9b76ea8ba013885c0f3d5f00131431ec"></a>
virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">scene::IMeshManipulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b76ea8ba013885c0f3d5f00131431ec">getMeshManipulator</a> ()=0</td></tr>
<tr class="memdesc:a9b76ea8ba013885c0f3d5f00131431ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the mesh manipulator. <br /></td></tr>
<tr class="separator:a9b76ea8ba013885c0f3d5f00131431ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a> ()=0</td></tr>
<tr class="memdesc:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the ZBuffer.  <a href="#a2036fe0a27dbd1a123ff5aedb07373a5">More...</a><br /></td></tr>
<tr class="separator:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db0e36d406089167facf70b2eb4706"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a50db0e36d406089167facf70b2eb4706">createScreenShot</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">video::ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">video::ECF_UNKNOWN</a>, <a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">video::E_RENDER_TARGET</a> target=<a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972a232d0f49241a378e11d4a37e752d3d73">video::ERT_FRAME_BUFFER</a>)=0</td></tr>
<tr class="memdesc:a50db0e36d406089167facf70b2eb4706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a screenshot of the last rendered frame.  <a href="#a50db0e36d406089167facf70b2eb4706">More...</a><br /></td></tr>
<tr class="separator:a50db0e36d406089167facf70b2eb4706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eaed6d56b092e6805400ca59795de9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad4eaed6d56b092e6805400ca59795de9">findTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:ad4eaed6d56b092e6805400ca59795de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the image is already loaded.  <a href="#ad4eaed6d56b092e6805400ca59795de9">More...</a><br /></td></tr>
<tr class="separator:ad4eaed6d56b092e6805400ca59795de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ac385891941e7ec8d99b2f105b265"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a959ac385891941e7ec8d99b2f105b265">setClipPlane</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, const <a class="el" href="namespaceirr_1_1core.html#a97c9b39d4c6f71dbd9ded0153c4fa7f7">core::plane3df</a> &amp;plane, bool enable=false)=0</td></tr>
<tr class="memdesc:a959ac385891941e7ec8d99b2f105b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or unset a clipping plane.  <a href="#a959ac385891941e7ec8d99b2f105b265">More...</a><br /></td></tr>
<tr class="separator:a959ac385891941e7ec8d99b2f105b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf9567c759f866311c76e3874822339"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaaf9567c759f866311c76e3874822339">enableClipPlane</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, bool enable)=0</td></tr>
<tr class="memdesc:aaaf9567c759f866311c76e3874822339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a clipping plane.  <a href="#aaaf9567c759f866311c76e3874822339">More...</a><br /></td></tr>
<tr class="separator:aaaf9567c759f866311c76e3874822339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cbd1329b4206503e9a9593592502ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a79cbd1329b4206503e9a9593592502ea">setMinHardwareBufferVertexCount</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> count)=0</td></tr>
<tr class="memdesc:a79cbd1329b4206503e9a9593592502ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of vertices for which a hw buffer will be created.  <a href="#a79cbd1329b4206503e9a9593592502ea">More...</a><br /></td></tr>
<tr class="separator:a79cbd1329b4206503e9a9593592502ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119ebfd02f99f77a463007277abf14a"><td class="memItemLeft" align="right" valign="top">virtual SOverrideMaterial &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af119ebfd02f99f77a463007277abf14a">getOverrideMaterial</a> ()=0</td></tr>
<tr class="memdesc:af119ebfd02f99f77a463007277abf14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global Material, which might override local materials.  <a href="#af119ebfd02f99f77a463007277abf14a">More...</a><br /></td></tr>
<tr class="separator:af119ebfd02f99f77a463007277abf14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a198bbe60fdb1b5d6d0f4921e8a26109c">getMaterial2D</a> ()=0</td></tr>
<tr class="memdesc:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2d override material for altering its values.  <a href="#a198bbe60fdb1b5d6d0f4921e8a26109c">More...</a><br /></td></tr>
<tr class="separator:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686a41fe0f506bb04c262f724f65756"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7686a41fe0f506bb04c262f724f65756">enableMaterial2D</a> (bool enable=true)=0</td></tr>
<tr class="memdesc:a7686a41fe0f506bb04c262f724f65756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the 2d override material.  <a href="#a7686a41fe0f506bb04c262f724f65756">More...</a><br /></td></tr>
<tr class="separator:a7686a41fe0f506bb04c262f724f65756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a3ee79676ad9fbebc39cf0150516e"><td class="memItemLeft" align="right" valign="top"><a id="a221a3ee79676ad9fbebc39cf0150516e"></a>
virtual <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a221a3ee79676ad9fbebc39cf0150516e">getVendorInfo</a> ()=0</td></tr>
<tr class="memdesc:a221a3ee79676ad9fbebc39cf0150516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the graphics card vendor name. <br /></td></tr>
<tr class="separator:a221a3ee79676ad9fbebc39cf0150516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8d96a8061264393fc74ac9a3cd04f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaba8d96a8061264393fc74ac9a3cd04f">setAmbientLight</a> (const <a class="el" href="classirr_1_1video_1_1SColorf.html">SColorf</a> &amp;color)=0</td></tr>
<tr class="memdesc:aaba8d96a8061264393fc74ac9a3cd04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used by the engine internally.  <a href="#aaba8d96a8061264393fc74ac9a3cd04f">More...</a><br /></td></tr>
<tr class="separator:aaba8d96a8061264393fc74ac9a3cd04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78022589e5b7cb42b4d6ed2f7950e42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af78022589e5b7cb42b4d6ed2f7950e42">setAllowZWriteOnTransparent</a> (bool flag)=0</td></tr>
<tr class="memdesc:af78022589e5b7cb42b4d6ed2f7950e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used by the engine internally.  <a href="#af78022589e5b7cb42b4d6ed2f7950e42">More...</a><br /></td></tr>
<tr class="separator:af78022589e5b7cb42b4d6ed2f7950e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc9632861757d167c035bb5ecfa6854"><td class="memItemLeft" align="right" valign="top"><a id="a9bc9632861757d167c035bb5ecfa6854"></a>
virtual <a class="el" href="namespaceirr_1_1core.html#a13e5bd7e47b2014eefc870ede11bbbbc">core::dimension2du</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9bc9632861757d167c035bb5ecfa6854">getMaxTextureSize</a> () const =0</td></tr>
<tr class="memdesc:a9bc9632861757d167c035bb5ecfa6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum texture size supported. <br /></td></tr>
<tr class="separator:a9bc9632861757d167c035bb5ecfa6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb541967dbb2def61997f1d69f68d5d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afb541967dbb2def61997f1d69f68d5d1">convertColor</a> (const void *sP, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> sF, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> sN, void *dP, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> dF) const =0</td></tr>
<tr class="memdesc:afb541967dbb2def61997f1d69f68d5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color conversion convenience function.  <a href="#afb541967dbb2def61997f1d69f68d5d1">More...</a><br /></td></tr>
<tr class="separator:afb541967dbb2def61997f1d69f68d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b8f2f18c260a00a858181be1e9945"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945">beginScene</a> (bool backBuffer=true, bool zBuffer=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 0, 0, 0), const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;videoData=<a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>(), <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *sourceRect=0)=0</td></tr>
<tr class="memdesc:a015b8f2f18c260a00a858181be1e9945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applications must call this method before performing any rendering.  <a href="#a015b8f2f18c260a00a858181be1e9945">More...</a><br /></td></tr>
<tr class="separator:a015b8f2f18c260a00a858181be1e9945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f61a93c5fc9fdf161c044d27bc994e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a75f61a93c5fc9fdf161c044d27bc994e">endScene</a> ()=0</td></tr>
<tr class="memdesc:a75f61a93c5fc9fdf161c044d27bc994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the rendered image to the screen.  <a href="#a75f61a93c5fc9fdf161c044d27bc994e">More...</a><br /></td></tr>
<tr class="separator:a75f61a93c5fc9fdf161c044d27bc994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde468368b77441ada246e1603da4f47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#adde468368b77441ada246e1603da4f47">queryFeature</a> (<a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a> feature) const =0</td></tr>
<tr class="memdesc:adde468368b77441ada246e1603da4f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the features of the driver.  <a href="#adde468368b77441ada246e1603da4f47">More...</a><br /></td></tr>
<tr class="separator:adde468368b77441ada246e1603da4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea64c03fc205f23ec7575884fb7309c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aea64c03fc205f23ec7575884fb7309c8">disableFeature</a> (<a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a> feature, bool flag=true)=0</td></tr>
<tr class="memdesc:aea64c03fc205f23ec7575884fb7309c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a feature of the driver.  <a href="#aea64c03fc205f23ec7575884fb7309c8">More...</a><br /></td></tr>
<tr class="separator:aea64c03fc205f23ec7575884fb7309c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2b43d2215f2e5aad9b4f92aa635bcc85">getDriverAttributes</a> () const =0</td></tr>
<tr class="memdesc:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes of the actual video driver.  <a href="#a2b43d2215f2e5aad9b4f92aa635bcc85">More...</a><br /></td></tr>
<tr class="separator:a2b43d2215f2e5aad9b4f92aa635bcc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba84ee992939fc913d4935caffce87b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4ba84ee992939fc913d4935caffce87b">checkDriverReset</a> ()=0</td></tr>
<tr class="memdesc:a4ba84ee992939fc913d4935caffce87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the driver was recently reset.  <a href="#a4ba84ee992939fc913d4935caffce87b">More...</a><br /></td></tr>
<tr class="separator:a4ba84ee992939fc913d4935caffce87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf6e88bedf7b91666a2bd34f46e092fc">setTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a> state, const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;mat)=0</td></tr>
<tr class="memdesc:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transformation matrices.  <a href="#aaf6e88bedf7b91666a2bd34f46e092fc">More...</a><br /></td></tr>
<tr class="separator:aaf6e88bedf7b91666a2bd34f46e092fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c7d04aee02c2d5d8102279f9233101"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a85c7d04aee02c2d5d8102279f9233101">getTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a> state) const =0</td></tr>
<tr class="memdesc:a85c7d04aee02c2d5d8102279f9233101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transformation set by setTransform.  <a href="#a85c7d04aee02c2d5d8102279f9233101">More...</a><br /></td></tr>
<tr class="separator:a85c7d04aee02c2d5d8102279f9233101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92535921ad01c90570533ba60b0b76b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a92535921ad01c90570533ba60b0b76b2">getImageLoaderCount</a> () const =0</td></tr>
<tr class="memdesc:a92535921ad01c90570533ba60b0b76b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of image loaders.  <a href="#a92535921ad01c90570533ba60b0b76b2">More...</a><br /></td></tr>
<tr class="separator:a92535921ad01c90570533ba60b0b76b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5cc08e7cd2ce2a30275e22ce13bb1013">getImageLoader</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> n)=0</td></tr>
<tr class="memdesc:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given image loader.  <a href="#a5cc08e7cd2ce2a30275e22ce13bb1013">More...</a><br /></td></tr>
<tr class="separator:a5cc08e7cd2ce2a30275e22ce13bb1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173f33f0537a1511abdf35ed235a683a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a173f33f0537a1511abdf35ed235a683a">getImageWriterCount</a> () const =0</td></tr>
<tr class="memdesc:a173f33f0537a1511abdf35ed235a683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of image writers.  <a href="#a173f33f0537a1511abdf35ed235a683a">More...</a><br /></td></tr>
<tr class="separator:a173f33f0537a1511abdf35ed235a683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc5e788993c117efebb22e155ab6a77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#acdc5e788993c117efebb22e155ab6a77">getImageWriter</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> n)=0</td></tr>
<tr class="memdesc:acdc5e788993c117efebb22e155ab6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given image writer.  <a href="#acdc5e788993c117efebb22e155ab6a77">More...</a><br /></td></tr>
<tr class="separator:acdc5e788993c117efebb22e155ab6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c9e31b41b7e6fd26cf65ce538ebab05">setMaterial</a> (const <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;material)=0</td></tr>
<tr class="memdesc:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a material.  <a href="#a8c9e31b41b7e6fd26cf65ce538ebab05">More...</a><br /></td></tr>
<tr class="separator:a8c9e31b41b7e6fd26cf65ce538ebab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4055165190e4adf221c6dc6f2434ea0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0">getTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:af4055165190e4adf221c6dc6f2434ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a named texture.  <a href="#af4055165190e4adf221c6dc6f2434ea0">More...</a><br /></td></tr>
<tr class="separator:af4055165190e4adf221c6dc6f2434ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf989c8688ffe2a28a4b8e7b6ec2bce7">getTexture</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a named texture.  <a href="#aaf989c8688ffe2a28a4b8e7b6ec2bce7">More...</a><br /></td></tr>
<tr class="separator:aaf989c8688ffe2a28a4b8e7b6ec2bce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe395b1320ac52cea6be0e912135351"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#abfe395b1320ac52cea6be0e912135351">getTextureByIndex</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)=0</td></tr>
<tr class="memdesc:abfe395b1320ac52cea6be0e912135351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a texture by index.  <a href="#abfe395b1320ac52cea6be0e912135351">More...</a><br /></td></tr>
<tr class="separator:abfe395b1320ac52cea6be0e912135351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3f976980dd8387db37feca8c8e2d73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4c3f976980dd8387db37feca8c8e2d73">getTextureCount</a> () const =0</td></tr>
<tr class="memdesc:a4c3f976980dd8387db37feca8c8e2d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of textures currently loaded.  <a href="#a4c3f976980dd8387db37feca8c8e2d73">More...</a><br /></td></tr>
<tr class="separator:a4c3f976980dd8387db37feca8c8e2d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2cefddb9ebd7f46ee946c04b301a5c5b">renameTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;newName)=0</td></tr>
<tr class="memdesc:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a texture.  <a href="#a2cefddb9ebd7f46ee946c04b301a5c5b">More...</a><br /></td></tr>
<tr class="separator:a2cefddb9ebd7f46ee946c04b301a5c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c02ee280bb738cdf38b77e7a798244e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c02ee280bb738cdf38b77e7a798244e">addTexture</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829edac3d45e946a56d11bd43dc18661dfe7ec">ECF_A8R8G8B8</a>)=0</td></tr>
<tr class="memdesc:a8c02ee280bb738cdf38b77e7a798244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty texture of specified size.  <a href="#a8c02ee280bb738cdf38b77e7a798244e">More...</a><br /></td></tr>
<tr class="separator:a8c02ee280bb738cdf38b77e7a798244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebeb09a692c0d6b4741d952d97668e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#abfebeb09a692c0d6b4741d952d97668e">addTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name, <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, void *mipmapData=0)=0</td></tr>
<tr class="memdesc:abfebeb09a692c0d6b4741d952d97668e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture from an <a class="el" href="classirr_1_1video_1_1IImage.html" title="Interface for software image data. ">IImage</a>.  <a href="#abfebeb09a692c0d6b4741d952d97668e">More...</a><br /></td></tr>
<tr class="separator:abfebeb09a692c0d6b4741d952d97668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa704cece826ee37d02e4bb054b0b8797"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa704cece826ee37d02e4bb054b0b8797">addRenderTargetTexture</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;name=&quot;rt&quot;, const <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">ECF_UNKNOWN</a>)=0</td></tr>
<tr class="memdesc:aa704cece826ee37d02e4bb054b0b8797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new render target texture to the texture cache.  <a href="#aa704cece826ee37d02e4bb054b0b8797">More...</a><br /></td></tr>
<tr class="separator:aa704cece826ee37d02e4bb054b0b8797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88319ec41daa23fef2ae935285afcc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac88319ec41daa23fef2ae935285afcc9">removeTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture)=0</td></tr>
<tr class="memdesc:ac88319ec41daa23fef2ae935285afcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a texture from the texture cache and deletes it.  <a href="#ac88319ec41daa23fef2ae935285afcc9">More...</a><br /></td></tr>
<tr class="separator:ac88319ec41daa23fef2ae935285afcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179990e76fa91175d46c891b3508e717"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a179990e76fa91175d46c891b3508e717">removeAllTextures</a> ()=0</td></tr>
<tr class="memdesc:a179990e76fa91175d46c891b3508e717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all textures from the texture cache and deletes them.  <a href="#a179990e76fa91175d46c891b3508e717">More...</a><br /></td></tr>
<tr class="separator:a179990e76fa91175d46c891b3508e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1454ef5ba92de420f35678e2803485f6"><td class="memItemLeft" align="right" valign="top"><a id="a1454ef5ba92de420f35678e2803485f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1454ef5ba92de420f35678e2803485f6">removeHardwareBuffer</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb)=0</td></tr>
<tr class="memdesc:a1454ef5ba92de420f35678e2803485f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove hardware buffer. <br /></td></tr>
<tr class="separator:a1454ef5ba92de420f35678e2803485f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538b3163d6e072f5b3deb905cb2abb0"><td class="memItemLeft" align="right" valign="top"><a id="a2538b3163d6e072f5b3deb905cb2abb0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2538b3163d6e072f5b3deb905cb2abb0">removeAllHardwareBuffers</a> ()=0</td></tr>
<tr class="memdesc:a2538b3163d6e072f5b3deb905cb2abb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all hardware buffers. <br /></td></tr>
<tr class="separator:a2538b3163d6e072f5b3deb905cb2abb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f15814e039772ee43be272e97d1633"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a07f15814e039772ee43be272e97d1633">addOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, const <a class="el" href="classirr_1_1scene_1_1IMesh.html">scene::IMesh</a> *mesh=0)=0</td></tr>
<tr class="memdesc:a07f15814e039772ee43be272e97d1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create occlusion query.  <a href="#a07f15814e039772ee43be272e97d1633">More...</a><br /></td></tr>
<tr class="separator:a07f15814e039772ee43be272e97d1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7d9cec8356edf3e16e264e476d849a"><td class="memItemLeft" align="right" valign="top"><a id="a9f7d9cec8356edf3e16e264e476d849a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9f7d9cec8356edf3e16e264e476d849a">removeOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a9f7d9cec8356edf3e16e264e476d849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove occlusion query. <br /></td></tr>
<tr class="separator:a9f7d9cec8356edf3e16e264e476d849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="memItemLeft" align="right" valign="top"><a id="a5d77478ed4e0896fd2fd8b8d042dc1ff"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5d77478ed4e0896fd2fd8b8d042dc1ff">removeAllOcclusionQueries</a> ()=0</td></tr>
<tr class="memdesc:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occlusion queries. <br /></td></tr>
<tr class="separator:a5d77478ed4e0896fd2fd8b8d042dc1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf92a35268dad06996c4f5edabec249f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf92a35268dad06996c4f5edabec249f">runOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, bool visible=false)=0</td></tr>
<tr class="memdesc:aaf92a35268dad06996c4f5edabec249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run occlusion query. Draws mesh stored in query.  <a href="#aaf92a35268dad06996c4f5edabec249f">More...</a><br /></td></tr>
<tr class="separator:aaf92a35268dad06996c4f5edabec249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ba500924a7d74fe74dd4724b737628"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae2ba500924a7d74fe74dd4724b737628">runAllOcclusionQueries</a> (bool visible=false)=0</td></tr>
<tr class="memdesc:ae2ba500924a7d74fe74dd4724b737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all occlusion queries. Draws all meshes stored in queries.  <a href="#ae2ba500924a7d74fe74dd4724b737628">More...</a><br /></td></tr>
<tr class="separator:ae2ba500924a7d74fe74dd4724b737628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626061128fcf018516c6d931bd616ea7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a626061128fcf018516c6d931bd616ea7">updateOcclusionQuery</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node, bool block=true)=0</td></tr>
<tr class="memdesc:a626061128fcf018516c6d931bd616ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update occlusion query. Retrieves results from GPU.  <a href="#a626061128fcf018516c6d931bd616ea7">More...</a><br /></td></tr>
<tr class="separator:a626061128fcf018516c6d931bd616ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab611513a8cdb3cc62c29b864de0d1de7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab611513a8cdb3cc62c29b864de0d1de7">updateAllOcclusionQueries</a> (bool block=true)=0</td></tr>
<tr class="memdesc:ab611513a8cdb3cc62c29b864de0d1de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all occlusion queries. Retrieves results from GPU.  <a href="#ab611513a8cdb3cc62c29b864de0d1de7">More...</a><br /></td></tr>
<tr class="separator:ab611513a8cdb3cc62c29b864de0d1de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a149ea92e04b2d0fe18bf5b584ccf6de4">getOcclusionQueryResult</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *node) const =0</td></tr>
<tr class="memdesc:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return query result.  <a href="#a149ea92e04b2d0fe18bf5b584ccf6de4">More...</a><br /></td></tr>
<tr class="separator:a149ea92e04b2d0fe18bf5b584ccf6de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701e7d2101eb26888f57928134bc2ffb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a701e7d2101eb26888f57928134bc2ffb">makeColorKeyTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> color, bool zeroTexels=false) const =0</td></tr>
<tr class="memdesc:a701e7d2101eb26888f57928134bc2ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a boolean alpha channel on the texture based on a color key.  <a href="#a701e7d2101eb26888f57928134bc2ffb">More...</a><br /></td></tr>
<tr class="separator:a701e7d2101eb26888f57928134bc2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed772902f4fe1185b44ce81b9b0b9add"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aed772902f4fe1185b44ce81b9b0b9add">makeColorKeyTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; colorKeyPixelPos, bool zeroTexels=false) const =0</td></tr>
<tr class="memdesc:aed772902f4fe1185b44ce81b9b0b9add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a boolean alpha channel on the texture based on the color at a position.  <a href="#aed772902f4fe1185b44ce81b9b0b9add">More...</a><br /></td></tr>
<tr class="separator:aed772902f4fe1185b44ce81b9b0b9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">makeNormalMapTexture</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> amplitude=1.0f) const =0</td></tr>
<tr class="memdesc:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a normal map from a height map texture.  <a href="#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">More...</a><br /></td></tr>
<tr class="separator:a6470e31c1aaf2c0fa5e5a5b3f8f092e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb">setRenderTarget</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, bool clearBackBuffer=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new render target.  <a href="#a8c38a8d8d6d49be53bda55eb0749e7eb">More...</a><br /></td></tr>
<tr class="separator:a8c38a8d8d6d49be53bda55eb0749e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad75e7606ab186f1e31cc126bcaaeba9c">setRenderTarget</a> (<a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">E_RENDER_TARGET</a> target, bool clearTarget=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set or reset special render targets  <a href="#ad75e7606ab186f1e31cc126bcaaeba9c">More...</a><br /></td></tr>
<tr class="separator:ad75e7606ab186f1e31cc126bcaaeba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="memItemLeft" align="right" valign="top"><a id="a1e2bd871ef54ae9bf16c3a49b318d777"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1e2bd871ef54ae9bf16c3a49b318d777">setRenderTarget</a> (const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; video::IRenderTarget &gt; &amp;texture, bool clearBackBuffer=true, bool <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a>=true, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new multiple render targets. <br /></td></tr>
<tr class="separator:a1e2bd871ef54ae9bf16c3a49b318d777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af03cf9b67bb7b43a8021bbe4baa78a08">setViewPort</a> (const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;area)=0</td></tr>
<tr class="memdesc:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new viewport.  <a href="#af03cf9b67bb7b43a8021bbe4baa78a08">More...</a><br /></td></tr>
<tr class="separator:af03cf9b67bb7b43a8021bbe4baa78a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21810374736559e937fcad30ac699b4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa21810374736559e937fcad30ac699b4">getViewPort</a> () const =0</td></tr>
<tr class="memdesc:aa21810374736559e937fcad30ac699b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of the current viewport.  <a href="#aa21810374736559e937fcad30ac699b4">More...</a><br /></td></tr>
<tr class="separator:aa21810374736559e937fcad30ac699b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">drawVertexPrimitiveList</a> (const void *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const void *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> primCount, <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a> vType=<a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a>, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> pType=<a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a>, E_INDEX_TYPE iType=EIT_16BIT)=0</td></tr>
<tr class="memdesc:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertex primitive list.  <a href="#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">More...</a><br /></td></tr>
<tr class="separator:ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34845920167c68578a78f842af54d140"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a34845920167c68578a78f842af54d140">draw2DVertexPrimitiveList</a> (const void *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const void *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> primCount, <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a> vType=<a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a>, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> pType=<a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a>, E_INDEX_TYPE iType=EIT_16BIT)=0</td></tr>
<tr class="memdesc:a34845920167c68578a78f842af54d140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertex primitive list in 2d.  <a href="#a34845920167c68578a78f842af54d140">More...</a><br /></td></tr>
<tr class="separator:a34845920167c68578a78f842af54d140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eba6140492faaed9dca7e16ad8dde2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a55eba6140492faaed9dca7e16ad8dde2">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a55eba6140492faaed9dca7e16ad8dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a55eba6140492faaed9dca7e16ad8dde2">More...</a><br /></td></tr>
<tr class="separator:a55eba6140492faaed9dca7e16ad8dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a041d8028bc10f33c6707a3d1ddbdea4d">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a041d8028bc10f33c6707a3d1ddbdea4d">More...</a><br /></td></tr>
<tr class="separator:a041d8028bc10f33c6707a3d1ddbdea4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09777bd8ca7a25e6f6134369e5dfb680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a09777bd8ca7a25e6f6134369e5dfb680">drawIndexedTriangleList</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a09777bd8ca7a25e6f6134369e5dfb680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle list.  <a href="#a09777bd8ca7a25e6f6134369e5dfb680">More...</a><br /></td></tr>
<tr class="separator:a09777bd8ca7a25e6f6134369e5dfb680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8303b9a0f3e941d07d8cdc70c8fc1346">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#a8303b9a0f3e941d07d8cdc70c8fc1346">More...</a><br /></td></tr>
<tr class="separator:a8303b9a0f3e941d07d8cdc70c8fc1346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8902326a78075ad1b12d0cfc722aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae0b8902326a78075ad1b12d0cfc722aa">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:ae0b8902326a78075ad1b12d0cfc722aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#ae0b8902326a78075ad1b12d0cfc722aa">More...</a><br /></td></tr>
<tr class="separator:ae0b8902326a78075ad1b12d0cfc722aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbc69e35e987b4d3882e51a62b8030b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7fbc69e35e987b4d3882e51a62b8030b">drawIndexedTriangleFan</a> (const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *vertices, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertexCount, const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *indexList, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> triangleCount)</td></tr>
<tr class="memdesc:a7fbc69e35e987b4d3882e51a62b8030b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an indexed triangle fan.  <a href="#a7fbc69e35e987b4d3882e51a62b8030b">More...</a><br /></td></tr>
<tr class="separator:a7fbc69e35e987b4d3882e51a62b8030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5e4e03dca1720f3d2019b73a4eebb5e6">draw3DLine</a> (const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;start, const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;end, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d line.  <a href="#a5e4e03dca1720f3d2019b73a4eebb5e6">More...</a><br /></td></tr>
<tr class="separator:a5e4e03dca1720f3d2019b73a4eebb5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eb03a333a43d17278dad31be19efca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac5eb03a333a43d17278dad31be19efca">draw3DTriangle</a> (const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;triangle, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:ac5eb03a333a43d17278dad31be19efca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d triangle.  <a href="#ac5eb03a333a43d17278dad31be19efca">More...</a><br /></td></tr>
<tr class="separator:ac5eb03a333a43d17278dad31be19efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7773fce9358ee81db5484b2d21015570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7773fce9358ee81db5484b2d21015570">draw3DBox</a> (const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;box, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a7773fce9358ee81db5484b2d21015570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3d axis aligned box.  <a href="#a7773fce9358ee81db5484b2d21015570">More...</a><br /></td></tr>
<tr class="separator:a7773fce9358ee81db5484b2d21015570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f12aefefb24414e03876bca942fb02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac1f12aefefb24414e03876bca942fb02">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destPos)=0</td></tr>
<tr class="memdesc:ac1f12aefefb24414e03876bca942fb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d image without any special effects.  <a href="#ac1f12aefefb24414e03876bca942fb02">More...</a><br /></td></tr>
<tr class="separator:ac1f12aefefb24414e03876bca942fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a167d3a5e2ea5804bfa9ba9e526bbcdb3">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destPos, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;sourceRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d image using a color.  <a href="#a167d3a5e2ea5804bfa9ba9e526bbcdb3">More...</a><br /></td></tr>
<tr class="separator:a167d3a5e2ea5804bfa9ba9e526bbcdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7647e900a56f23abb0809fd533617e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1b7647e900a56f23abb0809fd533617e">draw2DImageBatch</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;sourceRects, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;indices, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> kerningWidth=0, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a1b7647e900a56f23abb0809fd533617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a set of 2d images, using a color and the alpha channel of the texture.  <a href="#a1b7647e900a56f23abb0809fd533617e">More...</a><br /></td></tr>
<tr class="separator:a1b7647e900a56f23abb0809fd533617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6485a684c4dfa4d0f94d0edfb46439a6">draw2DImageBatch</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;positions, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;sourceRects, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a set of 2d images, using a color and the alpha channel of the texture.  <a href="#a6485a684c4dfa4d0f94d0edfb46439a6">More...</a><br /></td></tr>
<tr class="separator:a6485a684c4dfa4d0f94d0edfb46439a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49258725a8c36dbb22d073acf7927354"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a49258725a8c36dbb22d073acf7927354">draw2DImage</a> (const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;destRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;sourceRect, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clipRect=0, const <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> *const colors=0, bool useAlphaChannelOfTexture=false)=0</td></tr>
<tr class="memdesc:a49258725a8c36dbb22d073acf7927354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used.  <a href="#a49258725a8c36dbb22d073acf7927354">More...</a><br /></td></tr>
<tr class="separator:a49258725a8c36dbb22d073acf7927354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f452fae0ef8abe01768a78ba7033b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac7f452fae0ef8abe01768a78ba7033b7">draw2DRectangle</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clip=0)=0</td></tr>
<tr class="memdesc:ac7f452fae0ef8abe01768a78ba7033b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d rectangle.  <a href="#ac7f452fae0ef8abe01768a78ba7033b7">More...</a><br /></td></tr>
<tr class="separator:ac7f452fae0ef8abe01768a78ba7033b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a83bb3c30be6c9f960a4d8b625d7dee8c">draw2DRectangle</a> (const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorLeftUp, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorRightUp, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorLeftDown, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> colorRightDown, const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *clip=0)=0</td></tr>
<tr class="memdesc:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d rectangle with a gradient.  <a href="#a83bb3c30be6c9f960a4d8b625d7dee8c">More...</a><br /></td></tr>
<tr class="separator:a83bb3c30be6c9f960a4d8b625d7dee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65efe36e19f0570988848175a8af7bd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a65efe36e19f0570988848175a8af7bd1">draw2DRectangleOutline</a> (const <a class="el" href="namespaceirr_1_1core.html#a816a136b99c60f8c739005f7da7de914">core::recti</a> &amp;pos, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a65efe36e19f0570988848175a8af7bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the outline of a 2D rectangle.  <a href="#a65efe36e19f0570988848175a8af7bd1">More...</a><br /></td></tr>
<tr class="separator:a65efe36e19f0570988848175a8af7bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5388e319a0ae1340c3d81db02dd959"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7b5388e319a0ae1340c3d81db02dd959">draw2DLine</a> (const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;start, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;end, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255, 255, 255, 255))=0</td></tr>
<tr class="memdesc:a7b5388e319a0ae1340c3d81db02dd959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 2d line. Both start and end will be included in coloring.  <a href="#a7b5388e319a0ae1340c3d81db02dd959">More...</a><br /></td></tr>
<tr class="separator:a7b5388e319a0ae1340c3d81db02dd959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567ced74ed6dc8cb1b325493ae7a093"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a6567ced74ed6dc8cb1b325493ae7a093">drawPixel</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> x, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> y, const <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;color)=0</td></tr>
<tr class="memdesc:a6567ced74ed6dc8cb1b325493ae7a093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a pixel.  <a href="#a6567ced74ed6dc8cb1b325493ae7a093">More...</a><br /></td></tr>
<tr class="separator:a6567ced74ed6dc8cb1b325493ae7a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1318379f3d70c9347cfa853b944ad4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaf1318379f3d70c9347cfa853b944ad4">draw2DPolygon</a> (core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; center, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> radius, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(100, 255, 255, 255), <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> vertexCount=10)=0</td></tr>
<tr class="memdesc:aaf1318379f3d70c9347cfa853b944ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a non filled concyclic regular 2d polygon.  <a href="#aaf1318379f3d70c9347cfa853b944ad4">More...</a><br /></td></tr>
<tr class="separator:aaf1318379f3d70c9347cfa853b944ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae340fe71939b7c1043071507f3330cad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae340fe71939b7c1043071507f3330cad">drawStencilShadowVolume</a> (const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &gt; &amp;triangles, bool zfail=true, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> debugDataVisible=0)=0</td></tr>
<tr class="memdesc:ae340fe71939b7c1043071507f3330cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a shadow volume into the stencil buffer.  <a href="#ae340fe71939b7c1043071507f3330cad">More...</a><br /></td></tr>
<tr class="separator:ae340fe71939b7c1043071507f3330cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ea57c5cf23b7774044f6ed9f96579"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579">drawStencilShadow</a> (bool clearStencilBuffer=false, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> leftUpEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> rightUpEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> leftDownEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> rightDownEdge=<a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255, 0, 0, 0))=0</td></tr>
<tr class="memdesc:a985ea57c5cf23b7774044f6ed9f96579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the stencil shadow with color.  <a href="#a985ea57c5cf23b7774044f6ed9f96579">More...</a><br /></td></tr>
<tr class="separator:a985ea57c5cf23b7774044f6ed9f96579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09507d0b00502912b75e31d2c344e5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab09507d0b00502912b75e31d2c344e5c">drawMeshBuffer</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb)=0</td></tr>
<tr class="memdesc:ab09507d0b00502912b75e31d2c344e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a mesh buffer.  <a href="#ab09507d0b00502912b75e31d2c344e5c">More...</a><br /></td></tr>
<tr class="separator:ab09507d0b00502912b75e31d2c344e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2ba3fb555e3c7622f3124799440226"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1c2ba3fb555e3c7622f3124799440226">drawMeshBufferNormals</a> (const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *mb, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> length=10.f, <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=0xffffffff)=0</td></tr>
<tr class="memdesc:a1c2ba3fb555e3c7622f3124799440226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws normals of a mesh buffer.  <a href="#a1c2ba3fb555e3c7622f3124799440226">More...</a><br /></td></tr>
<tr class="separator:a1c2ba3fb555e3c7622f3124799440226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cbb090b42198244c1703eb17024bbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af8cbb090b42198244c1703eb17024bbc">setFog</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> color=<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(0, 255, 255, 255), <a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a> fogType=EFT_FOG_LINEAR, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> start=50.0f, f32 end=100.0f, f32 density=0.01f, bool pixelFog=false, bool rangeFog=false)=0</td></tr>
<tr class="memdesc:af8cbb090b42198244c1703eb17024bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fog mode.  <a href="#af8cbb090b42198244c1703eb17024bbc">More...</a><br /></td></tr>
<tr class="separator:af8cbb090b42198244c1703eb17024bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29435c6a654675bdb276c89fd4a1356c"><td class="memItemLeft" align="right" valign="top"><a id="a29435c6a654675bdb276c89fd4a1356c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a29435c6a654675bdb276c89fd4a1356c">getFog</a> (<a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;color, <a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a> &amp;fogType, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;start, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;end, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &amp;density, bool &amp;pixelFog, bool &amp;rangeFog)=0</td></tr>
<tr class="memdesc:a29435c6a654675bdb276c89fd4a1356c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fog mode. <br /></td></tr>
<tr class="separator:a29435c6a654675bdb276c89fd4a1356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afc8f27bfd9756f4ca8de2d4bb37b0e15">getColorFormat</a> () const =0</td></tr>
<tr class="memdesc:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current color format of the color buffer.  <a href="#afc8f27bfd9756f4ca8de2d4bb37b0e15">More...</a><br /></td></tr>
<tr class="separator:afc8f27bfd9756f4ca8de2d4bb37b0e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106dd9ff233497f9ea9a07dc6441c82"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa106dd9ff233497f9ea9a07dc6441c82">getScreenSize</a> () const =0</td></tr>
<tr class="memdesc:aa106dd9ff233497f9ea9a07dc6441c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the screen or render window.  <a href="#aa106dd9ff233497f9ea9a07dc6441c82">More...</a><br /></td></tr>
<tr class="separator:aa106dd9ff233497f9ea9a07dc6441c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc2aba131b5986d07d92c6888cfc0c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a76fc2aba131b5986d07d92c6888cfc0c">getCurrentRenderTargetSize</a> () const =0</td></tr>
<tr class="memdesc:a76fc2aba131b5986d07d92c6888cfc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the current render target.  <a href="#a76fc2aba131b5986d07d92c6888cfc0c">More...</a><br /></td></tr>
<tr class="separator:a76fc2aba131b5986d07d92c6888cfc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71428402c0b6a3b18b8f2fa408af13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5b71428402c0b6a3b18b8f2fa408af13">getFPS</a> () const =0</td></tr>
<tr class="memdesc:a5b71428402c0b6a3b18b8f2fa408af13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current frames per second value.  <a href="#a5b71428402c0b6a3b18b8f2fa408af13">More...</a><br /></td></tr>
<tr class="separator:a5b71428402c0b6a3b18b8f2fa408af13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2ce9be45cacb4aa034d3afdb489a57a3">getPrimitiveCountDrawn</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> mode=0) const =0</td></tr>
<tr class="memdesc:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of primitives (mostly triangles) which were drawn in the last frame.  <a href="#a2ce9be45cacb4aa034d3afdb489a57a3">More...</a><br /></td></tr>
<tr class="separator:a2ce9be45cacb4aa034d3afdb489a57a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="memItemLeft" align="right" valign="top"><a id="ab1bd29567ef6eb31a43bebe04c47eb5e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab1bd29567ef6eb31a43bebe04c47eb5e">deleteAllDynamicLights</a> ()=0</td></tr>
<tr class="memdesc:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dynamic lights which were previously added with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">addDynamicLight()</a>. <br /></td></tr>
<tr class="separator:ab1bd29567ef6eb31a43bebe04c47eb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813a39352eae26c4d30b5882618639be"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be">addDynamicLight</a> (const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;light)=0</td></tr>
<tr class="memdesc:a813a39352eae26c4d30b5882618639be"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a dynamic light, returning an index to the light  <a href="#a813a39352eae26c4d30b5882618639be">More...</a><br /></td></tr>
<tr class="separator:a813a39352eae26c4d30b5882618639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a2875011c8870fd011a486f3503ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ab64a2875011c8870fd011a486f3503ec">getMaximalDynamicLightAmount</a> () const =0</td></tr>
<tr class="memdesc:ab64a2875011c8870fd011a486f3503ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal amount of dynamic lights the device can handle.  <a href="#ab64a2875011c8870fd011a486f3503ec">More...</a><br /></td></tr>
<tr class="separator:ab64a2875011c8870fd011a486f3503ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1e5de698f264a9f74a17bdba313138"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b1e5de698f264a9f74a17bdba313138">getDynamicLightCount</a> () const =0</td></tr>
<tr class="memdesc:a9b1e5de698f264a9f74a17bdba313138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of dynamic lights currently set.  <a href="#a9b1e5de698f264a9f74a17bdba313138">More...</a><br /></td></tr>
<tr class="separator:a9b1e5de698f264a9f74a17bdba313138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9ee246e85a56300031f7d7516054e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9eb9ee246e85a56300031f7d7516054e">getDynamicLight</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx) const =0</td></tr>
<tr class="memdesc:a9eb9ee246e85a56300031f7d7516054e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns light data which was previously set by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">IVideoDriver::addDynamicLight()</a>.  <a href="#a9eb9ee246e85a56300031f7d7516054e">More...</a><br /></td></tr>
<tr class="separator:a9eb9ee246e85a56300031f7d7516054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26904f7d1bf0e37d51fe71562346a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a3c26904f7d1bf0e37d51fe71562346a0">turnLightOn</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> lightIndex, bool turnOn)=0</td></tr>
<tr class="memdesc:a3c26904f7d1bf0e37d51fe71562346a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a dynamic light on or off.  <a href="#a3c26904f7d1bf0e37d51fe71562346a0">More...</a><br /></td></tr>
<tr class="separator:a3c26904f7d1bf0e37d51fe71562346a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca51832295b2dceaa1e258daf863f1"><td class="memItemLeft" align="right" valign="top">virtual const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a87ca51832295b2dceaa1e258daf863f1">getName</a> () const =0</td></tr>
<tr class="memdesc:a87ca51832295b2dceaa1e258daf863f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets name of this video driver.  <a href="#a87ca51832295b2dceaa1e258daf863f1">More...</a><br /></td></tr>
<tr class="separator:a87ca51832295b2dceaa1e258daf863f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9479ae15f0e26eaaf15c9420ff289b6d">addExternalImageLoader</a> (<a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *loader)=0</td></tr>
<tr class="memdesc:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external image loader to the engine.  <a href="#a9479ae15f0e26eaaf15c9420ff289b6d">More...</a><br /></td></tr>
<tr class="separator:a9479ae15f0e26eaaf15c9420ff289b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56160e0d88346e04db921fbe4635a7ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a56160e0d88346e04db921fbe4635a7ae">addExternalImageWriter</a> (<a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *writer)=0</td></tr>
<tr class="memdesc:a56160e0d88346e04db921fbe4635a7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external image writer to the engine.  <a href="#a56160e0d88346e04db921fbe4635a7ae">More...</a><br /></td></tr>
<tr class="separator:a56160e0d88346e04db921fbe4635a7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93e778fac79f7863da72a50e720f88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afd93e778fac79f7863da72a50e720f88">getMaximalPrimitiveCount</a> () const =0</td></tr>
<tr class="memdesc:afd93e778fac79f7863da72a50e720f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum amount of primitives.  <a href="#afd93e778fac79f7863da72a50e720f88">More...</a><br /></td></tr>
<tr class="separator:afd93e778fac79f7863da72a50e720f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b58a6b86b9e4841ca3879ce246c4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e">setTextureCreationFlag</a> (<a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a> flag, bool enabled=true)=0</td></tr>
<tr class="memdesc:a868b58a6b86b9e4841ca3879ce246c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables a texture creation flag.  <a href="#a868b58a6b86b9e4841ca3879ce246c4e">More...</a><br /></td></tr>
<tr class="separator:a868b58a6b86b9e4841ca3879ce246c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae64d474cbca38f64f2dbb8fcacb1a035">getTextureCreationFlag</a> (<a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a> flag) const =0</td></tr>
<tr class="memdesc:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a texture creation flag is enabled or disabled.  <a href="#ae64d474cbca38f64f2dbb8fcacb1a035">More...</a><br /></td></tr>
<tr class="separator:ae64d474cbca38f64f2dbb8fcacb1a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac5b4c13f64d96d27fa27f52b68f77b8c">createImageFromFile</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a file.  <a href="#ac5b4c13f64d96d27fa27f52b68f77b8c">More...</a><br /></td></tr>
<tr class="separator:ac5b4c13f64d96d27fa27f52b68f77b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322c41fa08c1da9de4633cf8a1e68607"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a322c41fa08c1da9de4633cf8a1e68607">createImageFromFile</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:a322c41fa08c1da9de4633cf8a1e68607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a file.  <a href="#a322c41fa08c1da9de4633cf8a1e68607">More...</a><br /></td></tr>
<tr class="separator:a322c41fa08c1da9de4633cf8a1e68607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407d6a1483f995060035340e0a92ce9b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a407d6a1483f995060035340e0a92ce9b">writeImageToFile</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> param=0)=0</td></tr>
<tr class="memdesc:a407d6a1483f995060035340e0a92ce9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the provided image to a file.  <a href="#a407d6a1483f995060035340e0a92ce9b">More...</a><br /></td></tr>
<tr class="separator:a407d6a1483f995060035340e0a92ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12c362cfbc92a7c59b434666c8436c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae12c362cfbc92a7c59b434666c8436c0">writeImageToFile</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *image, <a class="el" href="classirr_1_1io_1_1IWriteFile.html">io::IWriteFile</a> *file, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> param=0)=0</td></tr>
<tr class="memdesc:ae12c362cfbc92a7c59b434666c8436c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the provided image to a file.  <a href="#ae12c362cfbc92a7c59b434666c8436c0">More...</a><br /></td></tr>
<tr class="separator:ae12c362cfbc92a7c59b434666c8436c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d60f2fcad42d8a79c33c587f41a06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a425d60f2fcad42d8a79c33c587f41a06">createImageFromData</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size, void *data, bool ownForeignMemory=false, bool deleteMemory=true)=0</td></tr>
<tr class="memdesc:a425d60f2fcad42d8a79c33c587f41a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a byte array.  <a href="#a425d60f2fcad42d8a79c33c587f41a06">More...</a><br /></td></tr>
<tr class="separator:a425d60f2fcad42d8a79c33c587f41a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1578fdd92118665755f31c0dd1dbb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aee1578fdd92118665755f31c0dd1dbb5">createImage</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:aee1578fdd92118665755f31c0dd1dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty software image.  <a href="#aee1578fdd92118665755f31c0dd1dbb5">More...</a><br /></td></tr>
<tr class="separator:aee1578fdd92118665755f31c0dd1dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92ef735bc8c755f5c201a52a70d05e8"><td class="memItemLeft" align="right" valign="top">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af92ef735bc8c755f5c201a52a70d05e8">createImage</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> format, <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *imageToCopy)=0</td></tr>
<tr class="memdesc:af92ef735bc8c755f5c201a52a70d05e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image by converting it to given format from another image.  <a href="#af92ef735bc8c755f5c201a52a70d05e8">More...</a><br /></td></tr>
<tr class="separator:af92ef735bc8c755f5c201a52a70d05e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06059abf33e473d7af77e1fbc2b0f75"><td class="memItemLeft" align="right" valign="top">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa06059abf33e473d7af77e1fbc2b0f75">createImage</a> (<a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *imageToCopy, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:aa06059abf33e473d7af77e1fbc2b0f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a part of another image.  <a href="#aa06059abf33e473d7af77e1fbc2b0f75">More...</a><br /></td></tr>
<tr class="separator:aa06059abf33e473d7af77e1fbc2b0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e722e8dd2d750907e9e059c3dc8fae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a38e722e8dd2d750907e9e059c3dc8fae">createImage</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *texture, const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;pos, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:a38e722e8dd2d750907e9e059c3dc8fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a software image from a part of a texture.  <a href="#a38e722e8dd2d750907e9e059c3dc8fae">More...</a><br /></td></tr>
<tr class="separator:a38e722e8dd2d750907e9e059c3dc8fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a1a236e1233fc6fc2c5f36aaa830814fc">OnResize</a> (const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;size)=0</td></tr>
<tr class="memdesc:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for resize events. Only used by the engine internally.  <a href="#a1a236e1233fc6fc2c5f36aaa830814fc">More...</a><br /></td></tr>
<tr class="separator:a1a236e1233fc6fc2c5f36aaa830814fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6">addMaterialRenderer</a> (<a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *renderer, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name=0)=0</td></tr>
<tr class="memdesc:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new material renderer to the video device.  <a href="#a0dfc3a7168f3a73a6f4323b579f03ff6">More...</a><br /></td></tr>
<tr class="separator:a0dfc3a7168f3a73a6f4323b579f03ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb321dfb32ad3c76efb99427bc90cc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#accb321dfb32ad3c76efb99427bc90cc8">getMaterialRenderer</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx)=0</td></tr>
<tr class="memdesc:accb321dfb32ad3c76efb99427bc90cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to a material renderer by index.  <a href="#accb321dfb32ad3c76efb99427bc90cc8">More...</a><br /></td></tr>
<tr class="separator:accb321dfb32ad3c76efb99427bc90cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0e2e952afdcdbdd915dc106375381"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac1d0e2e952afdcdbdd915dc106375381">getMaterialRendererCount</a> () const =0</td></tr>
<tr class="memdesc:ac1d0e2e952afdcdbdd915dc106375381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of currently available material renderers.  <a href="#ac1d0e2e952afdcdbdd915dc106375381">More...</a><br /></td></tr>
<tr class="separator:ac1d0e2e952afdcdbdd915dc106375381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac6f8c53abcd5a24d94c84185b0ef65e0">getMaterialRendererName</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> idx) const =0</td></tr>
<tr class="memdesc:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of a material renderer.  <a href="#ac6f8c53abcd5a24d94c84185b0ef65e0">More...</a><br /></td></tr>
<tr class="separator:ac6f8c53abcd5a24d94c84185b0ef65e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef324ed93094f84832e8d31cf0776f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4ef324ed93094f84832e8d31cf0776f2">setMaterialRendererName</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> idx, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name)=0</td></tr>
<tr class="memdesc:a4ef324ed93094f84832e8d31cf0776f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of a material renderer.  <a href="#a4ef324ed93094f84832e8d31cf0776f2">More...</a><br /></td></tr>
<tr class="separator:a4ef324ed93094f84832e8d31cf0776f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4e496fec6b4b0b70d2e95b2576eaffee">createAttributesFromMaterial</a> (const <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;material, <a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *options=0)=0</td></tr>
<tr class="memdesc:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates material attributes list from a material.  <a href="#a4e496fec6b4b0b70d2e95b2576eaffee">More...</a><br /></td></tr>
<tr class="separator:a4e496fec6b4b0b70d2e95b2576eaffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b7b5942cf2378f9f96d47ec7a0cd881">fillMaterialStructureFromAttributes</a> (<a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;outMaterial, <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *attributes)=0</td></tr>
<tr class="memdesc:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> structure from attributes.  <a href="#a9b7b5942cf2378f9f96d47ec7a0cd881">More...</a><br /></td></tr>
<tr class="separator:a9b7b5942cf2378f9f96d47ec7a0cd881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3535b2125e654e2e9645745e50cc49"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4f3535b2125e654e2e9645745e50cc49">getExposedVideoData</a> ()=0</td></tr>
<tr class="memdesc:a4f3535b2125e654e2e9645745e50cc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns driver and operating system specific data about the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions. ">IVideoDriver</a>.  <a href="#a4f3535b2125e654e2e9645745e50cc49">More...</a><br /></td></tr>
<tr class="separator:a4f3535b2125e654e2e9645745e50cc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a0c4fcc0337f3befe8b90424e68aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0">E_DRIVER_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af89a0c4fcc0337f3befe8b90424e68aa">getDriverType</a> () const =0</td></tr>
<tr class="memdesc:af89a0c4fcc0337f3befe8b90424e68aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of video driver.  <a href="#af89a0c4fcc0337f3befe8b90424e68aa">More...</a><br /></td></tr>
<tr class="separator:af89a0c4fcc0337f3befe8b90424e68aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2098a408bbe9dad8053c3f4aea7d856"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html">IGPUProgrammingServices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad2098a408bbe9dad8053c3f4aea7d856">getGPUProgrammingServices</a> ()=0</td></tr>
<tr class="memdesc:ad2098a408bbe9dad8053c3f4aea7d856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a> interface.  <a href="#ad2098a408bbe9dad8053c3f4aea7d856">More...</a><br /></td></tr>
<tr class="separator:ad2098a408bbe9dad8053c3f4aea7d856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b76ea8ba013885c0f3d5f00131431ec"><td class="memItemLeft" align="right" valign="top"><a id="a9b76ea8ba013885c0f3d5f00131431ec"></a>
virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">scene::IMeshManipulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b76ea8ba013885c0f3d5f00131431ec">getMeshManipulator</a> ()=0</td></tr>
<tr class="memdesc:a9b76ea8ba013885c0f3d5f00131431ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the mesh manipulator. <br /></td></tr>
<tr class="separator:a9b76ea8ba013885c0f3d5f00131431ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a2036fe0a27dbd1a123ff5aedb07373a5">clearZBuffer</a> ()=0</td></tr>
<tr class="memdesc:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the ZBuffer.  <a href="#a2036fe0a27dbd1a123ff5aedb07373a5">More...</a><br /></td></tr>
<tr class="separator:a2036fe0a27dbd1a123ff5aedb07373a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db0e36d406089167facf70b2eb4706"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a50db0e36d406089167facf70b2eb4706">createScreenShot</a> (<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">video::ECOLOR_FORMAT</a> format=<a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">video::ECF_UNKNOWN</a>, <a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">video::E_RENDER_TARGET</a> target=<a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972a232d0f49241a378e11d4a37e752d3d73">video::ERT_FRAME_BUFFER</a>)=0</td></tr>
<tr class="memdesc:a50db0e36d406089167facf70b2eb4706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a screenshot of the last rendered frame.  <a href="#a50db0e36d406089167facf70b2eb4706">More...</a><br /></td></tr>
<tr class="separator:a50db0e36d406089167facf70b2eb4706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eaed6d56b092e6805400ca59795de9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad4eaed6d56b092e6805400ca59795de9">findTexture</a> (const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:ad4eaed6d56b092e6805400ca59795de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the image is already loaded.  <a href="#ad4eaed6d56b092e6805400ca59795de9">More...</a><br /></td></tr>
<tr class="separator:ad4eaed6d56b092e6805400ca59795de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ac385891941e7ec8d99b2f105b265"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a959ac385891941e7ec8d99b2f105b265">setClipPlane</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, const <a class="el" href="namespaceirr_1_1core.html#a97c9b39d4c6f71dbd9ded0153c4fa7f7">core::plane3df</a> &amp;plane, bool enable=false)=0</td></tr>
<tr class="memdesc:a959ac385891941e7ec8d99b2f105b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or unset a clipping plane.  <a href="#a959ac385891941e7ec8d99b2f105b265">More...</a><br /></td></tr>
<tr class="separator:a959ac385891941e7ec8d99b2f105b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf9567c759f866311c76e3874822339"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaaf9567c759f866311c76e3874822339">enableClipPlane</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, bool enable)=0</td></tr>
<tr class="memdesc:aaaf9567c759f866311c76e3874822339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a clipping plane.  <a href="#aaaf9567c759f866311c76e3874822339">More...</a><br /></td></tr>
<tr class="separator:aaaf9567c759f866311c76e3874822339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cbd1329b4206503e9a9593592502ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a79cbd1329b4206503e9a9593592502ea">setMinHardwareBufferVertexCount</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> count)=0</td></tr>
<tr class="memdesc:a79cbd1329b4206503e9a9593592502ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of vertices for which a hw buffer will be created.  <a href="#a79cbd1329b4206503e9a9593592502ea">More...</a><br /></td></tr>
<tr class="separator:a79cbd1329b4206503e9a9593592502ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119ebfd02f99f77a463007277abf14a"><td class="memItemLeft" align="right" valign="top">virtual SOverrideMaterial &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af119ebfd02f99f77a463007277abf14a">getOverrideMaterial</a> ()=0</td></tr>
<tr class="memdesc:af119ebfd02f99f77a463007277abf14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global Material, which might override local materials.  <a href="#af119ebfd02f99f77a463007277abf14a">More...</a><br /></td></tr>
<tr class="separator:af119ebfd02f99f77a463007277abf14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a198bbe60fdb1b5d6d0f4921e8a26109c">getMaterial2D</a> ()=0</td></tr>
<tr class="memdesc:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2d override material for altering its values.  <a href="#a198bbe60fdb1b5d6d0f4921e8a26109c">More...</a><br /></td></tr>
<tr class="separator:a198bbe60fdb1b5d6d0f4921e8a26109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686a41fe0f506bb04c262f724f65756"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a7686a41fe0f506bb04c262f724f65756">enableMaterial2D</a> (bool enable=true)=0</td></tr>
<tr class="memdesc:a7686a41fe0f506bb04c262f724f65756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the 2d override material.  <a href="#a7686a41fe0f506bb04c262f724f65756">More...</a><br /></td></tr>
<tr class="separator:a7686a41fe0f506bb04c262f724f65756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a3ee79676ad9fbebc39cf0150516e"><td class="memItemLeft" align="right" valign="top"><a id="a221a3ee79676ad9fbebc39cf0150516e"></a>
virtual <a class="el" href="namespaceirr_1_1core.html#ab26a0e0359206b5a694f35c37c829d7f">core::stringc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a221a3ee79676ad9fbebc39cf0150516e">getVendorInfo</a> ()=0</td></tr>
<tr class="memdesc:a221a3ee79676ad9fbebc39cf0150516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the graphics card vendor name. <br /></td></tr>
<tr class="separator:a221a3ee79676ad9fbebc39cf0150516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8d96a8061264393fc74ac9a3cd04f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aaba8d96a8061264393fc74ac9a3cd04f">setAmbientLight</a> (const <a class="el" href="classirr_1_1video_1_1SColorf.html">SColorf</a> &amp;color)=0</td></tr>
<tr class="memdesc:aaba8d96a8061264393fc74ac9a3cd04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used by the engine internally.  <a href="#aaba8d96a8061264393fc74ac9a3cd04f">More...</a><br /></td></tr>
<tr class="separator:aaba8d96a8061264393fc74ac9a3cd04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78022589e5b7cb42b4d6ed2f7950e42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af78022589e5b7cb42b4d6ed2f7950e42">setAllowZWriteOnTransparent</a> (bool flag)=0</td></tr>
<tr class="memdesc:af78022589e5b7cb42b4d6ed2f7950e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used by the engine internally.  <a href="#af78022589e5b7cb42b4d6ed2f7950e42">More...</a><br /></td></tr>
<tr class="separator:af78022589e5b7cb42b4d6ed2f7950e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc9632861757d167c035bb5ecfa6854"><td class="memItemLeft" align="right" valign="top"><a id="a9bc9632861757d167c035bb5ecfa6854"></a>
virtual <a class="el" href="namespaceirr_1_1core.html#a13e5bd7e47b2014eefc870ede11bbbbc">core::dimension2du</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9bc9632861757d167c035bb5ecfa6854">getMaxTextureSize</a> () const =0</td></tr>
<tr class="memdesc:a9bc9632861757d167c035bb5ecfa6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum texture size supported. <br /></td></tr>
<tr class="separator:a9bc9632861757d167c035bb5ecfa6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb541967dbb2def61997f1d69f68d5d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1IVideoDriver.html#afb541967dbb2def61997f1d69f68d5d1">convertColor</a> (const void *sP, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> sF, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> sN, void *dP, <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> dF) const =0</td></tr>
<tr class="memdesc:afb541967dbb2def61997f1d69f68d5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color conversion convenience function.  <a href="#afb541967dbb2def61997f1d69f68d5d1">More...</a><br /></td></tr>
<tr class="separator:afb541967dbb2def61997f1d69f68d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to driver which is able to perform 2d and 3d graphics functions. </p>
<p>This interface is one of the most important interfaces of the Irrlicht Engine: All rendering and texture manipulation is done with this interface. You are able to use the Irrlicht Engine by only invoking methods of this interface if you like to, although the <a class="el" href="classirr_1_1scene_1_1ISceneManager.html" title="The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff. ">irr::scene::ISceneManager</a> interface provides a lot of powerful classes and methods to make the programmer's life easier. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a813a39352eae26c4d30b5882618639be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813a39352eae26c4d30b5882618639be">&#9670;&nbsp;</a></span>addDynamicLight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::addDynamicLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a dynamic light, returning an index to the light </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>the light data to use to create the light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index to the light, or -1 if an error occurs </dd></dl>

</div>
</div>
<a id="a813a39352eae26c4d30b5882618639be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813a39352eae26c4d30b5882618639be">&#9670;&nbsp;</a></span>addDynamicLight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::addDynamicLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a> &amp;&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a dynamic light, returning an index to the light </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>the light data to use to create the light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index to the light, or -1 if an error occurs </dd></dl>

</div>
</div>
<a id="a9479ae15f0e26eaaf15c9420ff289b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9479ae15f0e26eaaf15c9420ff289b6d">&#9670;&nbsp;</a></span>addExternalImageLoader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addExternalImageLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external image loader to the engine. </p>
<p>This is useful if the Irrlicht Engine should be able to load textures of currently unsupported file formats (e.g. gif). The <a class="el" href="classirr_1_1video_1_1IImageLoader.html" title="Class which is able to create a image from a file. ">IImageLoader</a> only needs to be implemented for loading this file format. A pointer to the implementation can be passed to the engine using this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>Pointer to the external loader created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9479ae15f0e26eaaf15c9420ff289b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9479ae15f0e26eaaf15c9420ff289b6d">&#9670;&nbsp;</a></span>addExternalImageLoader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addExternalImageLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external image loader to the engine. </p>
<p>This is useful if the Irrlicht Engine should be able to load textures of currently unsupported file formats (e.g. gif). The <a class="el" href="classirr_1_1video_1_1IImageLoader.html" title="Class which is able to create a image from a file. ">IImageLoader</a> only needs to be implemented for loading this file format. A pointer to the implementation can be passed to the engine using this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>Pointer to the external loader created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56160e0d88346e04db921fbe4635a7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56160e0d88346e04db921fbe4635a7ae">&#9670;&nbsp;</a></span>addExternalImageWriter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addExternalImageWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external image writer to the engine. </p>
<p>This is useful if the Irrlicht Engine should be able to write textures of currently unsupported file formats (e.g .gif). The <a class="el" href="classirr_1_1video_1_1IImageWriter.html" title="Interface for writing software image data. ">IImageWriter</a> only needs to be implemented for writing this file format. A pointer to the implementation can be passed to the engine using this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>Pointer to the external writer created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56160e0d88346e04db921fbe4635a7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56160e0d88346e04db921fbe4635a7ae">&#9670;&nbsp;</a></span>addExternalImageWriter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addExternalImageWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external image writer to the engine. </p>
<p>This is useful if the Irrlicht Engine should be able to write textures of currently unsupported file formats (e.g .gif). The <a class="el" href="classirr_1_1video_1_1IImageWriter.html" title="Interface for writing software image data. ">IImageWriter</a> only needs to be implemented for writing this file format. A pointer to the implementation can be passed to the engine using this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>Pointer to the external writer created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dfc3a7168f3a73a6f4323b579f03ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfc3a7168f3a73a6f4323b579f03ff6">&#9670;&nbsp;</a></span>addMaterialRenderer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::addMaterialRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new material renderer to the video device. </p>
<p>Use this method to extend the VideoDriver with new material types. To extend the engine using this method do the following: Derive a class from <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html" title="Interface for material rendering. ">IMaterialRenderer</a> and override the methods you need. For setting the right renderstates, you can try to get a pointer to the real rendering device using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4f3535b2125e654e2e9645745e50cc49" title="Returns driver and operating system specific data about the IVideoDriver. ">IVideoDriver::getExposedVideoData()</a>. Add your class with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">IVideoDriver::addMaterialRenderer()</a>. To use an object being displayed with your new material, set the MaterialType member of the <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> struct to the value returned by this method. If you simply want to create a new material using vertex and/or pixel shaders it would be easier to use the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">video::IGPUProgrammingServices</a> interface which you can get using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad2098a408bbe9dad8053c3f4aea7d856" title="Gets the IGPUProgrammingServices interface. ">getGPUProgrammingServices()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A pointer to the new renderer. </td></tr>
    <tr><td class="paramname">name</td><td>Optional name for the material renderer entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1SMaterial.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together. ">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. For example if you tried to add an material renderer to the software renderer or the null device, which do not accept material renderers. </dd></dl>

</div>
</div>
<a id="a0dfc3a7168f3a73a6f4323b579f03ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfc3a7168f3a73a6f4323b579f03ff6">&#9670;&nbsp;</a></span>addMaterialRenderer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::addMaterialRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new material renderer to the video device. </p>
<p>Use this method to extend the VideoDriver with new material types. To extend the engine using this method do the following: Derive a class from <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html" title="Interface for material rendering. ">IMaterialRenderer</a> and override the methods you need. For setting the right renderstates, you can try to get a pointer to the real rendering device using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4f3535b2125e654e2e9645745e50cc49" title="Returns driver and operating system specific data about the IVideoDriver. ">IVideoDriver::getExposedVideoData()</a>. Add your class with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">IVideoDriver::addMaterialRenderer()</a>. To use an object being displayed with your new material, set the MaterialType member of the <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> struct to the value returned by this method. If you simply want to create a new material using vertex and/or pixel shaders it would be easier to use the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">video::IGPUProgrammingServices</a> interface which you can get using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad2098a408bbe9dad8053c3f4aea7d856" title="Gets the IGPUProgrammingServices interface. ">getGPUProgrammingServices()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A pointer to the new renderer. </td></tr>
    <tr><td class="paramname">name</td><td>Optional name for the material renderer entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1SMaterial.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together. ">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. For example if you tried to add an material renderer to the software renderer or the null device, which do not accept material renderers. </dd></dl>

</div>
</div>
<a id="a07f15814e039772ee43be272e97d1633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f15814e039772ee43be272e97d1633">&#9670;&nbsp;</a></span>addOcclusionQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMesh.html">scene::IMesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create occlusion query. </p>
<p>Use node for identification and mesh for occlusion test. </p>

</div>
</div>
<a id="a07f15814e039772ee43be272e97d1633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f15814e039772ee43be272e97d1633">&#9670;&nbsp;</a></span>addOcclusionQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::addOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMesh.html">scene::IMesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create occlusion query. </p>
<p>Use node for identification and mesh for occlusion test. </p>

</div>
</div>
<a id="aa704cece826ee37d02e4bb054b0b8797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa704cece826ee37d02e4bb054b0b8797">&#9670;&nbsp;</a></span>addRenderTargetTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addRenderTargetTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;rt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">ECF_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new render target texture to the texture cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the texture, in pixels. Width and height should be a power of two (e.g. 64, 128, 256, 512, ...) and it should not be bigger than the backbuffer, because it shares the zbuffer with the screen buffer. </td></tr>
    <tr><td class="paramname">name</td><td>An optional name for the RTT. </td></tr>
    <tr><td class="paramname">format</td><td>The color format of the render target. Floating point formats are supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created texture or 0 if the texture could not be created. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aa704cece826ee37d02e4bb054b0b8797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa704cece826ee37d02e4bb054b0b8797">&#9670;&nbsp;</a></span>addRenderTargetTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addRenderTargetTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;rt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">ECF_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new render target texture to the texture cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the texture, in pixels. Width and height should be a power of two (e.g. 64, 128, 256, 512, ...) and it should not be bigger than the backbuffer, because it shares the zbuffer with the screen buffer. </td></tr>
    <tr><td class="paramname">name</td><td>An optional name for the RTT. </td></tr>
    <tr><td class="paramname">format</td><td>The color format of the render target. Floating point formats are supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created texture or 0 if the texture could not be created. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a8c02ee280bb738cdf38b77e7a798244e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c02ee280bb738cdf38b77e7a798244e">&#9670;&nbsp;</a></span>addTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829edac3d45e946a56d11bd43dc18661dfe7ec">ECF_A8R8G8B8</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty texture of specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the texture. </td></tr>
    <tr><td class="paramname">name</td><td>A name for the texture. Later calls to <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td class="paramname">format</td><td>Desired color format of the texture. Please note that the driver may choose to create the texture in another color format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a8c02ee280bb738cdf38b77e7a798244e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c02ee280bb738cdf38b77e7a798244e">&#9670;&nbsp;</a></span>addTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829edac3d45e946a56d11bd43dc18661dfe7ec">ECF_A8R8G8B8</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty texture of specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the texture. </td></tr>
    <tr><td class="paramname">name</td><td>A name for the texture. Later calls to <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td class="paramname">format</td><td>Desired color format of the texture. Please note that the driver may choose to create the texture in another color format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="abfebeb09a692c0d6b4741d952d97668e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfebeb09a692c0d6b4741d952d97668e">&#9670;&nbsp;</a></span>addTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mipmapData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a texture from an <a class="el" href="classirr_1_1video_1_1IImage.html" title="Interface for software image data. ">IImage</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A name for the texture. Later calls of <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> the texture is created from. </td></tr>
    <tr><td class="paramname">mipmapData</td><td>Optional pointer to a set of images which build up the whole mipmap set. Must be images of the same color type as image. If this parameter is not given, the mipmaps are derived from image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="abfebeb09a692c0d6b4741d952d97668e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfebeb09a692c0d6b4741d952d97668e">&#9670;&nbsp;</a></span>addTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::addTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mipmapData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a texture from an <a class="el" href="classirr_1_1video_1_1IImage.html" title="Interface for software image data. ">IImage</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A name for the texture. Later calls of <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> the texture is created from. </td></tr>
    <tr><td class="paramname">mipmapData</td><td>Optional pointer to a set of images which build up the whole mipmap set. Must be images of the same color type as image. If this parameter is not given, the mipmaps are derived from image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a015b8f2f18c260a00a858181be1e9945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015b8f2f18c260a00a858181be1e9945">&#9670;&nbsp;</a></span>beginScene() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::beginScene </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;&#160;</td>
          <td class="paramname"><em>videoData</em> = <code><a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>sourceRect</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applications must call this method before performing any rendering. </p>
<p>This method can clear the back- and the z-buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backBuffer</td><td>Specifies if the back buffer should be cleared, which means that the screen is filled with the color specified. If this parameter is false, the back buffer will not be cleared and the color parameter is ignored. </td></tr>
    <tr><td class="paramname">zBuffer</td><td>Specifies if the depth buffer (z buffer) should be cleared. It is not nesesarry to do so if only 2d drawing is used. </td></tr>
    <tr><td class="paramname">color</td><td>The color used for back buffer clearing </td></tr>
    <tr><td class="paramname">videoData</td><td>Handle of another window, if you want the bitmap to be displayed on another window. If this is an empty element, everything will be displayed in the default window. Note: This feature is not fully implemented for all devices. </td></tr>
    <tr><td class="paramname">sourceRect</td><td>Pointer to a rectangle defining the source rectangle of the area to be presented. Set to null to present everything. Note: not implemented in all devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if failed. </dd></dl>

</div>
</div>
<a id="a015b8f2f18c260a00a858181be1e9945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015b8f2f18c260a00a858181be1e9945">&#9670;&nbsp;</a></span>beginScene() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::beginScene </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a> &amp;&#160;</td>
          <td class="paramname"><em>videoData</em> = <code><a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>sourceRect</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applications must call this method before performing any rendering. </p>
<p>This method can clear the back- and the z-buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backBuffer</td><td>Specifies if the back buffer should be cleared, which means that the screen is filled with the color specified. If this parameter is false, the back buffer will not be cleared and the color parameter is ignored. </td></tr>
    <tr><td class="paramname">zBuffer</td><td>Specifies if the depth buffer (z buffer) should be cleared. It is not nesesarry to do so if only 2d drawing is used. </td></tr>
    <tr><td class="paramname">color</td><td>The color used for back buffer clearing </td></tr>
    <tr><td class="paramname">videoData</td><td>Handle of another window, if you want the bitmap to be displayed on another window. If this is an empty element, everything will be displayed in the default window. Note: This feature is not fully implemented for all devices. </td></tr>
    <tr><td class="paramname">sourceRect</td><td>Pointer to a rectangle defining the source rectangle of the area to be presented. Set to null to present everything. Note: not implemented in all devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if failed. </dd></dl>

</div>
</div>
<a id="a4ba84ee992939fc913d4935caffce87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba84ee992939fc913d4935caffce87b">&#9670;&nbsp;</a></span>checkDriverReset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::checkDriverReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the driver was recently reset. </p>
<p>For d3d devices you will need to recreate the RTTs if the driver was reset. Should be queried right after <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">beginScene()</a>. </p>

</div>
</div>
<a id="a4ba84ee992939fc913d4935caffce87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba84ee992939fc913d4935caffce87b">&#9670;&nbsp;</a></span>checkDriverReset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::checkDriverReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the driver was recently reset. </p>
<p>For d3d devices you will need to recreate the RTTs if the driver was reset. Should be queried right after <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">beginScene()</a>. </p>

</div>
</div>
<a id="a2036fe0a27dbd1a123ff5aedb07373a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2036fe0a27dbd1a123ff5aedb07373a5">&#9670;&nbsp;</a></span>clearZBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::clearZBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the ZBuffer. </p>
<p>Note that you usually need not to call this method, as it is automatically done in <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">IVideoDriver::beginScene()</a> or <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb" title="Sets a new render target. ">IVideoDriver::setRenderTarget()</a> if you enable zBuffer. But if you have to render some special things, you can clear the zbuffer during the rendering process with this method any time. </p>

</div>
</div>
<a id="a2036fe0a27dbd1a123ff5aedb07373a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2036fe0a27dbd1a123ff5aedb07373a5">&#9670;&nbsp;</a></span>clearZBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::clearZBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the ZBuffer. </p>
<p>Note that you usually need not to call this method, as it is automatically done in <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">IVideoDriver::beginScene()</a> or <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb" title="Sets a new render target. ">IVideoDriver::setRenderTarget()</a> if you enable zBuffer. But if you have to render some special things, you can clear the zbuffer during the rendering process with this method any time. </p>

</div>
</div>
<a id="afb541967dbb2def61997f1d69f68d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb541967dbb2def61997f1d69f68d5d1">&#9670;&nbsp;</a></span>convertColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::convertColor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>sF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>sN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>dF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Color conversion convenience function. </p>
<p>Convert an image (as array of pixels) from source to destination array, thereby converting the color format. The pixel size is determined by the color formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sP</td><td>Pointer to source </td></tr>
    <tr><td class="paramname">sF</td><td>Color format of source </td></tr>
    <tr><td class="paramname">sN</td><td>Number of pixels to convert, both array must be large enough </td></tr>
    <tr><td class="paramname">dP</td><td>Pointer to destination </td></tr>
    <tr><td class="paramname">dF</td><td>Color format of destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb541967dbb2def61997f1d69f68d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb541967dbb2def61997f1d69f68d5d1">&#9670;&nbsp;</a></span>convertColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::convertColor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>sF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>sN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>dF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Color conversion convenience function. </p>
<p>Convert an image (as array of pixels) from source to destination array, thereby converting the color format. The pixel size is determined by the color formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sP</td><td>Pointer to source </td></tr>
    <tr><td class="paramname">sF</td><td>Color format of source </td></tr>
    <tr><td class="paramname">sN</td><td>Number of pixels to convert, both array must be large enough </td></tr>
    <tr><td class="paramname">dP</td><td>Pointer to destination </td></tr>
    <tr><td class="paramname">dF</td><td>Color format of destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e496fec6b4b0b70d2e95b2576eaffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e496fec6b4b0b70d2e95b2576eaffee">&#9670;&nbsp;</a></span>createAttributesFromMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a>* irr::video::IVideoDriver::createAttributesFromMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates material attributes list from a material. </p>
<p>This method is useful for serialization and more. Please note that the video driver will use the material renderer names from <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac6f8c53abcd5a24d94c84185b0ef65e0" title="Get name of a material renderer. ">getMaterialRendererName()</a> to write out the material type name, so they should be set before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>The material to serialize. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the serialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classirr_1_1io_1_1IAttributes.html" title="Provides a generic interface for attributes and their values and the possiblity to serialize them...">io::IAttributes</a> container holding the material properties. </dd></dl>

</div>
</div>
<a id="a4e496fec6b4b0b70d2e95b2576eaffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e496fec6b4b0b70d2e95b2576eaffee">&#9670;&nbsp;</a></span>createAttributesFromMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a>* irr::video::IVideoDriver::createAttributesFromMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1io_1_1SAttributeReadWriteOptions.html">io::SAttributeReadWriteOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates material attributes list from a material. </p>
<p>This method is useful for serialization and more. Please note that the video driver will use the material renderer names from <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ac6f8c53abcd5a24d94c84185b0ef65e0" title="Get name of a material renderer. ">getMaterialRendererName()</a> to write out the material type name, so they should be set before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>The material to serialize. </td></tr>
    <tr><td class="paramname">options</td><td>Additional options which might influence the serialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classirr_1_1io_1_1IAttributes.html" title="Provides a generic interface for attributes and their values and the possiblity to serialize them...">io::IAttributes</a> container holding the material properties. </dd></dl>

</div>
</div>
<a id="aee1578fdd92118665755f31c0dd1dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1578fdd92118665755f31c0dd1dbb5">&#9670;&nbsp;</a></span>createImage() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty software image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the image. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the image to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aee1578fdd92118665755f31c0dd1dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1578fdd92118665755f31c0dd1dbb5">&#9670;&nbsp;</a></span>createImage() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty software image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the image. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the image to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="af92ef735bc8c755f5c201a52a70d05e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92ef735bc8c755f5c201a52a70d05e8">&#9670;&nbsp;</a></span>createImage() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>imageToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image by converting it to given format from another image. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the image. </td></tr>
    <tr><td class="paramname">imageToCopy</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to copy to the new image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="af92ef735bc8c755f5c201a52a70d05e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92ef735bc8c755f5c201a52a70d05e8">&#9670;&nbsp;</a></span>createImage() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>imageToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image by converting it to given format from another image. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the image. </td></tr>
    <tr><td class="paramname">imageToCopy</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to copy to the new image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aa06059abf33e473d7af77e1fbc2b0f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06059abf33e473d7af77e1fbc2b0f75">&#9670;&nbsp;</a></span>createImage() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>imageToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a part of another image. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToCopy</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to copy to the new image in part. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of rectangle to copy. </td></tr>
    <tr><td class="paramname">size</td><td>Extents of rectangle to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aa06059abf33e473d7af77e1fbc2b0f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06059abf33e473d7af77e1fbc2b0f75">&#9670;&nbsp;</a></span>createImage() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _IRR_DEPRECATED_ <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>imageToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a part of another image. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Create an empty image and use copyTo(). This method may be removed by Irrlicht 1.9. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToCopy</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to copy to the new image in part. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of rectangle to copy. </td></tr>
    <tr><td class="paramname">size</td><td>Extents of rectangle to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a38e722e8dd2d750907e9e059c3dc8fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e722e8dd2d750907e9e059c3dc8fae">&#9670;&nbsp;</a></span>createImage() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a part of a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to copy to the new image in part. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of rectangle to copy. </td></tr>
    <tr><td class="paramname">size</td><td>Extents of rectangle to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a38e722e8dd2d750907e9e059c3dc8fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e722e8dd2d750907e9e059c3dc8fae">&#9670;&nbsp;</a></span>createImage() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a part of a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to copy to the new image in part. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of rectangle to copy. </td></tr>
    <tr><td class="paramname">size</td><td>Extents of rectangle to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a425d60f2fcad42d8a79c33c587f41a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d60f2fcad42d8a79c33c587f41a06">&#9670;&nbsp;</a></span>createImageFromData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownForeignMemory</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteMemory</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a byte array. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the texture </td></tr>
    <tr><td class="paramname">size</td><td>Desired size of the image </td></tr>
    <tr><td class="paramname">data</td><td>A byte array with pixel color information </td></tr>
    <tr><td class="paramname">ownForeignMemory</td><td>If true, the image will use the data pointer directly and own it afterwards. If false, the memory will by copied internally. </td></tr>
    <tr><td class="paramname">deleteMemory</td><td>Whether the memory is deallocated upon destruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a425d60f2fcad42d8a79c33c587f41a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d60f2fcad42d8a79c33c587f41a06">&#9670;&nbsp;</a></span>createImageFromData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownForeignMemory</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteMemory</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a byte array. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Desired color format of the texture </td></tr>
    <tr><td class="paramname">size</td><td>Desired size of the image </td></tr>
    <tr><td class="paramname">data</td><td>A byte array with pixel color information </td></tr>
    <tr><td class="paramname">ownForeignMemory</td><td>If true, the image will use the data pointer directly and own it afterwards. If false, the memory will by copied internally. </td></tr>
    <tr><td class="paramname">deleteMemory</td><td>Whether the memory is deallocated upon destruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="ac5b4c13f64d96d27fa27f52b68f77b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b4c13f64d96d27fa27f52b68f77b8c">&#9670;&nbsp;</a></span>createImageFromFile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a file. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file from which the image is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="ac5b4c13f64d96d27fa27f52b68f77b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b4c13f64d96d27fa27f52b68f77b8c">&#9670;&nbsp;</a></span>createImageFromFile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a file. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file from which the image is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a322c41fa08c1da9de4633cf8a1e68607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322c41fa08c1da9de4633cf8a1e68607">&#9670;&nbsp;</a></span>createImageFromFile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a file. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>File from which the image is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a322c41fa08c1da9de4633cf8a1e68607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322c41fa08c1da9de4633cf8a1e68607">&#9670;&nbsp;</a></span>createImageFromFile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createImageFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a software image from a file. </p>
<p>No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>File from which the image is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created image. If you no longer need the image, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IImage::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a50db0e36d406089167facf70b2eb4706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50db0e36d406089167facf70b2eb4706">&#9670;&nbsp;</a></span>createScreenShot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createScreenShot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">video::ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">video::ECF_UNKNOWN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">video::E_RENDER_TARGET</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972a232d0f49241a378e11d4a37e752d3d73">video::ERT_FRAME_BUFFER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a screenshot of the last rendered frame. </p>
<dl class="section return"><dt>Returns</dt><dd>An image created from the last rendered frame. </dd></dl>

</div>
</div>
<a id="a50db0e36d406089167facf70b2eb4706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50db0e36d406089167facf70b2eb4706">&#9670;&nbsp;</a></span>createScreenShot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a>* irr::video::IVideoDriver::createScreenShot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">video::ECOLOR_FORMAT</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda8d25e5e1e9c83f95c4f7d48e11688a51">video::ECF_UNKNOWN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">video::E_RENDER_TARGET</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972a232d0f49241a378e11d4a37e752d3d73">video::ERT_FRAME_BUFFER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a screenshot of the last rendered frame. </p>
<dl class="section return"><dt>Returns</dt><dd>An image created from the last rendered frame. </dd></dl>

</div>
</div>
<a id="aea64c03fc205f23ec7575884fb7309c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea64c03fc205f23ec7575884fb7309c8">&#9670;&nbsp;</a></span>disableFeature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::disableFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a>&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a feature of the driver. </p>
<p>Can also be used to enable the features again. It is not possible to enable unsupported features this way, though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>Feature to disable. </td></tr>
    <tr><td class="paramname">flag</td><td>When true the feature is disabled, otherwise it is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea64c03fc205f23ec7575884fb7309c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea64c03fc205f23ec7575884fb7309c8">&#9670;&nbsp;</a></span>disableFeature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::disableFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a>&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a feature of the driver. </p>
<p>Can also be used to enable the features again. It is not possible to enable unsupported features this way, though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>Feature to disable. </td></tr>
    <tr><td class="paramname">flag</td><td>When true the feature is disabled, otherwise it is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f12aefefb24414e03876bca942fb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f12aefefb24414e03876bca942fb02">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d image without any special effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to texture to use. </td></tr>
    <tr><td class="paramname">destPos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f12aefefb24414e03876bca942fb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f12aefefb24414e03876bca942fb02">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d image without any special effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to texture to use. </td></tr>
    <tr><td class="paramname">destPos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167d3a5e2ea5804bfa9ba9e526bbcdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d3a5e2ea5804bfa9ba9e526bbcdb3">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d image using a color. </p>
<p>(if color is other than Color(255,255,255,255)) and the alpha channel of the texture. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">destPos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td class="paramname">sourceRect</td><td>Source rectangle in the image. </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is NULL the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. If the color equals Color(255,255,255,255) it is ignored. Note that the alpha component is used: If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167d3a5e2ea5804bfa9ba9e526bbcdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d3a5e2ea5804bfa9ba9e526bbcdb3">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d image using a color. </p>
<p>(if color is other than Color(255,255,255,255)) and the alpha channel of the texture. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">destPos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td class="paramname">sourceRect</td><td>Source rectangle in the image. </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is NULL the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. If the color equals Color(255,255,255,255) it is ignored. Note that the alpha component is used: If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49258725a8c36dbb22d073acf7927354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49258725a8c36dbb22d073acf7927354">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> *const&#160;</td>
          <td class="paramname"><em>colors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used. </p>
<p>Suggested and first implemented by zola. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture to draw from </td></tr>
    <tr><td class="paramname">destRect</td><td>The rectangle to draw into </td></tr>
    <tr><td class="paramname">sourceRect</td><td>The rectangle denoting a part of the texture </td></tr>
    <tr><td class="paramname">clipRect</td><td>Clips the destination rectangle (may be 0) </td></tr>
    <tr><td class="paramname">colors</td><td>Array of 4 colors denoting the color values of the corners of the destRect </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>True if alpha channel will be blended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49258725a8c36dbb22d073acf7927354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49258725a8c36dbb22d073acf7927354">&#9670;&nbsp;</a></span>draw2DImage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> *const&#160;</td>
          <td class="paramname"><em>colors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used. </p>
<p>Suggested and first implemented by zola. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture to draw from </td></tr>
    <tr><td class="paramname">destRect</td><td>The rectangle to draw into </td></tr>
    <tr><td class="paramname">sourceRect</td><td>The rectangle denoting a part of the texture </td></tr>
    <tr><td class="paramname">clipRect</td><td>Clips the destination rectangle (may be 0) </td></tr>
    <tr><td class="paramname">colors</td><td>Array of 4 colors denoting the color values of the corners of the destRect </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>True if alpha channel will be blended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7647e900a56f23abb0809fd533617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7647e900a56f23abb0809fd533617e">&#9670;&nbsp;</a></span>draw2DImageBatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImageBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>kerningWidth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a set of 2d images, using a color and the alpha channel of the texture. </p>
<p>The images are drawn beginning at pos and concatenated in one line. All drawings are clipped against clipRect (if != 0). The subtextures are defined by the array of sourceRects and are chosen by the indices given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">pos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td class="paramname">sourceRects</td><td>Source rectangles of the image. </td></tr>
    <tr><td class="paramname">indices</td><td>List of indices which choose the actual rectangle used each time. </td></tr>
    <tr><td class="paramname">kerningWidth</td><td>Offset to Position on X </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is 0 then the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7647e900a56f23abb0809fd533617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7647e900a56f23abb0809fd533617e">&#9670;&nbsp;</a></span>draw2DImageBatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImageBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>kerningWidth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a set of 2d images, using a color and the alpha channel of the texture. </p>
<p>The images are drawn beginning at pos and concatenated in one line. All drawings are clipped against clipRect (if != 0). The subtextures are defined by the array of sourceRects and are chosen by the indices given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">pos</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td class="paramname">sourceRects</td><td>Source rectangles of the image. </td></tr>
    <tr><td class="paramname">indices</td><td>List of indices which choose the actual rectangle used each time. </td></tr>
    <tr><td class="paramname">kerningWidth</td><td>Offset to Position on X </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is 0 then the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6485a684c4dfa4d0f94d0edfb46439a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6485a684c4dfa4d0f94d0edfb46439a6">&#9670;&nbsp;</a></span>draw2DImageBatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImageBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a set of 2d images, using a color and the alpha channel of the texture. </p>
<p>All drawings are clipped against clipRect (if != 0). The subtextures are defined by the array of sourceRects and are positioned using the array of positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">positions</td><td>Array of upper left 2d destinations where the images will be drawn. </td></tr>
    <tr><td class="paramname">sourceRects</td><td>Source rectangles of the image. </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the images are clipped to. If this pointer is 0 then the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6485a684c4dfa4d0f94d0edfb46439a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6485a684c4dfa4d0f94d0edfb46439a6">&#9670;&nbsp;</a></span>draw2DImageBatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DImageBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlphaChannelOfTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a set of 2d images, using a color and the alpha channel of the texture. </p>
<p>All drawings are clipped against clipRect (if != 0). The subtextures are defined by the array of sourceRects and are positioned using the array of positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to be drawn. </td></tr>
    <tr><td class="paramname">positions</td><td>Array of upper left 2d destinations where the images will be drawn. </td></tr>
    <tr><td class="paramname">sourceRects</td><td>Source rectangles of the image. </td></tr>
    <tr><td class="paramname">clipRect</td><td>Pointer to rectangle on the screen where the images are clipped to. If this pointer is 0 then the image is not clipped. </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td class="paramname">useAlphaChannelOfTexture</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5388e319a0ae1340c3d81db02dd959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5388e319a0ae1340c3d81db02dd959">&#9670;&nbsp;</a></span>draw2DLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DLine </td>
          <td>(</td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d line. Both start and end will be included in coloring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td class="paramname">end</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5388e319a0ae1340c3d81db02dd959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5388e319a0ae1340c3d81db02dd959">&#9670;&nbsp;</a></span>draw2DLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DLine </td>
          <td>(</td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d line. Both start and end will be included in coloring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td class="paramname">end</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1318379f3d70c9347cfa853b944ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1318379f3d70c9347cfa853b944ad4">&#9670;&nbsp;</a></span>draw2DPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DPolygon </td>
          <td>(</td>
          <td class="paramtype">core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(100,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a non filled concyclic regular 2d polygon. </p>
<p>This method can be used to draw circles, but also triangles, tetragons, pentagons, hexagons, heptagons, octagons, enneagons, decagons, hendecagons, dodecagon, triskaidecagons, etc. I think you'll got it now. And all this by simply specifying the vertex count. Welcome to the wonders of geometry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Position of center of circle (pixels). </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of circle in pixels. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the circle. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices of the polygon. Specify 2 to draw a line, 3 to draw a triangle, 4 for tetragons and a lot (&gt;10) for nearly a circle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1318379f3d70c9347cfa853b944ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1318379f3d70c9347cfa853b944ad4">&#9670;&nbsp;</a></span>draw2DPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DPolygon </td>
          <td>(</td>
          <td class="paramtype">core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(100,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a non filled concyclic regular 2d polygon. </p>
<p>This method can be used to draw circles, but also triangles, tetragons, pentagons, hexagons, heptagons, octagons, enneagons, decagons, hendecagons, dodecagon, triskaidecagons, etc. I think you'll got it now. And all this by simply specifying the vertex count. Welcome to the wonders of geometry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Position of center of circle (pixels). </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of circle in pixels. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the circle. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices of the polygon. Specify 2 to draw a line, 3 to draw a triangle, 4 for tetragons and a lot (&gt;10) for nearly a circle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f452fae0ef8abe01768a78ba7033b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f452fae0ef8abe01768a78ba7033b7">&#9670;&nbsp;</a></span>draw2DRectangle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color of the rectangle to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">clip</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f452fae0ef8abe01768a78ba7033b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f452fae0ef8abe01768a78ba7033b7">&#9670;&nbsp;</a></span>draw2DRectangle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color of the rectangle to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">clip</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83bb3c30be6c9f960a4d8b625d7dee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bb3c30be6c9f960a4d8b625d7dee8c">&#9670;&nbsp;</a></span>draw2DRectangle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorLeftUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorRightUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorLeftDown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorRightDown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d rectangle with a gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorLeftUp</td><td>Color of the upper left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorRightUp</td><td>Color of the upper right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorLeftDown</td><td>Color of the lower left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorRightDown</td><td>Color of the lower right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">clip</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83bb3c30be6c9f960a4d8b625d7dee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bb3c30be6c9f960a4d8b625d7dee8c">&#9670;&nbsp;</a></span>draw2DRectangle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorLeftUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorRightUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorLeftDown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>colorRightDown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; *&#160;</td>
          <td class="paramname"><em>clip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 2d rectangle with a gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorLeftUp</td><td>Color of the upper left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorRightUp</td><td>Color of the upper right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorLeftDown</td><td>Color of the lower left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">colorRightDown</td><td>Color of the lower right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">clip</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65efe36e19f0570988848175a8af7bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65efe36e19f0570988848175a8af7bd1">&#9670;&nbsp;</a></span>draw2DRectangleOutline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangleOutline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a816a136b99c60f8c739005f7da7de914">core::recti</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the outline of a 2D rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the rectangle to draw. The alpha component specifies how transparent the rectangle outline will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65efe36e19f0570988848175a8af7bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65efe36e19f0570988848175a8af7bd1">&#9670;&nbsp;</a></span>draw2DRectangleOutline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DRectangleOutline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a816a136b99c60f8c739005f7da7de914">core::recti</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the outline of a 2D rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the rectangle. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the rectangle to draw. The alpha component specifies how transparent the rectangle outline will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34845920167c68578a78f842af54d140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34845920167c68578a78f842af54d140">&#9670;&nbsp;</a></span>draw2DVertexPrimitiveList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DVertexPrimitiveList </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>primCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a>&#160;</td>
          <td class="paramname"><em>vType</em> = <code><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&#160;</td>
          <td class="paramname"><em>pType</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_INDEX_TYPE&#160;</td>
          <td class="paramname"><em>iType</em> = <code>EIT_16BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a vertex primitive list in 2d. </p>
<p>Compared to the general (3d) version of this method, this one sets up a 2d render mode, and uses only x and y of vectors. Note that, depending on the index type, some vertices might be not accessible through the index list. The limit is at 65535 vertices for 16bit indices. Please note that currently not all primitives are available for all drivers, and some might be emulated via triangle renders. This function is not available for the sw drivers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. These define the vertices used for each primitive. Depending on the pType, indices are interpreted as single objects (for point like primitives), pairs (for lines), triplets (for triangles), or quads. </td></tr>
    <tr><td class="paramname">primCount</td><td>Amount of Primitives </td></tr>
    <tr><td class="paramname">vType</td><td>Vertex type, e.g. <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex. ">video::EVT_STANDARD</a> for <a class="el" href="structirr_1_1video_1_1S3DVertex.html" title="standard vertex used by the Irrlicht engine. ">S3DVertex</a>. </td></tr>
    <tr><td class="paramname">pType</td><td>Primitive type, e.g. <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca0a3f2b49f2dc8c34749e406580a6fc1c" title="After the first two vertices each vertex defines a new triangle. All around the common first vertex...">scene::EPT_TRIANGLE_FAN</a> for a triangle fan. </td></tr>
    <tr><td class="paramname">iType</td><td>Index type, e.g. video::EIT_16BIT for 16bit indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34845920167c68578a78f842af54d140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34845920167c68578a78f842af54d140">&#9670;&nbsp;</a></span>draw2DVertexPrimitiveList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw2DVertexPrimitiveList </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>primCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a>&#160;</td>
          <td class="paramname"><em>vType</em> = <code><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&#160;</td>
          <td class="paramname"><em>pType</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_INDEX_TYPE&#160;</td>
          <td class="paramname"><em>iType</em> = <code>EIT_16BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a vertex primitive list in 2d. </p>
<p>Compared to the general (3d) version of this method, this one sets up a 2d render mode, and uses only x and y of vectors. Note that, depending on the index type, some vertices might be not accessible through the index list. The limit is at 65535 vertices for 16bit indices. Please note that currently not all primitives are available for all drivers, and some might be emulated via triangle renders. This function is not available for the sw drivers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. These define the vertices used for each primitive. Depending on the pType, indices are interpreted as single objects (for point like primitives), pairs (for lines), triplets (for triangles), or quads. </td></tr>
    <tr><td class="paramname">primCount</td><td>Amount of Primitives </td></tr>
    <tr><td class="paramname">vType</td><td>Vertex type, e.g. <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex. ">video::EVT_STANDARD</a> for <a class="el" href="structirr_1_1video_1_1S3DVertex.html" title="standard vertex used by the Irrlicht engine. ">S3DVertex</a>. </td></tr>
    <tr><td class="paramname">pType</td><td>Primitive type, e.g. <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca0a3f2b49f2dc8c34749e406580a6fc1c" title="After the first two vertices each vertex defines a new triangle. All around the common first vertex...">scene::EPT_TRIANGLE_FAN</a> for a triangle fan. </td></tr>
    <tr><td class="paramname">iType</td><td>Index type, e.g. video::EIT_16BIT for 16bit indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7773fce9358ee81db5484b2d21015570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7773fce9358ee81db5484b2d21015570">&#9670;&nbsp;</a></span>draw3DBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d axis aligned box. </p>
<p>This method simply calls draw3DLine for the edges of the box. Note that the box is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The axis aligned box to draw </td></tr>
    <tr><td class="paramname">color</td><td>Color to use while drawing the box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7773fce9358ee81db5484b2d21015570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7773fce9358ee81db5484b2d21015570">&#9670;&nbsp;</a></span>draw3DBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1aabbox3d.html">core::aabbox3d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d axis aligned box. </p>
<p>This method simply calls draw3DLine for the edges of the box. Note that the box is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The axis aligned box to draw </td></tr>
    <tr><td class="paramname">color</td><td>Color to use while drawing the box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e4e03dca1720f3d2019b73a4eebb5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e03dca1720f3d2019b73a4eebb5e6">&#9670;&nbsp;</a></span>draw3DLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d line. </p>
<p>For some implementations, this method simply calls drawVertexPrimitiveList for some triangles. Note that the line is drawn using the current transformation matrix and material. So if you need to draw the 3D line independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the line. Some drivers support line thickness set in the material. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the 3d line. </td></tr>
    <tr><td class="paramname">end</td><td>End of the 3d line. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e4e03dca1720f3d2019b73a4eebb5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e03dca1720f3d2019b73a4eebb5e6">&#9670;&nbsp;</a></span>draw3DLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d line. </p>
<p>For some implementations, this method simply calls drawVertexPrimitiveList for some triangles. Note that the line is drawn using the current transformation matrix and material. So if you need to draw the 3D line independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the line. Some drivers support line thickness set in the material. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the 3d line. </td></tr>
    <tr><td class="paramname">end</td><td>End of the 3d line. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5eb03a333a43d17278dad31be19efca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eb03a333a43d17278dad31be19efca">&#9670;&nbsp;</a></span>draw3DTriangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d triangle. </p>
<p>This method calls drawVertexPrimitiveList for some triangles. This method works with all drivers because it simply calls drawVertexPrimitiveList, but it is hence not very fast. Note that the triangle is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the triangle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle</td><td>The triangle to draw. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5eb03a333a43d17278dad31be19efca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eb03a333a43d17278dad31be19efca">&#9670;&nbsp;</a></span>draw3DTriangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::draw3DTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a8983bda2678a7a67d97bf3c7be6c31c7">core::triangle3df</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a 3d triangle. </p>
<p>This method calls drawVertexPrimitiveList for some triangles. This method works with all drivers because it simply calls drawVertexPrimitiveList, but it is hence not very fast. Note that the triangle is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use </p><div class="fragment"><div class="line">driver-&gt;setMaterial(someMaterial);</div><div class="line">driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43daf0d9765331daace35b8443c471738305">video::ETS_WORLD</a>, <a class="code" href="namespaceirr_1_1core.html#ac4561f3920d3fbfbfff74c9bed1f2713">core::IdentityMatrix</a>);</div></div><!-- fragment --><p> for some properly set up material before drawing the triangle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle</td><td>The triangle to draw. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8303b9a0f3e941d07d8cdc70c8fc1346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8303b9a0f3e941d07d8cdc70c8fc1346">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8303b9a0f3e941d07d8cdc70c8fc1346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8303b9a0f3e941d07d8cdc70c8fc1346">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b8902326a78075ad1b12d0cfc722aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b8902326a78075ad1b12d0cfc722aa">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b8902326a78075ad1b12d0cfc722aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b8902326a78075ad1b12d0cfc722aa">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fbc69e35e987b4d3882e51a62b8030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbc69e35e987b4d3882e51a62b8030b">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fbc69e35e987b4d3882e51a62b8030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbc69e35e987b4d3882e51a62b8030b">&#9670;&nbsp;</a></span>drawIndexedTriangleFan() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleFan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle fan. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55eba6140492faaed9dca7e16ad8dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eba6140492faaed9dca7e16ad8dde2">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55eba6140492faaed9dca7e16ad8dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eba6140492faaed9dca7e16ad8dde2">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex.html">S3DVertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041d8028bc10f33c6707a3d1ddbdea4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d8028bc10f33c6707a3d1ddbdea4d">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041d8028bc10f33c6707a3d1ddbdea4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d8028bc10f33c6707a3d1ddbdea4d">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertex2TCoords.html">S3DVertex2TCoords</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09777bd8ca7a25e6f6134369e5dfb680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09777bd8ca7a25e6f6134369e5dfb680">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09777bd8ca7a25e6f6134369e5dfb680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09777bd8ca7a25e6f6134369e5dfb680">&#9670;&nbsp;</a></span>drawIndexedTriangleList() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::video::IVideoDriver::drawIndexedTriangleList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1video_1_1S3DVertexTangents.html">S3DVertexTangents</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc">u16</a> *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>triangleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an indexed triangle list. </p>
<p>Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. If there are more than 65536 vertices in the list, results of this operation are not defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. </td></tr>
    <tr><td class="paramname">triangleCount</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab09507d0b00502912b75e31d2c344e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09507d0b00502912b75e31d2c344e5c">&#9670;&nbsp;</a></span>drawMeshBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a mesh buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>Buffer to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab09507d0b00502912b75e31d2c344e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09507d0b00502912b75e31d2c344e5c">&#9670;&nbsp;</a></span>drawMeshBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a mesh buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>Buffer to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2ba3fb555e3c7622f3124799440226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2ba3fb555e3c7622f3124799440226">&#9670;&nbsp;</a></span>drawMeshBufferNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawMeshBufferNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>10.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws normals of a mesh buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>Buffer to draw the normals of </td></tr>
    <tr><td class="paramname">length</td><td>length scale factor of the normals </td></tr>
    <tr><td class="paramname">color</td><td>Color the normals are rendered with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2ba3fb555e3c7622f3124799440226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2ba3fb555e3c7622f3124799440226">&#9670;&nbsp;</a></span>drawMeshBufferNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawMeshBufferNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1IMeshBuffer.html">scene::IMeshBuffer</a> *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>10.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws normals of a mesh buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>Buffer to draw the normals of </td></tr>
    <tr><td class="paramname">length</td><td>length scale factor of the normals </td></tr>
    <tr><td class="paramname">color</td><td>Color the normals are rendered with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6567ced74ed6dc8cb1b325493ae7a093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6567ced74ed6dc8cb1b325493ae7a093">&#9670;&nbsp;</a></span>drawPixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-position of the pixel. </td></tr>
    <tr><td class="paramname">y</td><td>The y-position of the pixel. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the pixel to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6567ced74ed6dc8cb1b325493ae7a093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6567ced74ed6dc8cb1b325493ae7a093">&#9670;&nbsp;</a></span>drawPixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-position of the pixel. </td></tr>
    <tr><td class="paramname">y</td><td>The y-position of the pixel. </td></tr>
    <tr><td class="paramname">color</td><td>Color of the pixel to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a985ea57c5cf23b7774044f6ed9f96579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985ea57c5cf23b7774044f6ed9f96579">&#9670;&nbsp;</a></span>drawStencilShadow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawStencilShadow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearStencilBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>leftUpEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>rightUpEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>leftDownEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>rightDownEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the stencil shadow with color. </p>
<p>After the shadow volume has been drawn into the stencil buffer using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae340fe71939b7c1043071507f3330cad" title="Draws a shadow volume into the stencil buffer. ">IVideoDriver::drawStencilShadowVolume()</a>, use this to draw the color of the shadow. Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearStencilBuffer</td><td>Set this to false, if you want to draw every shadow with the same color, and only want to call <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579" title="Fills the stencil shadow with color. ">drawStencilShadow()</a> once after all shadow volumes have been drawn. Set this to true, if you want to paint every shadow with its own color. </td></tr>
    <tr><td class="paramname">leftUpEdge</td><td>Color of the shadow in the upper left corner of screen. </td></tr>
    <tr><td class="paramname">rightUpEdge</td><td>Color of the shadow in the upper right corner of screen. </td></tr>
    <tr><td class="paramname">leftDownEdge</td><td>Color of the shadow in the lower left corner of screen. </td></tr>
    <tr><td class="paramname">rightDownEdge</td><td>Color of the shadow in the lower right corner of screen. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a985ea57c5cf23b7774044f6ed9f96579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985ea57c5cf23b7774044f6ed9f96579">&#9670;&nbsp;</a></span>drawStencilShadow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawStencilShadow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearStencilBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>leftUpEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>rightUpEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>leftDownEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>rightDownEdge</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(255,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the stencil shadow with color. </p>
<p>After the shadow volume has been drawn into the stencil buffer using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ae340fe71939b7c1043071507f3330cad" title="Draws a shadow volume into the stencil buffer. ">IVideoDriver::drawStencilShadowVolume()</a>, use this to draw the color of the shadow. Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearStencilBuffer</td><td>Set this to false, if you want to draw every shadow with the same color, and only want to call <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579" title="Fills the stencil shadow with color. ">drawStencilShadow()</a> once after all shadow volumes have been drawn. Set this to true, if you want to paint every shadow with its own color. </td></tr>
    <tr><td class="paramname">leftUpEdge</td><td>Color of the shadow in the upper left corner of screen. </td></tr>
    <tr><td class="paramname">rightUpEdge</td><td>Color of the shadow in the upper right corner of screen. </td></tr>
    <tr><td class="paramname">leftDownEdge</td><td>Color of the shadow in the lower left corner of screen. </td></tr>
    <tr><td class="paramname">rightDownEdge</td><td>Color of the shadow in the lower right corner of screen. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae340fe71939b7c1043071507f3330cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae340fe71939b7c1043071507f3330cad">&#9670;&nbsp;</a></span>drawStencilShadowVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawStencilShadowVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zfail</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>debugDataVisible</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a shadow volume into the stencil buffer. </p>
<p>To draw a stencil shadow, do this: First, draw all geometry. Then use this method, to draw the shadow volume. Then, use <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579" title="Fills the stencil shadow with color. ">IVideoDriver::drawStencilShadow()</a> to visualize the shadow. Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangles</td><td>Array of 3d vectors, specifying the shadow volume. </td></tr>
    <tr><td class="paramname">zfail</td><td>If set to true, zfail method is used, otherwise zpass. </td></tr>
    <tr><td class="paramname">debugDataVisible</td><td>The debug data that is enabled for this shadow node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae340fe71939b7c1043071507f3330cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae340fe71939b7c1043071507f3330cad">&#9670;&nbsp;</a></span>drawStencilShadowVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawStencilShadowVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#ae6e2b2a6c552833ebbd5b7463d03586b">core::vector3df</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zfail</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>debugDataVisible</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a shadow volume into the stencil buffer. </p>
<p>To draw a stencil shadow, do this: First, draw all geometry. Then use this method, to draw the shadow volume. Then, use <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a985ea57c5cf23b7774044f6ed9f96579" title="Fills the stencil shadow with color. ">IVideoDriver::drawStencilShadow()</a> to visualize the shadow. Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangles</td><td>Array of 3d vectors, specifying the shadow volume. </td></tr>
    <tr><td class="paramname">zfail</td><td>If set to true, zfail method is used, otherwise zpass. </td></tr>
    <tr><td class="paramname">debugDataVisible</td><td>The debug data that is enabled for this shadow node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">&#9670;&nbsp;</a></span>drawVertexPrimitiveList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawVertexPrimitiveList </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>primCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a>&#160;</td>
          <td class="paramname"><em>vType</em> = <code><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&#160;</td>
          <td class="paramname"><em>pType</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_INDEX_TYPE&#160;</td>
          <td class="paramname"><em>iType</em> = <code>EIT_16BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a vertex primitive list. </p>
<p>Note that, depending on the index type, some vertices might be not accessible through the index list. The limit is at 65535 vertices for 16bit indices. Please note that currently not all primitives are available for all drivers, and some might be emulated via triangle renders. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. These define the vertices used for each primitive. Depending on the pType, indices are interpreted as single objects (for point like primitives), pairs (for lines), triplets (for triangles), or quads. </td></tr>
    <tr><td class="paramname">primCount</td><td>Amount of Primitives </td></tr>
    <tr><td class="paramname">vType</td><td>Vertex type, e.g. <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex. ">video::EVT_STANDARD</a> for <a class="el" href="structirr_1_1video_1_1S3DVertex.html" title="standard vertex used by the Irrlicht engine. ">S3DVertex</a>. </td></tr>
    <tr><td class="paramname">pType</td><td>Primitive type, e.g. <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca0a3f2b49f2dc8c34749e406580a6fc1c" title="After the first two vertices each vertex defines a new triangle. All around the common first vertex...">scene::EPT_TRIANGLE_FAN</a> for a triangle fan. </td></tr>
    <tr><td class="paramname">iType</td><td>Index type, e.g. video::EIT_16BIT for 16bit indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18ac3ba8b6dbaa4437c5eb3b1e2f4fb">&#9670;&nbsp;</a></span>drawVertexPrimitiveList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::drawVertexPrimitiveList </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>primCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac">E_VERTEX_TYPE</a>&#160;</td>
          <td class="paramname"><em>vType</em> = <code><a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262">EVT_STANDARD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&#160;</td>
          <td class="paramname"><em>pType</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca6c884c4de3210b3ed36c99fb828ce376">scene::EPT_TRIANGLES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_INDEX_TYPE&#160;</td>
          <td class="paramname"><em>iType</em> = <code>EIT_16BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a vertex primitive list. </p>
<p>Note that, depending on the index type, some vertices might be not accessible through the index list. The limit is at 65535 vertices for 16bit indices. Please note that currently not all primitives are available for all drivers, and some might be emulated via triangle renders. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to array of vertices. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Amount of vertices in the array. </td></tr>
    <tr><td class="paramname">indexList</td><td>Pointer to array of indices. These define the vertices used for each primitive. Depending on the pType, indices are interpreted as single objects (for point like primitives), pairs (for lines), triplets (for triangles), or quads. </td></tr>
    <tr><td class="paramname">primCount</td><td>Amount of Primitives </td></tr>
    <tr><td class="paramname">vType</td><td>Vertex type, e.g. <a class="el" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca921f287a4f48d612a5be2d89453ca262" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex. ">video::EVT_STANDARD</a> for <a class="el" href="structirr_1_1video_1_1S3DVertex.html" title="standard vertex used by the Irrlicht engine. ">S3DVertex</a>. </td></tr>
    <tr><td class="paramname">pType</td><td>Primitive type, e.g. <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dca0a3f2b49f2dc8c34749e406580a6fc1c" title="After the first two vertices each vertex defines a new triangle. All around the common first vertex...">scene::EPT_TRIANGLE_FAN</a> for a triangle fan. </td></tr>
    <tr><td class="paramname">iType</td><td>Index type, e.g. video::EIT_16BIT for 16bit indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaf9567c759f866311c76e3874822339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf9567c759f866311c76e3874822339">&#9670;&nbsp;</a></span>enableClipPlane() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::enableClipPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable a clipping plane. </p>
<p>There are at least 6 clipping planes available for the user to set at will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td class="paramname">enable</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaf9567c759f866311c76e3874822339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf9567c759f866311c76e3874822339">&#9670;&nbsp;</a></span>enableClipPlane() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::enableClipPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable a clipping plane. </p>
<p>There are at least 6 clipping planes available for the user to set at will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td class="paramname">enable</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7686a41fe0f506bb04c262f724f65756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7686a41fe0f506bb04c262f724f65756">&#9670;&nbsp;</a></span>enableMaterial2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::enableMaterial2D </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the 2d override material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Flag which tells whether the material shall be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7686a41fe0f506bb04c262f724f65756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7686a41fe0f506bb04c262f724f65756">&#9670;&nbsp;</a></span>enableMaterial2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::enableMaterial2D </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the 2d override material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Flag which tells whether the material shall be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75f61a93c5fc9fdf161c044d27bc994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f61a93c5fc9fdf161c044d27bc994e">&#9670;&nbsp;</a></span>endScene() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::endScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Presents the rendered image to the screen. </p>
<p>Applications must call this method after performing any rendering. </p><dl class="section return"><dt>Returns</dt><dd>False if failed and true if succeeded. </dd></dl>

</div>
</div>
<a id="a75f61a93c5fc9fdf161c044d27bc994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f61a93c5fc9fdf161c044d27bc994e">&#9670;&nbsp;</a></span>endScene() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::endScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Presents the rendered image to the screen. </p>
<p>Applications must call this method after performing any rendering. </p><dl class="section return"><dt>Returns</dt><dd>False if failed and true if succeeded. </dd></dl>

</div>
</div>
<a id="a9b7b5942cf2378f9f96d47ec7a0cd881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7b5942cf2378f9f96d47ec7a0cd881">&#9670;&nbsp;</a></span>fillMaterialStructureFromAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::fillMaterialStructureFromAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>outMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills an <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> structure from attributes. </p>
<p>Please note that for setting material types of the material, the video driver will need to query the material renderers for their names, so all non built-in materials must have been created before calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outMaterial</td><td>The material to set the properties for. </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b7b5942cf2378f9f96d47ec7a0cd881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7b5942cf2378f9f96d47ec7a0cd881">&#9670;&nbsp;</a></span>fillMaterialStructureFromAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::fillMaterialStructureFromAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SMaterial.html">video::SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>outMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills an <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> structure from attributes. </p>
<p>Please note that for setting material types of the material, the video driver will need to query the material renderers for their names, so all non built-in materials must have been created before calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outMaterial</td><td>The material to set the properties for. </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4eaed6d56b092e6805400ca59795de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eaed6d56b092e6805400ca59795de9">&#9670;&nbsp;</a></span>findTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a>* irr::video::IVideoDriver::findTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the image is already loaded. </p>
<p>Works similar to <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a>, but does not load the texture if it is not currently loaded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to loaded texture, or 0 if not found. </dd></dl>

</div>
</div>
<a id="ad4eaed6d56b092e6805400ca59795de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eaed6d56b092e6805400ca59795de9">&#9670;&nbsp;</a></span>findTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a>* irr::video::IVideoDriver::findTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the image is already loaded. </p>
<p>Works similar to <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#af4055165190e4adf221c6dc6f2434ea0" title="Get access to a named texture. ">getTexture()</a>, but does not load the texture if it is not currently loaded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to loaded texture, or 0 if not found. </dd></dl>

</div>
</div>
<a id="afc8f27bfd9756f4ca8de2d4bb37b0e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8f27bfd9756f4ca8de2d4bb37b0e15">&#9670;&nbsp;</a></span>getColorFormat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> irr::video::IVideoDriver::getColorFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current color format of the color buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Color format of the color buffer. </dd></dl>

</div>
</div>
<a id="afc8f27bfd9756f4ca8de2d4bb37b0e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8f27bfd9756f4ca8de2d4bb37b0e15">&#9670;&nbsp;</a></span>getColorFormat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829ed">ECOLOR_FORMAT</a> irr::video::IVideoDriver::getColorFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current color format of the color buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Color format of the color buffer. </dd></dl>

</div>
</div>
<a id="a76fc2aba131b5986d07d92c6888cfc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc2aba131b5986d07d92c6888cfc0c">&#9670;&nbsp;</a></span>getCurrentRenderTargetSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&gt;&amp; irr::video::IVideoDriver::getCurrentRenderTargetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the current render target. </p>
<p>This method will return the screen size if the driver doesn't support render to texture, or if the current render target is the screen. </p><dl class="section return"><dt>Returns</dt><dd>Size of render target or screen/window </dd></dl>

</div>
</div>
<a id="a76fc2aba131b5986d07d92c6888cfc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc2aba131b5986d07d92c6888cfc0c">&#9670;&nbsp;</a></span>getCurrentRenderTargetSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&gt;&amp; irr::video::IVideoDriver::getCurrentRenderTargetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the current render target. </p>
<p>This method will return the screen size if the driver doesn't support render to texture, or if the current render target is the screen. </p><dl class="section return"><dt>Returns</dt><dd>Size of render target or screen/window </dd></dl>

</div>
</div>
<a id="a2b43d2215f2e5aad9b4f92aa635bcc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b43d2215f2e5aad9b4f92aa635bcc85">&#9670;&nbsp;</a></span>getDriverAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a>&amp; irr::video::IVideoDriver::getDriverAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get attributes of the actual video driver. </p>
<p>The following names can be queried for the given types: MaxTextures (int) The maximum number of simultaneous textures supported by the driver. This can be less than the supported number of textures of the driver. Use <em>IRR_MATERIAL_MAX_TEXTURES</em> to adapt the number. MaxSupportedTextures (int) The maximum number of simultaneous textures supported by the fixed function pipeline of the (hw) driver. The actual supported number of textures supported by the engine can be lower. MaxLights (int) Number of hardware lights supported in the fixed function pipieline of the driver, typically 6-8. Use light manager or deferred shading for more. MaxAnisotropy (int) Number of anisotropy levels supported for filtering. At least 1, max is typically at 16 or 32. MaxUserClipPlanes (int) Number of additional clip planes, which can be set by the user via dedicated driver methods. MaxAuxBuffers (int) Special render buffers, which are currently not really usable inside Irrlicht. Only supported by OpenGL MaxMultipleRenderTargets (int) Number of render targets which can be bound simultaneously. Rendering to MRTs is done via shaders. MaxIndices (int) Number of indices which can be used in one render call (i.e. one mesh buffer). MaxTextureSize (int) Dimension that a texture may have, both in width and height. MaxGeometryVerticesOut (int) Number of vertices the geometry shader can output in one pass. Only OpenGL so far. MaxTextureLODBias (float) Maximum value for LOD bias. Is usually at around 16, but can be lower on some systems. Version (int) Version of the driver. Should be Major*100+Minor ShaderLanguageVersion (int) Version of the high level shader language. Should be Major*100+Minor. AntiAlias (int) Number of Samples the driver uses for each pixel. 0 and 1 means anti aliasing is off, typical values are 2,4,8,16,32 </p>

</div>
</div>
<a id="a2b43d2215f2e5aad9b4f92aa635bcc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b43d2215f2e5aad9b4f92aa635bcc85">&#9670;&nbsp;</a></span>getDriverAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a>&amp; irr::video::IVideoDriver::getDriverAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get attributes of the actual video driver. </p>
<p>The following names can be queried for the given types: MaxTextures (int) The maximum number of simultaneous textures supported by the driver. This can be less than the supported number of textures of the driver. Use <em>IRR_MATERIAL_MAX_TEXTURES</em> to adapt the number. MaxSupportedTextures (int) The maximum number of simultaneous textures supported by the fixed function pipeline of the (hw) driver. The actual supported number of textures supported by the engine can be lower. MaxLights (int) Number of hardware lights supported in the fixed function pipieline of the driver, typically 6-8. Use light manager or deferred shading for more. MaxAnisotropy (int) Number of anisotropy levels supported for filtering. At least 1, max is typically at 16 or 32. MaxUserClipPlanes (int) Number of additional clip planes, which can be set by the user via dedicated driver methods. MaxAuxBuffers (int) Special render buffers, which are currently not really usable inside Irrlicht. Only supported by OpenGL MaxMultipleRenderTargets (int) Number of render targets which can be bound simultaneously. Rendering to MRTs is done via shaders. MaxIndices (int) Number of indices which can be used in one render call (i.e. one mesh buffer). MaxTextureSize (int) Dimension that a texture may have, both in width and height. MaxGeometryVerticesOut (int) Number of vertices the geometry shader can output in one pass. Only OpenGL so far. MaxTextureLODBias (float) Maximum value for LOD bias. Is usually at around 16, but can be lower on some systems. Version (int) Version of the driver. Should be Major*100+Minor ShaderLanguageVersion (int) Version of the high level shader language. Should be Major*100+Minor. AntiAlias (int) Number of Samples the driver uses for each pixel. 0 and 1 means anti aliasing is off, typical values are 2,4,8,16,32 </p>

</div>
</div>
<a id="af89a0c4fcc0337f3befe8b90424e68aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89a0c4fcc0337f3befe8b90424e68aa">&#9670;&nbsp;</a></span>getDriverType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0">E_DRIVER_TYPE</a> irr::video::IVideoDriver::getDriverType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get type of video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Type of driver. </dd></dl>

</div>
</div>
<a id="af89a0c4fcc0337f3befe8b90424e68aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89a0c4fcc0337f3befe8b90424e68aa">&#9670;&nbsp;</a></span>getDriverType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0">E_DRIVER_TYPE</a> irr::video::IVideoDriver::getDriverType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get type of video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Type of driver. </dd></dl>

</div>
</div>
<a id="a9eb9ee246e85a56300031f7d7516054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb9ee246e85a56300031f7d7516054e">&#9670;&nbsp;</a></span>getDynamicLight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a>&amp; irr::video::IVideoDriver::getDynamicLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns light data which was previously set by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">IVideoDriver::addDynamicLight()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Zero based index of the light. Must be 0 or greater and smaller than <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b1e5de698f264a9f74a17bdba313138" title="Returns amount of dynamic lights currently set. ">IVideoDriver::getDynamicLightCount</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Light data. </dd></dl>

</div>
</div>
<a id="a9eb9ee246e85a56300031f7d7516054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb9ee246e85a56300031f7d7516054e">&#9670;&nbsp;</a></span>getDynamicLight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structirr_1_1video_1_1SLight.html">SLight</a>&amp; irr::video::IVideoDriver::getDynamicLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns light data which was previously set by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a813a39352eae26c4d30b5882618639be" title="adds a dynamic light, returning an index to the light ">IVideoDriver::addDynamicLight()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Zero based index of the light. Must be 0 or greater and smaller than <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a9b1e5de698f264a9f74a17bdba313138" title="Returns amount of dynamic lights currently set. ">IVideoDriver::getDynamicLightCount</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Light data. </dd></dl>

</div>
</div>
<a id="a9b1e5de698f264a9f74a17bdba313138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1e5de698f264a9f74a17bdba313138">&#9670;&nbsp;</a></span>getDynamicLightCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getDynamicLightCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of dynamic lights currently set. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of dynamic lights currently set </dd></dl>

</div>
</div>
<a id="a9b1e5de698f264a9f74a17bdba313138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1e5de698f264a9f74a17bdba313138">&#9670;&nbsp;</a></span>getDynamicLightCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getDynamicLightCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of dynamic lights currently set. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of dynamic lights currently set </dd></dl>

</div>
</div>
<a id="a4f3535b2125e654e2e9645745e50cc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3535b2125e654e2e9645745e50cc49">&#9670;&nbsp;</a></span>getExposedVideoData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>&amp; irr::video::IVideoDriver::getExposedVideoData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns driver and operating system specific data about the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions. ">IVideoDriver</a>. </p>
<p>This method should only be used if the engine should be extended without having to modify the source of the engine. </p><dl class="section return"><dt>Returns</dt><dd>Collection of device dependent pointers. </dd></dl>

</div>
</div>
<a id="a4f3535b2125e654e2e9645745e50cc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3535b2125e654e2e9645745e50cc49">&#9670;&nbsp;</a></span>getExposedVideoData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structirr_1_1video_1_1SExposedVideoData.html">SExposedVideoData</a>&amp; irr::video::IVideoDriver::getExposedVideoData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns driver and operating system specific data about the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions. ">IVideoDriver</a>. </p>
<p>This method should only be used if the engine should be extended without having to modify the source of the engine. </p><dl class="section return"><dt>Returns</dt><dd>Collection of device dependent pointers. </dd></dl>

</div>
</div>
<a id="a5b71428402c0b6a3b18b8f2fa408af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b71428402c0b6a3b18b8f2fa408af13">&#9670;&nbsp;</a></span>getFPS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::getFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current frames per second value. </p>
<p>This value is updated approximately every 1.5 seconds and is only intended to provide a rough guide to the average frame rate. It is not suitable for use in performing timing calculations or framerate independent movement. </p><dl class="section return"><dt>Returns</dt><dd>Approximate amount of frames per second drawn. </dd></dl>

</div>
</div>
<a id="a5b71428402c0b6a3b18b8f2fa408af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b71428402c0b6a3b18b8f2fa408af13">&#9670;&nbsp;</a></span>getFPS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IVideoDriver::getFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current frames per second value. </p>
<p>This value is updated approximately every 1.5 seconds and is only intended to provide a rough guide to the average frame rate. It is not suitable for use in performing timing calculations or framerate independent movement. </p><dl class="section return"><dt>Returns</dt><dd>Approximate amount of frames per second drawn. </dd></dl>

</div>
</div>
<a id="ad2098a408bbe9dad8053c3f4aea7d856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2098a408bbe9dad8053c3f4aea7d856">&#9670;&nbsp;</a></span>getGPUProgrammingServices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html">IGPUProgrammingServices</a>* irr::video::IVideoDriver::getGPUProgrammingServices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a> interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a>. Returns 0 if the video driver does not support this. For example the Software driver and the Null driver will always return 0. </dd></dl>

</div>
</div>
<a id="ad2098a408bbe9dad8053c3f4aea7d856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2098a408bbe9dad8053c3f4aea7d856">&#9670;&nbsp;</a></span>getGPUProgrammingServices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html">IGPUProgrammingServices</a>* irr::video::IVideoDriver::getGPUProgrammingServices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a> interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classirr_1_1video_1_1IGPUProgrammingServices.html" title="Interface making it possible to create and use programs running on the GPU. ">IGPUProgrammingServices</a>. Returns 0 if the video driver does not support this. For example the Software driver and the Null driver will always return 0. </dd></dl>

</div>
</div>
<a id="a5cc08e7cd2ce2a30275e22ce13bb1013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc08e7cd2ce2a30275e22ce13bb1013">&#9670;&nbsp;</a></span>getImageLoader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a>* irr::video::IVideoDriver::getImageLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given image loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the loader to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified loader, 0 if the index is incorrect. </dd></dl>

</div>
</div>
<a id="a5cc08e7cd2ce2a30275e22ce13bb1013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc08e7cd2ce2a30275e22ce13bb1013">&#9670;&nbsp;</a></span>getImageLoader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImageLoader.html">IImageLoader</a>* irr::video::IVideoDriver::getImageLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given image loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the loader to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified loader, 0 if the index is incorrect. </dd></dl>

</div>
</div>
<a id="a92535921ad01c90570533ba60b0b76b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92535921ad01c90570533ba60b0b76b2">&#9670;&nbsp;</a></span>getImageLoaderCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getImageLoaderCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of image loaders. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of image loaders </dd></dl>

</div>
</div>
<a id="a92535921ad01c90570533ba60b0b76b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92535921ad01c90570533ba60b0b76b2">&#9670;&nbsp;</a></span>getImageLoaderCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getImageLoaderCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of image loaders. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of image loaders </dd></dl>

</div>
</div>
<a id="acdc5e788993c117efebb22e155ab6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc5e788993c117efebb22e155ab6a77">&#9670;&nbsp;</a></span>getImageWriter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a>* irr::video::IVideoDriver::getImageWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given image writer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the writer to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified writer, 0 if the index is incorrect. </dd></dl>

</div>
</div>
<a id="acdc5e788993c117efebb22e155ab6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc5e788993c117efebb22e155ab6a77">&#9670;&nbsp;</a></span>getImageWriter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IImageWriter.html">IImageWriter</a>* irr::video::IVideoDriver::getImageWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given image writer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the writer to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified writer, 0 if the index is incorrect. </dd></dl>

</div>
</div>
<a id="a173f33f0537a1511abdf35ed235a683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173f33f0537a1511abdf35ed235a683a">&#9670;&nbsp;</a></span>getImageWriterCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getImageWriterCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of image writers. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of image writers </dd></dl>

</div>
</div>
<a id="a173f33f0537a1511abdf35ed235a683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173f33f0537a1511abdf35ed235a683a">&#9670;&nbsp;</a></span>getImageWriterCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getImageWriterCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of image writers. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of image writers </dd></dl>

</div>
</div>
<a id="a198bbe60fdb1b5d6d0f4921e8a26109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198bbe60fdb1b5d6d0f4921e8a26109c">&#9670;&nbsp;</a></span>getMaterial2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a>&amp; irr::video::IVideoDriver::getMaterial2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 2d override material for altering its values. </p>
<p>The 2d override materual allows to alter certain render states of the 2d methods. Not all members of <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> are honored, especially not MaterialType and Textures. Moreover, the zbuffer is always ignored, and lighting is always off. All other flags can be changed, though some might have to effect in most cases. Please note that you have to enable/disable this effect with enableInitMaterial2D(). This effect is costly, as it increases the number of state changes considerably. Always reset the values when done. </p><dl class="section return"><dt>Returns</dt><dd>Material reference which should be altered to reflect the new settings. </dd></dl>

</div>
</div>
<a id="a198bbe60fdb1b5d6d0f4921e8a26109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198bbe60fdb1b5d6d0f4921e8a26109c">&#9670;&nbsp;</a></span>getMaterial2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a>&amp; irr::video::IVideoDriver::getMaterial2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 2d override material for altering its values. </p>
<p>The 2d override materual allows to alter certain render states of the 2d methods. Not all members of <a class="el" href="classirr_1_1video_1_1SMaterial.html" title="Struct for holding parameters for a material renderer. ">SMaterial</a> are honored, especially not MaterialType and Textures. Moreover, the zbuffer is always ignored, and lighting is always off. All other flags can be changed, though some might have to effect in most cases. Please note that you have to enable/disable this effect with enableInitMaterial2D(). This effect is costly, as it increases the number of state changes considerably. Always reset the values when done. </p><dl class="section return"><dt>Returns</dt><dd>Material reference which should be altered to reflect the new settings. </dd></dl>

</div>
</div>
<a id="accb321dfb32ad3c76efb99427bc90cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb321dfb32ad3c76efb99427bc90cc8">&#9670;&nbsp;</a></span>getMaterialRenderer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a>* irr::video::IVideoDriver::getMaterialRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a material renderer by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to material renderer or null if not existing. </dd></dl>

</div>
</div>
<a id="accb321dfb32ad3c76efb99427bc90cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb321dfb32ad3c76efb99427bc90cc8">&#9670;&nbsp;</a></span>getMaterialRenderer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IMaterialRenderer.html">IMaterialRenderer</a>* irr::video::IVideoDriver::getMaterialRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a material renderer by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to material renderer or null if not existing. </dd></dl>

</div>
</div>
<a id="ac1d0e2e952afdcdbdd915dc106375381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0e2e952afdcdbdd915dc106375381">&#9670;&nbsp;</a></span>getMaterialRendererCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaterialRendererCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get amount of currently available material renderers. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of currently available material renderers. </dd></dl>

</div>
</div>
<a id="ac1d0e2e952afdcdbdd915dc106375381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0e2e952afdcdbdd915dc106375381">&#9670;&nbsp;</a></span>getMaterialRendererCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaterialRendererCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get amount of currently available material renderers. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of currently available material renderers. </dd></dl>

</div>
</div>
<a id="ac6f8c53abcd5a24d94c84185b0ef65e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f8c53abcd5a24d94c84185b0ef65e0">&#9670;&nbsp;</a></span>getMaterialRendererName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a>* irr::video::IVideoDriver::getMaterialRendererName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of a material renderer. </p>
<p>This string can, e.g., be used to test if a specific renderer already has been registered/created, or use this string to store data about materials: This returned name will be also used when serializing materials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with the name of the renderer, or 0 if not exisiting </dd></dl>

</div>
</div>
<a id="ac6f8c53abcd5a24d94c84185b0ef65e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f8c53abcd5a24d94c84185b0ef65e0">&#9670;&nbsp;</a></span>getMaterialRendererName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a>* irr::video::IVideoDriver::getMaterialRendererName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of a material renderer. </p>
<p>This string can, e.g., be used to test if a specific renderer already has been registered/created, or use this string to store data about materials: This returned name will be also used when serializing materials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with the name of the renderer, or 0 if not exisiting </dd></dl>

</div>
</div>
<a id="ab64a2875011c8870fd011a486f3503ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a2875011c8870fd011a486f3503ec">&#9670;&nbsp;</a></span>getMaximalDynamicLightAmount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaximalDynamicLightAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximal amount of dynamic lights the device can handle. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximal amount of dynamic lights. </dd></dl>

</div>
</div>
<a id="ab64a2875011c8870fd011a486f3503ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a2875011c8870fd011a486f3503ec">&#9670;&nbsp;</a></span>getMaximalDynamicLightAmount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaximalDynamicLightAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximal amount of dynamic lights the device can handle. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximal amount of dynamic lights. </dd></dl>

</div>
</div>
<a id="afd93e778fac79f7863da72a50e720f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93e778fac79f7863da72a50e720f88">&#9670;&nbsp;</a></span>getMaximalPrimitiveCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaximalPrimitiveCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum amount of primitives. </p>
<p>(mostly vertices) which the device is able to render with one drawVertexPrimitiveList call. </p><dl class="section return"><dt>Returns</dt><dd>Maximum amount of primitives. </dd></dl>

</div>
</div>
<a id="afd93e778fac79f7863da72a50e720f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93e778fac79f7863da72a50e720f88">&#9670;&nbsp;</a></span>getMaximalPrimitiveCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getMaximalPrimitiveCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum amount of primitives. </p>
<p>(mostly vertices) which the device is able to render with one drawVertexPrimitiveList call. </p><dl class="section return"><dt>Returns</dt><dd>Maximum amount of primitives. </dd></dl>

</div>
</div>
<a id="a87ca51832295b2dceaa1e258daf863f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca51832295b2dceaa1e258daf863f1">&#9670;&nbsp;</a></span>getName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const wchar_t* irr::video::IVideoDriver::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets name of this video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the video driver, e.g. in case of the Direct3D8 driver, it would return "Direct3D 8.1". </dd></dl>

</div>
</div>
<a id="a87ca51832295b2dceaa1e258daf863f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca51832295b2dceaa1e258daf863f1">&#9670;&nbsp;</a></span>getName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const wchar_t* irr::video::IVideoDriver::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets name of this video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the video driver, e.g. in case of the Direct3D8 driver, it would return "Direct3D 8.1". </dd></dl>

</div>
</div>
<a id="a149ea92e04b2d0fe18bf5b584ccf6de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149ea92e04b2d0fe18bf5b584ccf6de4">&#9670;&nbsp;</a></span>getOcclusionQueryResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getOcclusionQueryResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return query result. </p>
<p>Return value is the number of visible pixels/fragments. The value is a safe approximation, i.e. can be larger than the actual value of pixels. </p>

</div>
</div>
<a id="a149ea92e04b2d0fe18bf5b584ccf6de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149ea92e04b2d0fe18bf5b584ccf6de4">&#9670;&nbsp;</a></span>getOcclusionQueryResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getOcclusionQueryResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return query result. </p>
<p>Return value is the number of visible pixels/fragments. The value is a safe approximation, i.e. can be larger than the actual value of pixels. </p>

</div>
</div>
<a id="af119ebfd02f99f77a463007277abf14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af119ebfd02f99f77a463007277abf14a">&#9670;&nbsp;</a></span>getOverrideMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SOverrideMaterial&amp; irr::video::IVideoDriver::getOverrideMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global Material, which might override local materials. </p>
<p>Depending on the enable flags, values from this Material are used to override those of local materials of some meshbuffer being rendered. </p><dl class="section return"><dt>Returns</dt><dd>Reference to the Override Material. </dd></dl>

</div>
</div>
<a id="af119ebfd02f99f77a463007277abf14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af119ebfd02f99f77a463007277abf14a">&#9670;&nbsp;</a></span>getOverrideMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SOverrideMaterial&amp; irr::video::IVideoDriver::getOverrideMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global Material, which might override local materials. </p>
<p>Depending on the enable flags, values from this Material are used to override those of local materials of some meshbuffer being rendered. </p><dl class="section return"><dt>Returns</dt><dd>Reference to the Override Material. </dd></dl>

</div>
</div>
<a id="a2ce9be45cacb4aa034d3afdb489a57a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce9be45cacb4aa034d3afdb489a57a3">&#9670;&nbsp;</a></span>getPrimitiveCountDrawn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getPrimitiveCountDrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of primitives (mostly triangles) which were drawn in the last frame. </p>
<p>Together with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5b71428402c0b6a3b18b8f2fa408af13" title="Returns current frames per second value. ">getFPS()</a> very useful method for statistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Defines if the primitives drawn are accumulated or counted per frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of primitives drawn in the last frame. </dd></dl>

</div>
</div>
<a id="a2ce9be45cacb4aa034d3afdb489a57a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce9be45cacb4aa034d3afdb489a57a3">&#9670;&nbsp;</a></span>getPrimitiveCountDrawn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getPrimitiveCountDrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of primitives (mostly triangles) which were drawn in the last frame. </p>
<p>Together with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a5b71428402c0b6a3b18b8f2fa408af13" title="Returns current frames per second value. ">getFPS()</a> very useful method for statistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Defines if the primitives drawn are accumulated or counted per frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of primitives drawn in the last frame. </dd></dl>

</div>
</div>
<a id="aa106dd9ff233497f9ea9a07dc6441c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa106dd9ff233497f9ea9a07dc6441c82">&#9670;&nbsp;</a></span>getScreenSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&gt;&amp; irr::video::IVideoDriver::getScreenSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the screen or render window. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of screen or render window. </dd></dl>

</div>
</div>
<a id="aa106dd9ff233497f9ea9a07dc6441c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa106dd9ff233497f9ea9a07dc6441c82">&#9670;&nbsp;</a></span>getScreenSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&gt;&amp; irr::video::IVideoDriver::getScreenSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the screen or render window. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of screen or render window. </dd></dl>

</div>
</div>
<a id="af4055165190e4adf221c6dc6f2434ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4055165190e4adf221c6dc6f2434ea0">&#9670;&nbsp;</a></span>getTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a named texture. </p>
<p>Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of the texture to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="af4055165190e4adf221c6dc6f2434ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4055165190e4adf221c6dc6f2434ea0">&#9670;&nbsp;</a></span>getTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a named texture. </p>
<p>Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of the texture to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aaf989c8688ffe2a28a4b8e7b6ec2bce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf989c8688ffe2a28a4b8e7b6ec2bce7">&#9670;&nbsp;</a></span>getTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a named texture. </p>
<p>Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Pointer to an already opened file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="aaf989c8688ffe2a28a4b8e7b6ec2bce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf989c8688ffe2a28a4b8e7b6ec2bce7">&#9670;&nbsp;</a></span>getTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to a named texture. </p>
<p>Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Pointer to an already opened file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="abfe395b1320ac52cea6be0e912135351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe395b1320ac52cea6be0e912135351">&#9670;&nbsp;</a></span>getTextureByIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTextureByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a texture by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the texture, must be smaller than <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4c3f976980dd8387db37feca8c8e2d73" title="Returns amount of textures currently loaded. ">getTextureCount()</a> Please note that this index might change when adding or removing textures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture was not set or index is out of bounds. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="abfe395b1320ac52cea6be0e912135351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe395b1320ac52cea6be0e912135351">&#9670;&nbsp;</a></span>getTextureByIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a>* irr::video::IVideoDriver::getTextureByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a texture by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the texture, must be smaller than <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a4c3f976980dd8387db37feca8c8e2d73" title="Returns amount of textures currently loaded. ">getTextureCount()</a> Please note that this index might change when adding or removing textures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture, or 0 if the texture was not set or index is out of bounds. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a id="a4c3f976980dd8387db37feca8c8e2d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f976980dd8387db37feca8c8e2d73">&#9670;&nbsp;</a></span>getTextureCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getTextureCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of textures currently loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of textures currently loaded </dd></dl>

</div>
</div>
<a id="a4c3f976980dd8387db37feca8c8e2d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f976980dd8387db37feca8c8e2d73">&#9670;&nbsp;</a></span>getTextureCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::video::IVideoDriver::getTextureCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of textures currently loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of textures currently loaded </dd></dl>

</div>
</div>
<a id="ae64d474cbca38f64f2dbb8fcacb1a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d474cbca38f64f2dbb8fcacb1a035">&#9670;&nbsp;</a></span>getTextureCreationFlag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::getTextureCreationFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a texture creation flag is enabled or disabled. </p>
<p>You can change this value using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Texture creation flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current texture creation flag enabled mode. </dd></dl>

</div>
</div>
<a id="ae64d474cbca38f64f2dbb8fcacb1a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d474cbca38f64f2dbb8fcacb1a035">&#9670;&nbsp;</a></span>getTextureCreationFlag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::getTextureCreationFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a texture creation flag is enabled or disabled. </p>
<p>You can change this value using <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a868b58a6b86b9e4841ca3879ce246c4e" title="Enables or disables a texture creation flag. ">setTextureCreationFlag()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Texture creation flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current texture creation flag enabled mode. </dd></dl>

</div>
</div>
<a id="a85c7d04aee02c2d5d8102279f9233101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c7d04aee02c2d5d8102279f9233101">&#9670;&nbsp;</a></span>getTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&amp; irr::video::IVideoDriver::getTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transformation set by setTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Transformation type to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix describing the transformation. </dd></dl>

</div>
</div>
<a id="a85c7d04aee02c2d5d8102279f9233101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c7d04aee02c2d5d8102279f9233101">&#9670;&nbsp;</a></span>getTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a>&amp; irr::video::IVideoDriver::getTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transformation set by setTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Transformation type to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix describing the transformation. </dd></dl>

</div>
</div>
<a id="aa21810374736559e937fcad30ac699b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21810374736559e937fcad30ac699b4">&#9670;&nbsp;</a></span>getViewPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt;<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&gt;&amp; irr::video::IVideoDriver::getViewPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the area of the current viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Rectangle of the current viewport. </dd></dl>

</div>
</div>
<a id="aa21810374736559e937fcad30ac699b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21810374736559e937fcad30ac699b4">&#9670;&nbsp;</a></span>getViewPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt;<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&gt;&amp; irr::video::IVideoDriver::getViewPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the area of the current viewport. </p>
<dl class="section return"><dt>Returns</dt><dd>Rectangle of the current viewport. </dd></dl>

</div>
</div>
<a id="a701e7d2101eb26888f57928134bc2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701e7d2101eb26888f57928134bc2ffb">&#9670;&nbsp;</a></span>makeColorKeyTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeColorKeyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroTexels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a boolean alpha channel on the texture based on a color key. </p>
<p>This makes the texture fully transparent at the texels where this color key can be found when using for example draw2DImage with useAlphachannel==true. The alpha of other texels is not modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">color</td><td>Color key color. Every texel with this color will become fully transparent as described above. Please note that the colors of a texture may be converted when loading it, so the color values may not be exactly the same in the engine and for example in picture edit programs. To avoid this problem, you could use the makeColorKeyTexture method, which takes the position of a pixel instead a color value. </td></tr>
    <tr><td class="paramname">zeroTexels</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701e7d2101eb26888f57928134bc2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701e7d2101eb26888f57928134bc2ffb">&#9670;&nbsp;</a></span>makeColorKeyTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeColorKeyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroTexels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a boolean alpha channel on the texture based on a color key. </p>
<p>This makes the texture fully transparent at the texels where this color key can be found when using for example draw2DImage with useAlphachannel==true. The alpha of other texels is not modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">color</td><td>Color key color. Every texel with this color will become fully transparent as described above. Please note that the colors of a texture may be converted when loading it, so the color values may not be exactly the same in the engine and for example in picture edit programs. To avoid this problem, you could use the makeColorKeyTexture method, which takes the position of a pixel instead a color value. </td></tr>
    <tr><td class="paramname">zeroTexels</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed772902f4fe1185b44ce81b9b0b9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed772902f4fe1185b44ce81b9b0b9add">&#9670;&nbsp;</a></span>makeColorKeyTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeColorKeyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt;&#160;</td>
          <td class="paramname"><em>colorKeyPixelPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroTexels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a boolean alpha channel on the texture based on the color at a position. </p>
<p>This makes the texture fully transparent at the texels where the color key can be found when using for example draw2DImage with useAlphachannel==true. The alpha of other texels is not modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">colorKeyPixelPos</td><td>Position of a pixel with the color key color. Every texel with this color will become fully transparent as described above. </td></tr>
    <tr><td class="paramname">zeroTexels</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed772902f4fe1185b44ce81b9b0b9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed772902f4fe1185b44ce81b9b0b9add">&#9670;&nbsp;</a></span>makeColorKeyTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeColorKeyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::position2d&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt;&#160;</td>
          <td class="paramname"><em>colorKeyPixelPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroTexels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a boolean alpha channel on the texture based on the color at a position. </p>
<p>This makes the texture fully transparent at the texels where the color key can be found when using for example draw2DImage with useAlphachannel==true. The alpha of other texels is not modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">colorKeyPixelPos</td><td>Position of a pixel with the color key color. Every texel with this color will become fully transparent as described above. </td></tr>
    <tr><td class="paramname">zeroTexels</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6470e31c1aaf2c0fa5e5a5b3f8f092e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">&#9670;&nbsp;</a></span>makeNormalMapTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeNormalMapTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>amplitude</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a normal map from a height map texture. </p>
<p>If the target texture has 32 bit, the height value is stored in the alpha component of the texture as addition. This value is used by the <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a934021cc4ff72a7ac1a66f392b9abb82" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping. ">video::EMT_PARALLAX_MAP_SOLID</a> material and similar materials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">amplitude</td><td>Constant value by which the height information is multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6470e31c1aaf2c0fa5e5a5b3f8f092e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470e31c1aaf2c0fa5e5a5b3f8f092e0">&#9670;&nbsp;</a></span>makeNormalMapTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::makeNormalMapTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>amplitude</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a normal map from a height map texture. </p>
<p>If the target texture has 32 bit, the height value is stored in the alpha component of the texture as addition. This value is used by the <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a934021cc4ff72a7ac1a66f392b9abb82" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping. ">video::EMT_PARALLAX_MAP_SOLID</a> material and similar materials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td class="paramname">amplitude</td><td>Constant value by which the height information is multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a236e1233fc6fc2c5f36aaa830814fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a236e1233fc6fc2c5f36aaa830814fc">&#9670;&nbsp;</a></span>OnResize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::OnResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event handler for resize events. Only used by the engine internally. </p>
<p>Used to notify the driver that the window was resized. Usually, there is no need to call this method. </p>

</div>
</div>
<a id="a1a236e1233fc6fc2c5f36aaa830814fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a236e1233fc6fc2c5f36aaa830814fc">&#9670;&nbsp;</a></span>OnResize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::OnResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event handler for resize events. Only used by the engine internally. </p>
<p>Used to notify the driver that the window was resized. Usually, there is no need to call this method. </p>

</div>
</div>
<a id="adde468368b77441ada246e1603da4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde468368b77441ada246e1603da4f47">&#9670;&nbsp;</a></span>queryFeature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::queryFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a>&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the features of the driver. </p>
<p>Returns true if a feature is available </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>Feature to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the feature is available, false if not. </dd></dl>

</div>
</div>
<a id="adde468368b77441ada246e1603da4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde468368b77441ada246e1603da4f47">&#9670;&nbsp;</a></span>queryFeature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::queryFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a57b1721e42a79c5dcf8e830e3621e08f">E_VIDEO_DRIVER_FEATURE</a>&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the features of the driver. </p>
<p>Returns true if a feature is available </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>Feature to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the feature is available, false if not. </dd></dl>

</div>
</div>
<a id="a179990e76fa91175d46c891b3508e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179990e76fa91175d46c891b3508e717">&#9670;&nbsp;</a></span>removeAllTextures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::removeAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all textures from the texture cache and deletes them. </p>
<p>This method can free a lot of memory! Please note that after calling this, the pointer to the <a class="el" href="classirr_1_1video_1_1ITexture.html" title="Interface of a Video Driver dependent Texture. ">ITexture</a> may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. </p>

</div>
</div>
<a id="a179990e76fa91175d46c891b3508e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179990e76fa91175d46c891b3508e717">&#9670;&nbsp;</a></span>removeAllTextures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::removeAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all textures from the texture cache and deletes them. </p>
<p>This method can free a lot of memory! Please note that after calling this, the pointer to the <a class="el" href="classirr_1_1video_1_1ITexture.html" title="Interface of a Video Driver dependent Texture. ">ITexture</a> may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. </p>

</div>
</div>
<a id="ac88319ec41daa23fef2ae935285afcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88319ec41daa23fef2ae935285afcc9">&#9670;&nbsp;</a></span>removeTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::removeTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a texture from the texture cache and deletes it. </p>
<p>This method can free a lot of memory! Please note that after calling this, the pointer to the <a class="el" href="classirr_1_1video_1_1ITexture.html" title="Interface of a Video Driver dependent Texture. ">ITexture</a> may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to delete from the engine cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac88319ec41daa23fef2ae935285afcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88319ec41daa23fef2ae935285afcc9">&#9670;&nbsp;</a></span>removeTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::removeTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a texture from the texture cache and deletes it. </p>
<p>This method can free a lot of memory! Please note that after calling this, the pointer to the <a class="el" href="classirr_1_1video_1_1ITexture.html" title="Interface of a Video Driver dependent Texture. ">ITexture</a> may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to delete from the engine cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cefddb9ebd7f46ee946c04b301a5c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cefddb9ebd7f46ee946c04b301a5c5b">&#9670;&nbsp;</a></span>renameTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::renameTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to the texture to rename. </td></tr>
    <tr><td class="paramname">newName</td><td>New name for the texture. This should be a unique name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cefddb9ebd7f46ee946c04b301a5c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cefddb9ebd7f46ee946c04b301a5c5b">&#9670;&nbsp;</a></span>renameTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::renameTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to the texture to rename. </td></tr>
    <tr><td class="paramname">newName</td><td>New name for the texture. This should be a unique name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2ba500924a7d74fe74dd4724b737628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ba500924a7d74fe74dd4724b737628">&#9670;&nbsp;</a></span>runAllOcclusionQueries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::runAllOcclusionQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all occlusion queries. Draws all meshes stored in queries. </p>
<p>If the meshes shall not be rendered visible, use overrideMaterial to disable the color and depth buffer. </p>

</div>
</div>
<a id="ae2ba500924a7d74fe74dd4724b737628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ba500924a7d74fe74dd4724b737628">&#9670;&nbsp;</a></span>runAllOcclusionQueries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::runAllOcclusionQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all occlusion queries. Draws all meshes stored in queries. </p>
<p>If the meshes shall not be rendered visible, use overrideMaterial to disable the color and depth buffer. </p>

</div>
</div>
<a id="aaf92a35268dad06996c4f5edabec249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf92a35268dad06996c4f5edabec249f">&#9670;&nbsp;</a></span>runOcclusionQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::runOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run occlusion query. Draws mesh stored in query. </p>
<p>If the mesh shall not be rendered visible, use overrideMaterial to disable the color and depth buffer. </p>

</div>
</div>
<a id="aaf92a35268dad06996c4f5edabec249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf92a35268dad06996c4f5edabec249f">&#9670;&nbsp;</a></span>runOcclusionQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::runOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run occlusion query. Draws mesh stored in query. </p>
<p>If the mesh shall not be rendered visible, use overrideMaterial to disable the color and depth buffer. </p>

</div>
</div>
<a id="af78022589e5b7cb42b4d6ed2f7950e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78022589e5b7cb42b4d6ed2f7950e42">&#9670;&nbsp;</a></span>setAllowZWriteOnTransparent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setAllowZWriteOnTransparent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only used by the engine internally. </p>
<p>Passes the global material flag AllowZWriteOnTransparent. Use the SceneManager attribute to set this value from your app. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Default behavior is to disable ZWrite, i.e. false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af78022589e5b7cb42b4d6ed2f7950e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78022589e5b7cb42b4d6ed2f7950e42">&#9670;&nbsp;</a></span>setAllowZWriteOnTransparent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setAllowZWriteOnTransparent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only used by the engine internally. </p>
<p>Passes the global material flag AllowZWriteOnTransparent. Use the SceneManager attribute to set this value from your app. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Default behavior is to disable ZWrite, i.e. false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba8d96a8061264393fc74ac9a3cd04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8d96a8061264393fc74ac9a3cd04f">&#9670;&nbsp;</a></span>setAmbientLight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setAmbientLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColorf.html">SColorf</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only used by the engine internally. </p>
<p>The ambient color is set in the scene manager, see <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8a424accb615c4f60fde59f55033a816" title="Sets ambient color of the scene. ">scene::ISceneManager::setAmbientLight()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>New color of the ambient light. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba8d96a8061264393fc74ac9a3cd04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8d96a8061264393fc74ac9a3cd04f">&#9670;&nbsp;</a></span>setAmbientLight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setAmbientLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SColorf.html">SColorf</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only used by the engine internally. </p>
<p>The ambient color is set in the scene manager, see <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8a424accb615c4f60fde59f55033a816" title="Sets ambient color of the scene. ">scene::ISceneManager::setAmbientLight()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>New color of the ambient light. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a959ac385891941e7ec8d99b2f105b265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ac385891941e7ec8d99b2f105b265">&#9670;&nbsp;</a></span>setClipPlane() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setClipPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a97c9b39d4c6f71dbd9ded0153c4fa7f7">core::plane3df</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or unset a clipping plane. </p>
<p>There are at least 6 clipping planes available for the user to set at will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td class="paramname">plane</td><td>The plane itself. </td></tr>
    <tr><td class="paramname">enable</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the clipping plane is usable. </dd></dl>

</div>
</div>
<a id="a959ac385891941e7ec8d99b2f105b265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ac385891941e7ec8d99b2f105b265">&#9670;&nbsp;</a></span>setClipPlane() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setClipPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a97c9b39d4c6f71dbd9ded0153c4fa7f7">core::plane3df</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or unset a clipping plane. </p>
<p>There are at least 6 clipping planes available for the user to set at will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td class="paramname">plane</td><td>The plane itself. </td></tr>
    <tr><td class="paramname">enable</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the clipping plane is usable. </dd></dl>

</div>
</div>
<a id="af8cbb090b42198244c1703eb17024bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cbb090b42198244c1703eb17024bbc">&#9670;&nbsp;</a></span>setFog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setFog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(0,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a>&#160;</td>
          <td class="paramname"><em>fogType</em> = <code>EFT_FOG_LINEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>density</em> = <code>0.01f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pixelFog</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rangeFog</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fog mode. </p>
<p>These are global values attached to each 3d object rendered, which has the fog flag enabled in its material. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color of the fog </td></tr>
    <tr><td class="paramname">fogType</td><td>Type of fog used </td></tr>
    <tr><td class="paramname">start</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog starts. </td></tr>
    <tr><td class="paramname">end</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog ends. </td></tr>
    <tr><td class="paramname">density</td><td>Only used in exponential fog mode (linearFog=false). Must be a value between 0 and 1. </td></tr>
    <tr><td class="paramname">pixelFog</td><td>Set this to false for vertex fog, and true if you want per-pixel fog. </td></tr>
    <tr><td class="paramname">rangeFog</td><td>Set this to true to enable range-based vertex fog. The distance from the viewer is used to compute the fog, not the z-coordinate. This is better, but slower. This might not be available with all drivers and fog settings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8cbb090b42198244c1703eb17024bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cbb090b42198244c1703eb17024bbc">&#9670;&nbsp;</a></span>setFog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setFog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>(0,&#160;255,&#160;255,&#160;255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44e">E_FOG_TYPE</a>&#160;</td>
          <td class="paramname"><em>fogType</em> = <code>EFT_FOG_LINEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>density</em> = <code>0.01f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pixelFog</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rangeFog</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fog mode. </p>
<p>These are global values attached to each 3d object rendered, which has the fog flag enabled in its material. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color of the fog </td></tr>
    <tr><td class="paramname">fogType</td><td>Type of fog used </td></tr>
    <tr><td class="paramname">start</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog starts. </td></tr>
    <tr><td class="paramname">end</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog ends. </td></tr>
    <tr><td class="paramname">density</td><td>Only used in exponential fog mode (linearFog=false). Must be a value between 0 and 1. </td></tr>
    <tr><td class="paramname">pixelFog</td><td>Set this to false for vertex fog, and true if you want per-pixel fog. </td></tr>
    <tr><td class="paramname">rangeFog</td><td>Set this to true to enable range-based vertex fog. The distance from the viewer is used to compute the fog, not the z-coordinate. This is better, but slower. This might not be available with all drivers and fog settings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c9e31b41b7e6fd26cf65ce538ebab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e31b41b7e6fd26cf65ce538ebab05">&#9670;&nbsp;</a></span>setMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a material. </p>
<p>All 3d drawing functions will draw geometry using this material thereafter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>Material to be used from now on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c9e31b41b7e6fd26cf65ce538ebab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e31b41b7e6fd26cf65ce538ebab05">&#9670;&nbsp;</a></span>setMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1video_1_1SMaterial.html">SMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a material. </p>
<p>All 3d drawing functions will draw geometry using this material thereafter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>Material to be used from now on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef324ed93094f84832e8d31cf0776f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef324ed93094f84832e8d31cf0776f2">&#9670;&nbsp;</a></span>setMaterialRendererName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMaterialRendererName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of a material renderer. </p>
<p>Will have no effect on built-in material renderers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>New name of the material renderer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef324ed93094f84832e8d31cf0776f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef324ed93094f84832e8d31cf0776f2">&#9670;&nbsp;</a></span>setMaterialRendererName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMaterialRendererName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of a material renderer. </p>
<p>Will have no effect on built-in material renderers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device. ">addMaterialRenderer()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>New name of the material renderer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79cbd1329b4206503e9a9593592502ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cbd1329b4206503e9a9593592502ea">&#9670;&nbsp;</a></span>setMinHardwareBufferVertexCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMinHardwareBufferVertexCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimum number of vertices for which a hw buffer will be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of vertices to set as minimum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79cbd1329b4206503e9a9593592502ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cbd1329b4206503e9a9593592502ea">&#9670;&nbsp;</a></span>setMinHardwareBufferVertexCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setMinHardwareBufferVertexCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimum number of vertices for which a hw buffer will be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of vertices to set as minimum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c38a8d8d6d49be53bda55eb0749e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c38a8d8d6d49be53bda55eb0749e7eb">&#9670;&nbsp;</a></span>setRenderTarget() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBackBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearZBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new render target. </p>
<p>This will only work if the driver supports the EVDF_RENDER_TO_TARGET feature, which can be queried with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#adde468368b77441ada246e1603da4f47" title="Queries the features of the driver. ">queryFeature()</a>. Usually, rendering to textures is done in this way: </p><div class="fragment"><div class="line"><span class="comment">// create render target</span></div><div class="line">ITexture* target = driver-&gt;addRenderTargetTexture(core::dimension2d&lt;u32&gt;(128,128), <span class="stringliteral">&quot;rtt1&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">driver-&gt;setRenderTarget(target); <span class="comment">// set render target</span></div><div class="line"><span class="comment">// .. draw stuff here</span></div><div class="line">driver-&gt;setRenderTarget(0); <span class="comment">// set previous render target</span></div></div><!-- fragment --><p> Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target at the same time. It is usually only possible to render into a texture between the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">IVideoDriver::beginScene()</a> and <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a75f61a93c5fc9fdf161c044d27bc994e" title="Presents the rendered image to the screen. ">endScene()</a> method calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>New render target. Must be a texture created with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa704cece826ee37d02e4bb054b0b8797" title="Adds a new render target texture to the texture cache. ">IVideoDriver::addRenderTargetTexture()</a>. If set to 0, it sets the previous render target which was set before the last <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb" title="Sets a new render target. ">setRenderTarget()</a> call. </td></tr>
    <tr><td class="paramname">clearBackBuffer</td><td>Clears the backbuffer of the render target with the color parameter </td></tr>
    <tr><td class="paramname">clearZBuffer</td><td>Clears the zBuffer of the rendertarget. Note that because the frame buffer may share the zbuffer with the rendertarget, its zbuffer might be partially cleared too by this. </td></tr>
    <tr><td class="paramname">color</td><td>The background color for the render target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sucessful and false if not. </dd></dl>

</div>
</div>
<a id="a8c38a8d8d6d49be53bda55eb0749e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c38a8d8d6d49be53bda55eb0749e7eb">&#9670;&nbsp;</a></span>setRenderTarget() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBackBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearZBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new render target. </p>
<p>This will only work if the driver supports the EVDF_RENDER_TO_TARGET feature, which can be queried with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#adde468368b77441ada246e1603da4f47" title="Queries the features of the driver. ">queryFeature()</a>. Usually, rendering to textures is done in this way: </p><div class="fragment"><div class="line"><span class="comment">// create render target</span></div><div class="line">ITexture* target = driver-&gt;addRenderTargetTexture(core::dimension2d&lt;u32&gt;(128,128), <span class="stringliteral">&quot;rtt1&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">driver-&gt;setRenderTarget(target); <span class="comment">// set render target</span></div><div class="line"><span class="comment">// .. draw stuff here</span></div><div class="line">driver-&gt;setRenderTarget(0); <span class="comment">// set previous render target</span></div></div><!-- fragment --><p> Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target at the same time. It is usually only possible to render into a texture between the <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a015b8f2f18c260a00a858181be1e9945" title="Applications must call this method before performing any rendering. ">IVideoDriver::beginScene()</a> and <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a75f61a93c5fc9fdf161c044d27bc994e" title="Presents the rendered image to the screen. ">endScene()</a> method calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>New render target. Must be a texture created with <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#aa704cece826ee37d02e4bb054b0b8797" title="Adds a new render target texture to the texture cache. ">IVideoDriver::addRenderTargetTexture()</a>. If set to 0, it sets the previous render target which was set before the last <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a8c38a8d8d6d49be53bda55eb0749e7eb" title="Sets a new render target. ">setRenderTarget()</a> call. </td></tr>
    <tr><td class="paramname">clearBackBuffer</td><td>Clears the backbuffer of the render target with the color parameter </td></tr>
    <tr><td class="paramname">clearZBuffer</td><td>Clears the zBuffer of the rendertarget. Note that because the frame buffer may share the zbuffer with the rendertarget, its zbuffer might be partially cleared too by this. </td></tr>
    <tr><td class="paramname">color</td><td>The background color for the render target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sucessful and false if not. </dd></dl>

</div>
</div>
<a id="ad75e7606ab186f1e31cc126bcaaeba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75e7606ab186f1e31cc126bcaaeba9c">&#9670;&nbsp;</a></span>setRenderTarget() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">E_RENDER_TARGET</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearTarget</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearZBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set or reset special render targets </p>
<p>This method enables access to special color buffers such as stereoscopic buffers or auxiliary buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Enum value for the render target </td></tr>
    <tr><td class="paramname">clearTarget</td><td>Clears the target buffer with the color parameter </td></tr>
    <tr><td class="paramname">clearZBuffer</td><td>Clears the zBuffer of the rendertarget. Note that because the main frame buffer may share the zbuffer with the rendertarget, its zbuffer might be partially cleared too by this. </td></tr>
    <tr><td class="paramname">color</td><td>The background color for the render target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sucessful and false if not. </dd></dl>

</div>
</div>
<a id="ad75e7606ab186f1e31cc126bcaaeba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75e7606ab186f1e31cc126bcaaeba9c">&#9670;&nbsp;</a></span>setRenderTarget() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a5b61a3f2bd5d458f76f2eb20b0f40972">E_RENDER_TARGET</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearTarget</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearZBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">SColor</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>(0,&#160;0,&#160;0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set or reset special render targets </p>
<p>This method enables access to special color buffers such as stereoscopic buffers or auxiliary buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Enum value for the render target </td></tr>
    <tr><td class="paramname">clearTarget</td><td>Clears the target buffer with the color parameter </td></tr>
    <tr><td class="paramname">clearZBuffer</td><td>Clears the zBuffer of the rendertarget. Note that because the main frame buffer may share the zbuffer with the rendertarget, its zbuffer might be partially cleared too by this. </td></tr>
    <tr><td class="paramname">color</td><td>The background color for the render target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sucessful and false if not. </dd></dl>

</div>
</div>
<a id="a868b58a6b86b9e4841ca3879ce246c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868b58a6b86b9e4841ca3879ce246c4e">&#9670;&nbsp;</a></span>setTextureCreationFlag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setTextureCreationFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables a texture creation flag. </p>
<p>These flags define how textures should be created. By changing this value, you can influence for example the speed of rendering a lot. But please note that the video drivers take this value only as recommendation. It could happen that you enable the ETCF_ALWAYS_16_BIT mode, but the driver still creates 32 bit textures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Texture creation flag. </td></tr>
    <tr><td class="paramname">enabled</td><td>Specifies if the given flag should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a868b58a6b86b9e4841ca3879ce246c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868b58a6b86b9e4841ca3879ce246c4e">&#9670;&nbsp;</a></span>setTextureCreationFlag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setTextureCreationFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876f">E_TEXTURE_CREATION_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables a texture creation flag. </p>
<p>These flags define how textures should be created. By changing this value, you can influence for example the speed of rendering a lot. But please note that the video drivers take this value only as recommendation. It could happen that you enable the ETCF_ALWAYS_16_BIT mode, but the driver still creates 32 bit textures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Texture creation flag. </td></tr>
    <tr><td class="paramname">enabled</td><td>Specifies if the given flag should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf6e88bedf7b91666a2bd34f46e092fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6e88bedf7b91666a2bd34f46e092fc">&#9670;&nbsp;</a></span>setTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transformation matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Transformation type to be set, e.g. view, world, or projection. </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix describing the transformation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf6e88bedf7b91666a2bd34f46e092fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6e88bedf7b91666a2bd34f46e092fc">&#9670;&nbsp;</a></span>setTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a15b57657a320243be03ae6f66fcff43d">E_TRANSFORMATION_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a4c9d4e29899535971052810954a14431">core::matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transformation matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Transformation type to be set, e.g. view, world, or projection. </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix describing the transformation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af03cf9b67bb7b43a8021bbe4baa78a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03cf9b67bb7b43a8021bbe4baa78a08">&#9670;&nbsp;</a></span>setViewPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setViewPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new viewport. </p>
<p>Every rendering operation is done into this new area. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Rectangle defining the new area of rendering operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af03cf9b67bb7b43a8021bbe4baa78a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03cf9b67bb7b43a8021bbe4baa78a08">&#9670;&nbsp;</a></span>setViewPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::setViewPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1rect.html">core::rect</a>&lt; <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new viewport. </p>
<p>Every rendering operation is done into this new area. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Rectangle defining the new area of rendering operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c26904f7d1bf0e37d51fe71562346a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26904f7d1bf0e37d51fe71562346a0">&#9670;&nbsp;</a></span>turnLightOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::turnLightOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>lightIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>turnOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns a dynamic light on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>the index returned by addDynamicLight </td></tr>
    <tr><td class="paramname">turnOn</td><td>true to turn the light on, false to turn it off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c26904f7d1bf0e37d51fe71562346a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26904f7d1bf0e37d51fe71562346a0">&#9670;&nbsp;</a></span>turnLightOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::turnLightOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>lightIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>turnOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns a dynamic light on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>the index returned by addDynamicLight </td></tr>
    <tr><td class="paramname">turnOn</td><td>true to turn the light on, false to turn it off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab611513a8cdb3cc62c29b864de0d1de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab611513a8cdb3cc62c29b864de0d1de7">&#9670;&nbsp;</a></span>updateAllOcclusionQueries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::updateAllOcclusionQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all occlusion queries. Retrieves results from GPU. </p>
<p>If the query shall not block, set the flag to false. Update might not occur in this case, though </p>

</div>
</div>
<a id="ab611513a8cdb3cc62c29b864de0d1de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab611513a8cdb3cc62c29b864de0d1de7">&#9670;&nbsp;</a></span>updateAllOcclusionQueries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::updateAllOcclusionQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all occlusion queries. Retrieves results from GPU. </p>
<p>If the query shall not block, set the flag to false. Update might not occur in this case, though </p>

</div>
</div>
<a id="a626061128fcf018516c6d931bd616ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626061128fcf018516c6d931bd616ea7">&#9670;&nbsp;</a></span>updateOcclusionQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::updateOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update occlusion query. Retrieves results from GPU. </p>
<p>If the query shall not block, set the flag to false. Update might not occur in this case, though </p>

</div>
</div>
<a id="a626061128fcf018516c6d931bd616ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626061128fcf018516c6d931bd616ea7">&#9670;&nbsp;</a></span>updateOcclusionQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::video::IVideoDriver::updateOcclusionQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update occlusion query. Retrieves results from GPU. </p>
<p>If the query shall not block, set the flag to false. Update might not occur in this case, though </p>

</div>
</div>
<a id="a407d6a1483f995060035340e0a92ce9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407d6a1483f995060035340e0a92ce9b">&#9670;&nbsp;</a></span>writeImageToFile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::writeImageToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>param</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the provided image to a file. </p>
<p>Requires that there is a suitable image writer registered for writing the image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to write. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file to write. </td></tr>
    <tr><td class="paramname">param</td><td>Control parameter for the backend (e.g. compression level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful write. </dd></dl>

</div>
</div>
<a id="a407d6a1483f995060035340e0a92ce9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407d6a1483f995060035340e0a92ce9b">&#9670;&nbsp;</a></span>writeImageToFile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::writeImageToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#a6468281622ce3a1c46b72e19f32dded5">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>param</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the provided image to a file. </p>
<p>Requires that there is a suitable image writer registered for writing the image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to write. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file to write. </td></tr>
    <tr><td class="paramname">param</td><td>Control parameter for the backend (e.g. compression level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful write. </dd></dl>

</div>
</div>
<a id="ae12c362cfbc92a7c59b434666c8436c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12c362cfbc92a7c59b434666c8436c0">&#9670;&nbsp;</a></span>writeImageToFile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::writeImageToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IWriteFile.html">io::IWriteFile</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>param</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the provided image to a file. </p>
<p>Requires that there is a suitable image writer registered for writing the image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to write. </td></tr>
    <tr><td class="paramname">file</td><td>An already open <a class="el" href="classirr_1_1io_1_1IWriteFile.html" title="Interface providing write access to a file. ">io::IWriteFile</a> object. The name will be used to determine the appropriate image writer to use. </td></tr>
    <tr><td class="paramname">param</td><td>Control parameter for the backend (e.g. compression level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful write. </dd></dl>

</div>
</div>
<a id="ae12c362cfbc92a7c59b434666c8436c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12c362cfbc92a7c59b434666c8436c0">&#9670;&nbsp;</a></span>writeImageToFile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::video::IVideoDriver::writeImageToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1IImage.html">IImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IWriteFile.html">io::IWriteFile</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>param</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the provided image to a file. </p>
<p>Requires that there is a suitable image writer registered for writing the image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classImage.html" title="Represent a image in the user interface. ">Image</a> to write. </td></tr>
    <tr><td class="paramname">file</td><td>An already open <a class="el" href="classirr_1_1io_1_1IWriteFile.html" title="Interface providing write access to a file. ">io::IWriteFile</a> object. The name will be used to determine the appropriate image writer to use. </td></tr>
    <tr><td class="paramname">param</td><td>Control parameter for the backend (e.g. compression level). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful write. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>indie_share/controller/include/<a class="el" href="indie__share_2controller_2include_2IVideoDriver_8h_source.html">IVideoDriver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
